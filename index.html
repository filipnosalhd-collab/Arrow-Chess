<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strzałkowe Szachy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --bg-dark: #0a0a0f;
        --bg-medium: #12121a;
        --bg-light: #1a1a25;
        --accent-cyan: #00d4ff;
        --accent-magenta: #ff00aa;
        --accent-gold: #ffd700;
        --text-primary: #e8e8f0;
        --text-secondary: #8888aa;
        --white-piece: #e0e8ff;
        --tile-light: #2a2a3a;
        --tile-dark: #1a1a28;
        --highlight: rgba(0, 212, 255, 0.4);
        --threat: rgba(255, 0, 100, 0.4);
        --valid-move: rgba(0, 255, 100, 0.3);
        --zone-center: rgba(255, 215, 0, 0.18);
        --zone-nexus-white: rgba(0, 150, 255, 0.15);
        --zone-phantom-white: rgba(0, 255, 150, 0.15);
        --zone-nexus-black: rgba(255, 100, 100, 0.15);
        --zone-phantom-black: rgba(255, 150, 0, 0.15);
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
      }
      body {
        font-family: "Rajdhani", sans-serif;
        background: var(--bg-dark);
        color: var(--text-primary);
      }
      .bg-pattern {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(0, 212, 255, 0.05) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(255, 0, 170, 0.05) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 0;
      }
      .container {
        position: relative;
        z-index: 1;
        height: 100vh;
        display: flex;
        flex-direction: column;
        padding: 15px;
        overflow: hidden;
        max-width: 1600px;
        margin: 0 auto;
      }
      header {
        text-align: center;
        padding: 15px 0;
        flex-shrink: 0;
      }
      h1 {
        font-family: "Orbitron", monospace;
        font-size: 2.2rem;
        font-weight: 900;
        letter-spacing: 5px;
        background: linear-gradient(
          135deg,
          var(--accent-cyan),
          var(--accent-magenta)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-transform: uppercase;
      }
      .subtitle {
        font-size: 1rem;
        color: var(--text-secondary);
        letter-spacing: 3px;
        text-transform: uppercase;
        margin-top: 5px;
      }
      nav {
        display: flex;
        justify-content: center;
        gap: 12px;
        flex-wrap: wrap;
        padding: 10px 0;
        flex-shrink: 0;
      }
      .nav-btn {
        font-family: "Orbitron", monospace;
        padding: 10px 25px;
        background: transparent;
        border: 2px solid var(--accent-cyan);
        color: var(--accent-cyan);
        font-size: 0.9rem;
        font-weight: 600;
        letter-spacing: 2px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
      }
      .nav-btn:hover,
      .nav-btn.active {
        background: var(--accent-cyan);
        color: var(--bg-dark);
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
      }
      .screen {
        display: none;
        flex: 1;
        overflow: hidden;
      }
      .screen.active {
        display: flex;
        flex-direction: column;
        animation: fadeIn 0.3s ease;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .menu-screen {
        text-align: center;
        justify-content: center;
        align-items: center;
        padding: 20px;
        overflow-y: auto;
      }
      .menu-title {
        font-family: "Orbitron", monospace;
        font-size: 1.5rem;
        margin-bottom: 25px;
        color: var(--accent-gold);
      }
      .game-modes {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 30px;
      }
      .mode-card {
        background: var(--bg-medium);
        border: 2px solid rgba(255, 255, 255, 0.1);
        padding: 25px;
        width: 250px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .mode-card:hover {
        border-color: var(--accent-cyan);
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
      }
      .mode-icon {
        font-size: 2.5rem;
        margin-bottom: 12px;
      }
      .mode-name {
        font-family: "Orbitron", monospace;
        font-size: 1.1rem;
        font-weight: 700;
        margin-bottom: 8px;
      }
      .mode-desc {
        font-size: 0.9rem;
        color: var(--text-secondary);
        line-height: 1.4;
      }
      .difficulty-select {
        margin-top: 25px;
      }
      .difficulty-select h3 {
        font-family: "Orbitron", monospace;
        font-size: 1.1rem;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }
      .difficulty-btns {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
      }
      .diff-btn {
        padding: 12px 28px;
        background: var(--bg-light);
        border: 2px solid transparent;
        color: var(--text-primary);
        font-family: "Rajdhani", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .diff-btn.easy {
        border-color: #00ff88;
        color: #00ff88;
      }
      .diff-btn.medium {
        border-color: var(--accent-gold);
        color: var(--accent-gold);
      }
      .diff-btn.hard {
        border-color: var(--accent-magenta);
        color: var(--accent-magenta);
      }
      .diff-btn.selected {
        background: currentColor;
        color: var(--bg-dark);
      }
      .time-select,
      .increment-select {
        margin-top: 20px;
      }
      .time-select h3,
      .increment-select h4 {
        font-family: "Orbitron", monospace;
        font-size: 1rem;
        margin-bottom: 12px;
        color: var(--text-secondary);
      }
      .time-btns,
      .increment-btns {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .time-btn,
      .inc-btn {
        padding: 10px 18px;
        background: var(--bg-light);
        border: 2px solid var(--accent-cyan);
        color: var(--accent-cyan);
        font-family: "Rajdhani", sans-serif;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .time-btn:hover,
      .inc-btn:hover {
        background: rgba(0, 212, 255, 0.2);
      }
      .time-btn.selected,
      .inc-btn.selected {
        background: var(--accent-cyan);
        color: var(--bg-dark);
      }
      .timer-display {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 20px;
        background: var(--bg-medium);
        border: 2px solid rgba(255, 255, 255, 0.1);
        min-width: 200px;
      }
      .timer-display.active {
        border-color: var(--accent-gold);
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
      }
      .timer-display.low-time {
        border-color: var(--accent-magenta);
        animation: lowTimePulse 0.5s infinite;
      }
      @keyframes lowTimePulse {
        0%,
        100% {
          box-shadow: 0 0 8px rgba(255, 0, 170, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(255, 0, 170, 0.8);
        }
      }
      .timer-label {
        font-family: "Orbitron", monospace;
        font-size: 0.75rem;
        color: var(--text-secondary);
      }
      .timer-value {
        font-family: "Orbitron", monospace;
        font-size: 1.3rem;
        font-weight: bold;
        color: var(--text-primary);
      }
      .white-timer .timer-value {
        color: var(--white-piece);
      }
      .black-timer .timer-value {
        color: var(--accent-magenta);
      }
      .game-screen.active {
        flex-direction: row;
      }
      .game-layout {
        display: flex;
        flex: 1;
        gap: 15px;
        align-items: stretch;
        height: 100%;
        overflow: hidden;
      }
      .side-panel {
        background: var(--bg-medium);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 15px;
        width: 200px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }
      .side-panel::-webkit-scrollbar {
        width: 4px;
      }
      .side-panel::-webkit-scrollbar-thumb {
        background: var(--accent-cyan);
      }
      .panel-title {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        color: var(--accent-cyan);
        margin-bottom: 10px;
        letter-spacing: 1px;
      }
      .captured-pieces {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        min-height: 40px;
      }
      .captured-piece {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        opacity: 0.7;
      }
      .turn-indicator {
        text-align: center;
        padding: 10px;
        background: var(--bg-light);
        margin-bottom: 12px;
        border-left: 3px solid var(--accent-cyan);
      }
      .turn-indicator.white-turn {
        border-left-color: var(--white-piece);
      }
      .turn-indicator.black-turn {
        border-left-color: var(--accent-magenta);
      }
      .turn-label {
        font-family: "Orbitron";
        font-size: 0.7rem;
        color: var(--text-secondary);
      }
      .turn-player {
        font-size: 1.1rem;
        font-weight: bold;
      }
      .move-info-panel {
        margin-top: 10px;
        padding: 10px;
        background: var(--bg-light);
        font-size: 0.85rem;
        text-align: center;
      }
      .move-info-panel .piece-name {
        color: var(--accent-gold);
        font-weight: bold;
        font-size: 0.9rem;
      }
      .move-info-panel .moves-left {
        color: var(--accent-cyan);
        font-family: "Orbitron", monospace;
        font-size: 1rem;
      }
      .game-board-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        flex: 1;
        min-width: 0;
      }
      .game-board-container.flipped {
        flex-direction: column-reverse;
      }
      .board-with-eval {
        display: flex;
        align-items: stretch;
        gap: 10px;
        flex-direction: row;
      }
      .eval-bar {
        width: 25px;
        height: min(65vh, 500px);
        background: var(--accent-magenta);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .eval-toggle {
        writing-mode: vertical-rl;
        text-orientation: mixed;
        font-size: 0.7rem;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        margin-left: -5px;
      }
      .eval-toggle label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        white-space: nowrap;
      }
      .eval-toggle input {
        width: 12px;
        height: 12px;
      }
      .eval-white {
        background: var(--white-piece);
        transition: height 0.5s ease;
        height: 50%;
      }
      .eval-black {
        background: var(--accent-magenta);
        flex: 1;
      }
      .eval-marker {
        position: absolute;
        left: 0;
        right: 0;
        height: 3px;
        background: var(--accent-gold);
        top: 50%;
        transform: translateY(-50%);
        transition: top 0.5s ease;
        box-shadow: 0 0 8px var(--accent-gold);
      }
      .eval-value {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-family: "Orbitron", monospace;
        font-size: 0.65rem;
        color: var(--bg-dark);
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 4px;
        border-radius: 2px;
        white-space: nowrap;
        transition: top 0.5s ease;
      }
      .board-wrapper {
        position: relative;
        padding: 25px;
      }
      .board-labels {
        position: absolute;
        font-family: "Orbitron", monospace;
        font-size: 0.8rem;
        color: var(--text-secondary);
        pointer-events: none;
      }
      .board-label-top {
        top: 3px;
        left: 25px;
        right: 25px;
        display: flex;
        justify-content: space-around;
      }
      .board-label-bottom {
        bottom: 3px;
        left: 25px;
        right: 25px;
        display: flex;
        justify-content: space-around;
      }
      .board-label-left {
        left: 3px;
        top: 25px;
        bottom: 25px;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
      }
      .board-label-right {
        right: 3px;
        top: 25px;
        bottom: 25px;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
      }
      .board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 2px;
        background: rgba(255, 255, 255, 0.12);
        padding: 2px;
        width: min(65vh, 500px);
        height: min(65vh, 500px);
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
        position: relative;
      }
      .tile {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        transition: all 0.2s ease;
      }
      .tile.light {
        background: var(--tile-light);
      }
      .tile.dark {
        background: var(--tile-dark);
      }
      .tile.zone-center {
        background: linear-gradient(
            135deg,
            var(--zone-center),
            var(--zone-center)
          ),
          var(--tile-light);
      }
      .tile.dark.zone-center {
        background: linear-gradient(
            135deg,
            var(--zone-center),
            var(--zone-center)
          ),
          var(--tile-dark);
      }
      .tile.zone-nexus-white {
        background: linear-gradient(
            135deg,
            var(--zone-nexus-white),
            var(--zone-nexus-white)
          ),
          var(--tile-light);
      }
      .tile.dark.zone-nexus-white {
        background: linear-gradient(
            135deg,
            var(--zone-nexus-white),
            var(--zone-nexus-white)
          ),
          var(--tile-dark);
      }
      .tile.zone-phantom-white {
        background: linear-gradient(
            135deg,
            var(--zone-phantom-white),
            var(--zone-phantom-white)
          ),
          var(--tile-light);
      }
      .tile.dark.zone-phantom-white {
        background: linear-gradient(
            135deg,
            var(--zone-phantom-white),
            var(--zone-phantom-white)
          ),
          var(--tile-dark);
      }
      .tile.zone-nexus-black {
        background: linear-gradient(
            135deg,
            var(--zone-nexus-black),
            var(--zone-nexus-black)
          ),
          var(--tile-light);
      }
      .tile.dark.zone-nexus-black {
        background: linear-gradient(
            135deg,
            var(--zone-nexus-black),
            var(--zone-nexus-black)
          ),
          var(--tile-dark);
      }
      .tile.zone-phantom-black {
        background: linear-gradient(
            135deg,
            var(--zone-phantom-black),
            var(--zone-phantom-black)
          ),
          var(--tile-light);
      }
      .tile.dark.zone-phantom-black {
        background: linear-gradient(
            135deg,
            var(--zone-phantom-black),
            var(--zone-phantom-black)
          ),
          var(--tile-dark);
      }
      .tile.selected {
        background: var(--highlight) !important;
        box-shadow: inset 0 0 20px rgba(0, 212, 255, 0.6);
      }
      .tile.valid-move {
        background: var(--valid-move) !important;
        cursor: pointer;
      }
      .tile.threat {
        background: var(--threat) !important;
      }
      .tile.threatened-king {
        animation: kingThreat 0.5s infinite;
      }
      @keyframes kingThreat {
        0%,
        100% {
          box-shadow: inset 0 0 20px rgba(255, 0, 100, 0.8);
        }
        50% {
          box-shadow: inset 0 0 40px rgba(255, 0, 100, 1);
        }
      }
      .piece {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease;
        position: relative;
        z-index: 2;
      }
      .piece:hover {
        transform: scale(1.1);
      }
      .piece.attacking {
        opacity: 0.7;
        cursor: not-allowed;
      }
      .piece.attacking:hover {
        transform: none;
      }
      .piece.white {
        color: var(--white-piece);
        text-shadow: 0 2px 12px rgba(224, 232, 255, 0.6);
      }
      .piece.black {
        color: var(--accent-magenta);
        text-shadow: 0 2px 12px rgba(255, 0, 170, 0.6);
      }
      .piece-symbol {
        font-size: 2rem;
        font-weight: bold;
        line-height: 1;
      }
      /* Animacja ruchu figury */
      .moving-piece {
        position: absolute;
        z-index: 100;
        pointer-events: none;
        transition: left 0.3s ease-out, top 0.3s ease-out;
      }
      .moving-piece .piece-symbol {
        font-size: 2rem;
        font-weight: bold;
      }
      .moving-piece.white {
        color: var(--white-piece);
        text-shadow: 0 2px 15px rgba(224, 232, 255, 0.8);
      }
      .moving-piece.black {
        color: var(--accent-magenta);
        text-shadow: 0 2px 15px rgba(255, 0, 170, 0.8);
      }
      .path-arrow {
        position: absolute;
        font-size: 1.5rem;
        color: var(--accent-gold);
        z-index: 1;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.9);
        pointer-events: none;
      }
      .lock-arrow {
        position: absolute;
        font-size: 1.3rem;
        z-index: 3;
        text-shadow: 0 0 12px currentColor;
        pointer-events: none;
        animation: lockPulse 1s infinite;
      }
      .lock-arrow.white-lock {
        color: var(--white-piece);
      }
      .lock-arrow.black-lock {
        color: var(--accent-magenta);
      }
      @keyframes lockPulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.7;
          transform: scale(1.15);
        }
      }
      .lock-timer {
        position: absolute;
        bottom: 3px;
        right: 4px;
        font-size: 0.75rem;
        font-family: "Orbitron", monospace;
        z-index: 4;
        padding: 1px 4px;
        border-radius: 3px;
        background: rgba(0, 0, 0, 0.8);
      }
      .lock-timer.white-lock {
        color: var(--white-piece);
      }
      .lock-timer.black-lock {
        color: var(--accent-magenta);
      }
      .attacker-pos {
        position: absolute;
        top: 3px;
        left: 4px;
        font-size: 0.9rem;
        z-index: 4;
        opacity: 0.7;
      }
      /* Tarcza Sentinela */
      .tile.sentinel-shield {
        position: relative;
      }
      .tile.sentinel-shield::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 1;
      }
      .tile.white-shield::after {
        background: linear-gradient(
          135deg,
          rgba(224, 232, 255, 0.3),
          rgba(224, 232, 255, 0.1)
        );
        border: 2px solid rgba(224, 232, 255, 0.5);
        box-shadow: inset 0 0 15px rgba(224, 232, 255, 0.4);
      }
      .tile.black-shield::after {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 170, 0.3),
          rgba(255, 0, 170, 0.1)
        );
        border: 2px solid rgba(255, 0, 170, 0.5);
        box-shadow: inset 0 0 15px rgba(255, 0, 170, 0.4);
      }
      .piece.guardian {
        animation: guardianPulse 2s infinite;
      }
      @keyframes guardianPulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.3);
        }
      }
      /* Zamrożenie */
      .piece.frozen {
        filter: brightness(0.7) saturate(0.5);
        opacity: 0.6;
        cursor: not-allowed;
      }
      .piece.frozen::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
          circle,
          rgba(100, 200, 255, 0.3),
          transparent
        );
        pointer-events: none;
      }
      .frozen-timer {
        position: absolute;
        bottom: 2px;
        left: 2px;
        font-size: 0.7rem;
        color: #00d4ff;
        background: rgba(0, 0, 0, 0.7);
        padding: 1px 4px;
        border-radius: 3px;
        z-index: 5;
      }
      /* Figura atakująca - pulsowanie na żółto */
      .piece.is-attacker {
        animation: attackPulse 1s infinite ease-in-out;
      }
      @keyframes attackPulse {
        0%,
        100% {
          background: rgba(255, 200, 0, 0.3);
          box-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
        }
        50% {
          background: rgba(255, 200, 0, 0.7);
          box-shadow: 0 0 25px rgba(255, 200, 0, 0.9);
        }
      }
      /* Figura która brała udział w podwójnym ataku - zielone świecenie */
      .piece.double-attacker {
        animation: doubleAttackPulse 1s infinite ease-in-out;
      }
      @keyframes doubleAttackPulse {
        0%,
        100% {
          background: rgba(0, 255, 100, 0.4);
          box-shadow: 0 0 15px rgba(0, 255, 100, 0.6);
        }
        50% {
          background: rgba(0, 255, 100, 0.8);
          box-shadow: 0 0 30px rgba(0, 255, 100, 1);
        }
      }
      /* Online / Profil */
      .profile-bar {
        position: absolute;
        top: 5px;
        left: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 50;
      }
      .profile-name {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        color: var(--accent-cyan);
        padding: 5px 12px;
        background: var(--bg-medium);
        border: 1px solid var(--accent-cyan);
        cursor: pointer;
      }
      .profile-name:hover {
        background: rgba(0, 212, 255, 0.2);
      }
      .no-profile {
        color: var(--accent-magenta);
        border-color: var(--accent-magenta);
      }
      .no-profile:hover {
        background: rgba(255, 0, 170, 0.2);
      }
      .elo-display {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        color: var(--accent-gold);
        padding: 5px 12px;
        background: var(--bg-medium);
        border: 1px solid var(--accent-gold);
      }
      .opponent-info {
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        padding: 5px 12px;
        background: var(--bg-medium);
        border: 1px solid var(--accent-magenta);
      }
      .vs-text {
        color: var(--text-secondary);
        font-size: 0.7rem;
      }
      .opponent-name {
        color: var(--accent-magenta);
      }
      .opponent-elo {
        color: var(--accent-gold);
        font-size: 0.75rem;
      }
      .elo-toast {
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        font-family: "Orbitron", monospace;
        font-size: 0.9rem;
        z-index: 1002;
        display: none;
        border-radius: 5px;
        animation: eloToastIn 0.3s ease;
      }
      .elo-toast.active {
        display: block;
      }
      .elo-toast.positive {
        background: rgba(0, 180, 100, 0.9);
        color: white;
        border: 2px solid #00ff88;
      }
      .elo-toast.negative {
        background: rgba(180, 0, 50, 0.9);
        color: white;
        border: 2px solid #ff4466;
      }
      @keyframes eloToastIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }
      @media (max-width: 900px) {
        .profile-bar {
          top: 30px;
          left: 5px;
          flex-direction: column;
          gap: 5px;
          align-items: flex-start;
        }
        .profile-name {
          font-size: 0.6rem;
          padding: 3px 8px;
        }
        .elo-display {
          font-size: 0.6rem;
          padding: 3px 8px;
        }
        .opponent-info {
          font-size: 0.6rem;
          padding: 3px 8px;
        }
        .elo-toast {
          top: 80px;
          font-size: 0.75rem;
          padding: 8px 15px;
        }
      }
      /* Ekran profilu */
      .profile-screen {
        text-align: center;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      .profile-form {
        background: var(--bg-medium);
        border: 2px solid var(--accent-cyan);
        padding: 30px;
        max-width: 400px;
      }
      .profile-form h2 {
        font-family: "Orbitron", monospace;
        font-size: 1.3rem;
        color: var(--accent-cyan);
        margin-bottom: 20px;
      }
      .profile-form input {
        width: 100%;
        padding: 12px;
        background: var(--bg-dark);
        border: 2px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        font-family: "Rajdhani", sans-serif;
        font-size: 1.1rem;
        margin-bottom: 15px;
        text-align: center;
      }
      .profile-form input:focus {
        outline: none;
        border-color: var(--accent-cyan);
      }
      .profile-form .save-btn {
        padding: 12px 30px;
        background: var(--accent-cyan);
        border: none;
        color: var(--bg-dark);
        font-family: "Orbitron", monospace;
        font-size: 1rem;
        cursor: pointer;
      }
      .profile-form .save-btn:hover {
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
      }
      /* Lobby Online */
      .lobby-screen {
        text-align: center;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      .lobby-box {
        background: var(--bg-medium);
        border: 2px solid var(--accent-gold);
        padding: 30px;
        max-width: 500px;
        width: 100%;
      }
      .lobby-box h2 {
        font-family: "Orbitron", monospace;
        font-size: 1.3rem;
        color: var(--accent-gold);
        margin-bottom: 20px;
      }
      .lobby-link {
        display: block;
        background: var(--bg-dark);
        padding: 15px;
        margin: 15px 0;
        border: 1px solid rgba(255, 255, 255, 0.2);
        word-break: break-all;
        font-family: monospace;
        font-size: 0.9rem;
        color: var(--accent-cyan);
        text-decoration: none;
      }
      .lobby-link:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: var(--accent-cyan);
      }
      .lobby-link-copy {
        padding: 8px 20px;
        background: var(--accent-cyan);
        border: none;
        color: var(--bg-dark);
        font-family: "Orbitron", monospace;
        font-size: 0.8rem;
        cursor: pointer;
        margin-top: 10px;
      }
      .lobby-players {
        margin: 20px 0;
        padding: 15px;
        background: var(--bg-light);
      }
      .lobby-players h3 {
        font-family: "Orbitron", monospace;
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-bottom: 10px;
      }
      .player-slot {
        padding: 10px;
        margin: 5px 0;
        background: var(--bg-dark);
        border-left: 3px solid var(--accent-cyan);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .player-slot.empty {
        border-left-color: var(--text-secondary);
        opacity: 0.5;
      }
      .player-slot .player-name {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
      }
      .player-slot .player-status {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }
      .waiting-text {
        color: var(--accent-gold);
        font-size: 1rem;
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
      .start-game-btn {
        padding: 15px 40px;
        background: var(--accent-gold);
        border: none;
        color: var(--bg-dark);
        font-family: "Orbitron", monospace;
        font-size: 1rem;
        cursor: pointer;
        margin-top: 15px;
      }
      .start-game-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .start-game-btn:not(:disabled):hover {
        box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
      }
      .leave-lobby-btn {
        padding: 10px 25px;
        background: transparent;
        border: 2px solid var(--accent-magenta);
        color: var(--accent-magenta);
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        cursor: pointer;
        margin-top: 15px;
      }
      .leave-lobby-btn:hover {
        background: rgba(255, 0, 170, 0.2);
      }
      .lobby-settings {
        margin: 15px 0;
        padding: 15px;
        background: var(--bg-light);
      }
      .lobby-settings h3 {
        font-family: "Orbitron", monospace;
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-bottom: 10px;
      }
      .lobby-time-btns,
      .lobby-inc-btns {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .lobby-time-btn,
      .lobby-inc-btn {
        padding: 8px 12px;
        font-size: 0.75rem;
      }
      .lobby-settings-display {
        color: var(--accent-cyan);
        font-size: 0.9rem;
        margin: 10px 0;
      }
      .pending-captures {
        margin-top: 12px;
        padding: 10px;
        background: rgba(255, 0, 100, 0.1);
        border: 1px solid rgba(255, 0, 100, 0.3);
      }
      .pending-title {
        font-family: "Orbitron", monospace;
        font-size: 0.75rem;
        color: var(--accent-magenta);
        margin-bottom: 8px;
      }
      .pending-item {
        font-size: 0.85rem;
        color: var(--text-secondary);
        padding: 4px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }
      /* Przyciski online (remis, poddanie) */
      .online-actions {
        margin-top: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .draw-btn,
      .resign-btn {
        padding: 10px 15px;
        font-family: "Orbitron", monospace;
        font-size: 0.75rem;
        cursor: pointer;
        border: none;
      }
      .draw-btn {
        background: var(--accent-gold);
        color: var(--bg-dark);
      }
      .draw-btn:hover {
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      }
      .draw-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .resign-btn {
        background: var(--accent-magenta);
        color: white;
      }
      .resign-btn:hover {
        box-shadow: 0 0 15px rgba(255, 0, 170, 0.5);
      }
      /* Modal propozycji remisu */
      .draw-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      .draw-modal.active {
        display: flex;
      }
      .draw-modal-content {
        background: var(--bg-medium);
        border: 2px solid var(--accent-gold);
        padding: 30px;
        text-align: center;
        max-width: 350px;
        animation: modalPop 0.3s ease;
      }
      @keyframes modalPop {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .draw-modal-text {
        font-family: "Orbitron", monospace;
        font-size: 1.1rem;
        color: var(--accent-gold);
        margin-bottom: 20px;
      }
      .draw-modal-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-bottom: 15px;
      }
      .draw-accept {
        padding: 12px 25px;
        background: var(--accent-cyan);
        border: none;
        color: var(--bg-dark);
        font-family: "Orbitron", monospace;
        font-size: 0.9rem;
        cursor: pointer;
      }
      .draw-accept:hover {
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
      }
      .draw-decline {
        padding: 12px 25px;
        background: var(--accent-magenta);
        border: none;
        color: white;
        font-family: "Orbitron", monospace;
        font-size: 0.9rem;
        cursor: pointer;
      }
      .draw-decline:hover {
        box-shadow: 0 0 20px rgba(255, 0, 170, 0.5);
      }
      .draw-modal-hint {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }
      /* Toast z odpowiedzią */
      .draw-toast {
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-medium);
        border: 2px solid var(--accent-cyan);
        padding: 15px 30px;
        font-family: "Orbitron", monospace;
        font-size: 1rem;
        z-index: 1001;
        display: none;
        animation: toastIn 0.3s ease;
      }
      .draw-toast.active {
        display: block;
      }
      .draw-toast.accepted {
        border-color: var(--accent-cyan);
        color: var(--accent-cyan);
      }
      .draw-toast.declined {
        border-color: var(--accent-magenta);
        color: var(--accent-magenta);
      }
      .draw-toast.sent {
        border-color: var(--accent-gold);
        color: var(--accent-gold);
      }
      @keyframes toastIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }
      .legend {
        margin-top: 12px;
        padding: 10px;
        background: var(--bg-light);
      }
      .legend-title {
        font-family: "Orbitron", monospace;
        font-size: 0.75rem;
        color: var(--accent-gold);
        margin-bottom: 8px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-bottom: 5px;
      }
      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .legend-color.center {
        background: rgba(255, 215, 0, 0.5);
      }
      .legend-color.nexus-white {
        background: rgba(0, 150, 255, 0.5);
      }
      .legend-color.phantom-white {
        background: rgba(0, 255, 150, 0.5);
      }
      .legend-color.nexus-black {
        background: rgba(255, 100, 100, 0.5);
      }
      .legend-color.phantom-black {
        background: rgba(255, 150, 0, 0.5);
      }
      .zone-toggle {
        margin-top: 8px;
      }
      .zone-toggle label {
        font-size: 0.75rem;
        color: var(--text-secondary);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .zone-toggle input {
        cursor: pointer;
        width: 14px;
        height: 14px;
      }
      .rules-screen {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
      }
      .rules-screen::-webkit-scrollbar {
        width: 6px;
      }
      .rules-screen::-webkit-scrollbar-thumb {
        background: var(--accent-cyan);
      }
      .rules-section {
        background: var(--bg-medium);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 20px;
        margin-bottom: 15px;
      }
      .rules-section h2 {
        font-family: "Orbitron", monospace;
        font-size: 1.1rem;
        color: var(--accent-cyan);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 212, 255, 0.3);
      }
      .rules-icons-legend {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin: 15px 0;
        padding: 15px;
        background: var(--bg-light);
        border-radius: 5px;
      }
      .rules-icon-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }
      .rules-section h3 {
        font-family: "Orbitron", monospace;
        font-size: 0.95rem;
        color: var(--accent-gold);
        margin: 12px 0 8px;
      }
      .rules-section p {
        color: var(--text-secondary);
        line-height: 1.6;
        margin-bottom: 8px;
        font-size: 0.9rem;
      }
      .piece-showcase {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 12px;
        margin-top: 12px;
      }
      .piece-card {
        background: var(--bg-light);
        padding: 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-left: 3px solid var(--accent-cyan);
      }
      .piece-card-symbol {
        font-size: 2.2rem;
        color: var(--white-piece);
      }
      .piece-card-info h4 {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        margin-bottom: 4px;
      }
      .piece-card-info p {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin: 0;
        line-height: 1.4;
      }
      .highlight-box {
        background: rgba(0, 212, 255, 0.1);
        border-left: 3px solid var(--accent-cyan);
        padding: 10px 12px;
        margin: 10px 0;
        font-size: 0.85rem;
      }
      .warning-box {
        background: rgba(255, 0, 100, 0.1);
        border-left: 3px solid var(--accent-magenta);
        padding: 10px 12px;
        margin: 10px 0;
        font-size: 0.85rem;
      }
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal-overlay.active {
        display: flex;
      }
      .modal {
        background: var(--bg-medium);
        border: 2px solid var(--accent-cyan);
        padding: 35px;
        text-align: center;
        max-width: 400px;
        animation: modalIn 0.3s ease;
      }
      @keyframes modalIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal h2 {
        font-family: "Orbitron", monospace;
        font-size: 1.8rem;
        margin-bottom: 15px;
        background: linear-gradient(
          135deg,
          var(--accent-cyan),
          var(--accent-magenta)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      .modal p {
        color: var(--text-secondary);
        margin-bottom: 20px;
        font-size: 1.1rem;
      }
      .modal-btn {
        padding: 12px 35px;
        background: var(--accent-cyan);
        border: none;
        color: var(--bg-dark);
        font-family: "Orbitron", monospace;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .modal-btn:hover {
        box-shadow: 0 0 25px rgba(0, 212, 255, 0.6);
      }
      .move-log {
        flex: 1;
        overflow-y: auto;
        font-size: 0.8rem;
      }
      .move-log::-webkit-scrollbar {
        width: 4px;
      }
      .move-log::-webkit-scrollbar-thumb {
        background: var(--accent-cyan);
      }
      .log-entry {
        padding: 6px 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .log-entry:hover {
        background: rgba(255, 255, 255, 0.05);
      }
      .log-entry.active-state {
        background: rgba(0, 212, 255, 0.2);
        border-left: 2px solid var(--accent-cyan);
      }
      .log-entry.white-move {
        border-left: 2px solid var(--white-piece);
      }
      .log-entry.black-move {
        border-left: 2px solid var(--accent-magenta);
      }
      .analysis-controls {
        margin-top: 10px;
        padding: 10px;
        background: rgba(0, 212, 255, 0.1);
        border: 1px solid rgba(0, 212, 255, 0.3);
      }
      .state-info {
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-bottom: 8px;
        text-align: center;
      }
      .analysis-btns {
        display: flex;
        justify-content: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .analysis-btn {
        padding: 6px 12px;
        background: var(--bg-light);
        border: 1px solid var(--accent-cyan);
        color: var(--accent-cyan);
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .analysis-btn:hover {
        background: var(--accent-cyan);
        color: var(--bg-dark);
      }
      .analysis-btn.reset-btn {
        border-color: var(--accent-magenta);
        color: var(--accent-magenta);
      }
      .analysis-btn.reset-btn:hover {
        background: var(--accent-magenta);
      }
      .whatif-panel {
        margin-top: 8px;
        padding: 8px;
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid rgba(255, 215, 0, 0.3);
        text-align: center;
      }
      .whatif-info {
        font-size: 0.7rem;
        color: var(--accent-gold);
        margin-bottom: 5px;
      }
      .whatif-counter {
        font-family: "Orbitron", monospace;
        font-size: 0.85rem;
        color: var(--accent-gold);
      }

      /* Mobile turn info - ukryte na desktop */
      .mobile-turn-info {
        display: none;
      }

      /* Animacja obrotu planszy */
      .board-wrapper {
        transition: transform 0.5s ease-in-out;
      }
      .board-wrapper.rotated {
        transform: rotate(180deg);
      }
      .board-wrapper.rotated .piece {
        transform: rotate(180deg);
      }
      .board-wrapper.rotated .lock-timer {
        transform: rotate(180deg);
        top: 3px;
        bottom: auto;
        right: auto;
        left: 4px;
      }
      .board-wrapper.rotated .attacker-pos {
        transform: rotate(180deg);
        bottom: 3px;
        top: auto;
        left: auto;
        right: 4px;
      }
      .board-wrapper.rotated .move-icon {
        transform: rotate(180deg);
      }
      .board-wrapper.rotated .move-icons-legend {
        transform: rotate(180deg);
      }

      /* Emotki ruchów */
      .move-icon {
        position: absolute;
        top: -8px;
        right: -5px;
        font-size: 0.7rem;
        font-weight: bold;
        padding: 2px 4px;
        border-radius: 4px;
        z-index: 10;
        font-family: "Orbitron", monospace;
        line-height: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .move-icon.brilliant {
        background: #1baca6;
        color: white;
      }
      .move-icon.great {
        background: #5c8bb0;
        color: white;
      }
      .move-icon.good {
        background: #97af8b;
        color: white;
      }
      .move-icon.book {
        background: #a88865;
        color: white;
      }
      .move-icon.inaccuracy {
        background: #e6a837;
        color: black;
      }
      .move-icon.mistake {
        background: #e68a37;
        color: white;
      }
      .move-icon.blunder {
        background: #ca3431;
        color: white;
      }

      /* Legenda emotek */
      .move-icons-legend {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .icon-item {
        font-size: 0.65rem;
        font-weight: bold;
        padding: 3px 6px;
        border-radius: 3px;
        font-family: "Orbitron", monospace;
      }
      .icon-item.brilliant {
        background: #1baca6;
        color: white;
      }
      .icon-item.great {
        background: #5c8bb0;
        color: white;
      }
      .icon-item.good {
        background: #97af8b;
        color: white;
      }
      .icon-item.book {
        background: #a88865;
        color: white;
      }
      .icon-item.inaccuracy {
        background: #e6a837;
        color: black;
      }
      .icon-item.mistake {
        background: #e68a37;
        color: white;
      }
      .icon-item.blunder {
        background: #ca3431;
        color: white;
      }

      /* MOBILE - layout jak chess.com - szachownica fullscreen */
      @media (max-width: 900px) {
        .container {
          padding: 0;
          height: 100vh;
        }
        header {
          display: none;
        }
        nav {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          z-index: 100;
          background: var(--bg-dark);
          padding: 3px;
          gap: 3px;
          justify-content: center;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .nav-btn {
          padding: 4px 10px;
          font-size: 0.55rem;
          border-width: 1px;
        }
        .game-screen.active {
          padding-top: 28px;
          height: 100%;
        }
        .game-layout {
          flex-direction: column;
          gap: 0;
          height: 100%;
        }
        .side-panel {
          display: none !important;
        }
        .game-board-container {
          flex: 1;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 5px;
        }
        .board {
          width: min(calc(100vh - 140px), calc(100vw - 10px));
          height: min(calc(100vh - 140px), calc(100vw - 10px));
          gap: 0;
          padding: 0;
        }
        .board-wrapper {
          padding: 0;
        }
        .board-labels {
          display: none;
        }
        .tile {
          border: none;
        }
        .piece-symbol {
          font-size: clamp(1.2rem, 10vmin, 3rem);
        }
        .path-arrow {
          font-size: clamp(0.8rem, 6vmin, 2rem);
        }
        .lock-arrow {
          font-size: clamp(0.7rem, 5vmin, 1.6rem);
        }
        .lock-timer {
          font-size: clamp(0.4rem, 2vmin, 0.8rem);
          padding: 1px 3px;
          bottom: 2px;
          right: 3px;
        }
        .attacker-pos {
          font-size: clamp(0.4rem, 2vmin, 0.8rem);
          top: 2px;
          left: 3px;
        }
        .timer-display {
          position: fixed;
          left: 50%;
          transform: translateX(-50%);
          padding: 4px 15px;
          border-width: 1px;
          z-index: 50;
          background: var(--bg-dark);
        }
        .timer-display.black-timer {
          top: 32px;
        }
        .timer-display.white-timer {
          bottom: 8px;
        }
        .timer-label {
          font-size: 0.5rem;
        }
        .timer-value {
          font-size: 0.9rem;
        }
        /* Mobile turn info między zegarami */
        .mobile-turn-info {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 8px 20px;
          background: var(--bg-medium);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 5px;
          margin: 5px 0;
        }
        .mobile-turn-player {
          font-family: "Orbitron", monospace;
          font-size: 1rem;
          font-weight: bold;
          color: var(--accent-cyan);
          letter-spacing: 2px;
        }
        .mobile-turn-player.white-turn {
          color: var(--white-piece);
        }
        .mobile-turn-player.black-turn {
          color: var(--accent-magenta);
        }
        .mobile-turn-moves {
          font-size: 0.75rem;
          color: var(--text-secondary);
          margin-top: 2px;
        }
        .modal {
          padding: 25px;
          max-width: 300px;
        }
        .modal h2 {
          font-size: 1.4rem;
        }
        .modal p {
          font-size: 1rem;
          margin-bottom: 15px;
        }
        .modal-btn {
          padding: 12px 30px;
          font-size: 0.9rem;
        }
      }
      @media (max-height: 700px) and (min-width: 901px) {
        .board {
          width: min(55vh, 450px);
          height: min(55vh, 450px);
        }
        header {
          padding: 5px 0;
        }
        h1 {
          font-size: 1.5rem;
        }
        nav {
          padding: 5px 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>
    <div class="container">
      <div class="profile-bar">
        <div
          class="profile-name no-profile"
          id="profile-display"
          onclick="showProfileScreen()"
        >
          ⚙ Ustaw profil
        </div>
        <div class="elo-display" id="elo-display">⭐ 0 ELO</div>
        <div class="opponent-info" id="opponent-info" style="display: none">
          <span class="vs-text">vs</span>
          <span class="opponent-name" id="opponent-name">-</span>
          <span class="opponent-elo" id="opponent-elo">⭐ 0</span>
        </div>
      </div>

      <!-- Toast zmiany ELO -->
      <div class="elo-toast" id="elo-toast"></div>
      <header>
        <h1>Strzałkowe Szachy</h1>
        <p class="subtitle">Strategia • Planowanie • Taktyka</p>
      </header>
      <nav>
        <button class="nav-btn active" data-screen="menu">Menu</button>
        <button class="nav-btn" data-screen="game">Gra</button>
        <button class="nav-btn" data-screen="rules">Zasady</button>
      </nav>

      <!-- Ekran profilu -->
      <div class="screen profile-screen" id="profile-screen">
        <div class="profile-form">
          <h2>🎮 Twój Profil</h2>
          <p style="color: var(--text-secondary); margin-bottom: 15px">
            Ustaw nazwę aby grać online
          </p>
          <input
            type="text"
            id="profile-name-input"
            placeholder="Wpisz nazwę gracza..."
            maxlength="20"
          />
          <button class="save-btn" onclick="saveProfile()">Zapisz</button>
          <button
            class="leave-lobby-btn"
            onclick="showScreen('menu')"
            style="margin-left: 10px"
          >
            Anuluj
          </button>
        </div>
      </div>

      <!-- Ekran Lobby -->
      <div class="screen lobby-screen" id="lobby-screen">
        <div class="lobby-box">
          <h2>🌐 Lobby Online</h2>
          <a class="lobby-link" id="lobby-link" href="#" target="_blank"
            >Generowanie linku...</a
          >
          <button class="lobby-link-copy" onclick="copyLobbyLink()">
            📋 Kopiuj link
          </button>
          <div class="lobby-players">
            <h3>Gracze (1/2)</h3>
            <div class="player-slot" id="player1-slot">
              <span class="player-name" id="player1-name">Host</span>
              <span class="player-status">👑 Host</span>
            </div>
            <div class="player-slot empty" id="player2-slot">
              <span class="player-name">Oczekiwanie...</span>
              <span class="player-status">⏳</span>
            </div>
          </div>
          <div class="lobby-settings" id="lobby-settings">
            <h3>⏱️ Czas na partię</h3>
            <div class="time-options lobby-time-btns">
              <button class="time-btn lobby-time-btn" data-time="0">∞</button>
              <button class="time-btn lobby-time-btn" data-time="3">
                3 min
              </button>
              <button class="time-btn lobby-time-btn selected" data-time="5">
                5 min
              </button>
              <button class="time-btn lobby-time-btn" data-time="10">
                10 min
              </button>
              <button class="time-btn lobby-time-btn" data-time="15">
                15 min
              </button>
            </div>
            <div class="increment-options lobby-inc-btns" id="lobby-increment">
              <h3>⏱️ Bonus za ruch</h3>
              <button class="inc-btn lobby-inc-btn" data-inc="0">+0s</button>
              <button class="inc-btn lobby-inc-btn selected" data-inc="2">
                +2s
              </button>
              <button class="inc-btn lobby-inc-btn" data-inc="3">+3s</button>
              <button class="inc-btn lobby-inc-btn" data-inc="5">+5s</button>
            </div>
          </div>
          <div
            class="lobby-settings-display"
            id="lobby-settings-display"
            style="display: none"
          >
            <p>
              ⏱️ Czas: <span id="lobby-time-display">5 min</span> | Bonus:
              <span id="lobby-inc-display">+2s</span>
            </p>
          </div>
          <p class="waiting-text" id="waiting-text">
            Czekam na drugiego gracza...
          </p>
          <button
            class="start-game-btn"
            id="start-online-btn"
            disabled
            onclick="startOnlineGame()"
          >
            ▶ Rozpocznij Grę
          </button>
          <br />
          <button class="leave-lobby-btn" onclick="leaveLobby()">
            ✖ Opuść Lobby
          </button>
        </div>
      </div>

      <div class="screen menu-screen active" id="menu-screen">
        <h2 class="menu-title">Wybierz Tryb Gry</h2>
        <div class="game-modes">
          <div class="mode-card" data-mode="pvp">
            <div class="mode-icon">⚔️</div>
            <div class="mode-name">Gracz vs Gracz</div>
            <div class="mode-desc">
              Graj z przyjacielem na jednym urządzeniu.
            </div>
          </div>
          <div class="mode-card" data-mode="bot">
            <div class="mode-icon">🤖</div>
            <div class="mode-name">Gracz vs Bot</div>
            <div class="mode-desc">Zmierz się z komputerem.</div>
          </div>
          <div class="mode-card" data-mode="online">
            <div class="mode-icon">🌐</div>
            <div class="mode-name">Online</div>
            <div class="mode-desc">Stwórz lobby i graj przez internet.</div>
          </div>
        </div>
        <div
          class="difficulty-select"
          id="difficulty-select"
          style="display: none"
        >
          <h3>Wybierz Poziom Trudności</h3>
          <div class="difficulty-btns">
            <button class="diff-btn easy" data-diff="easy">Łatwy</button>
            <button class="diff-btn medium" data-diff="medium">Średni</button>
            <button class="diff-btn hard" data-diff="hard">Trudny</button>
          </div>
        </div>
        <div class="time-select" id="time-select" style="display: none">
          <h3>Czas na grę</h3>
          <div class="time-btns">
            <button class="time-btn" data-time="0">∞ Bez limitu</button>
            <button class="time-btn" data-time="1">1 min</button>
            <button class="time-btn" data-time="3">3 min</button>
            <button class="time-btn" data-time="5">5 min</button>
            <button class="time-btn" data-time="10">10 min</button>
            <button class="time-btn" data-time="15">15 min</button>
          </div>
          <div
            class="increment-select"
            id="increment-select"
            style="display: none"
          >
            <h4>Bonus po ruchu</h4>
            <div class="increment-btns">
              <button class="inc-btn" data-inc="0">+0s</button>
              <button class="inc-btn" data-inc="1">+1s</button>
              <button class="inc-btn" data-inc="2">+2s</button>
              <button class="inc-btn" data-inc="3">+3s</button>
              <button class="inc-btn" data-inc="5">+5s</button>
              <button class="inc-btn" data-inc="10">+10s</button>
            </div>
          </div>
        </div>
      </div>
      <div class="screen" id="game-screen">
        <div class="game-layout">
          <div class="side-panel">
            <div class="turn-indicator white-turn" id="turn-indicator">
              <div class="turn-label">TURA</div>
              <div class="turn-player" id="current-player">BIAŁE</div>
            </div>
            <div
              class="move-info-panel"
              id="move-info-panel"
              style="display: none"
            >
              <div class="piece-name" id="selected-piece-name">-</div>
              <div>
                Pozostało kroków:
                <span class="moves-left" id="moves-left">0</span>
              </div>
            </div>
            <div style="margin-top: 20px">
              <div class="panel-title">Zbite przez Białe</div>
              <div class="captured-pieces" id="white-captured"></div>
            </div>
            <div style="margin-top: 20px">
              <div class="panel-title">Zbite przez Czarne</div>
              <div class="captured-pieces" id="black-captured"></div>
            </div>
            <div
              class="pending-captures"
              id="pending-captures"
              style="display: none"
            >
              <div class="pending-title">⚠️ Aktywne Blokady</div>
              <div id="pending-list"></div>
            </div>
            <div
              class="online-actions"
              id="online-actions"
              style="display: none"
            >
              <button class="draw-btn" id="btn-offer-draw">
                🤝 Zaproponuj remis
              </button>
              <button class="resign-btn" id="btn-resign">🏳️ Poddaj się</button>
            </div>
          </div>

          <!-- Modal propozycji remisu -->
          <div class="draw-modal" id="draw-modal">
            <div class="draw-modal-content">
              <div class="draw-modal-text" id="draw-modal-text">
                Przeciwnik proponuje remis
              </div>
              <div class="draw-modal-buttons">
                <button class="draw-accept" id="draw-accept">✓ Akceptuj</button>
                <button class="draw-decline" id="draw-decline">✗ Odrzuć</button>
              </div>
              <div class="draw-modal-hint">
                Wykonanie ruchu automatycznie odrzuca propozycję
              </div>
            </div>
          </div>

          <!-- Toast z odpowiedzią -->
          <div class="draw-toast" id="draw-toast"></div>
          <div class="game-board-container">
            <div class="timer-display black-timer" id="black-timer">
              <span class="timer-label">CZARNE</span>
              <span class="timer-value" id="black-time">∞</span>
            </div>
            <div class="mobile-turn-info" id="mobile-turn-info">
              <div class="mobile-turn-player" id="mobile-turn-player">
                BIAŁE
              </div>
              <div class="mobile-turn-moves" id="mobile-turn-moves"></div>
            </div>
            <div class="board-with-eval">
              <div class="eval-bar" id="eval-bar">
                <div class="eval-white" id="eval-white"></div>
                <div class="eval-black" id="eval-black"></div>
                <div class="eval-marker" id="eval-marker"></div>
                <div class="eval-value" id="eval-value">0.0</div>
              </div>
              <div class="eval-toggle">
                <label
                  ><input type="checkbox" id="show-eval" checked /> Pokaż pasek
                  szans</label
                >
              </div>
              <div class="board-wrapper" id="board-wrapper">
                <div class="board-labels board-label-top">
                  <span>a</span><span>b</span><span>c</span><span>d</span
                  ><span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
                <div class="board-labels board-label-bottom">
                  <span>a</span><span>b</span><span>c</span><span>d</span
                  ><span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
                <div class="board-labels board-label-left">
                  <span>8</span><span>7</span><span>6</span><span>5</span
                  ><span>4</span><span>3</span><span>2</span><span>1</span>
                </div>
                <div class="board-labels board-label-right">
                  <span>8</span><span>7</span><span>6</span><span>5</span
                  ><span>4</span><span>3</span><span>2</span><span>1</span>
                </div>
                <div class="board" id="board"></div>
                <div class="move-icons-legend">
                  <span class="icon-item brilliant">!!</span>
                  <span class="icon-item great">!</span>
                  <span class="icon-item good">✓</span>
                  <span class="icon-item book">📖</span>
                  <span class="icon-item inaccuracy">?!</span>
                  <span class="icon-item mistake">?</span>
                  <span class="icon-item blunder">??</span>
                </div>
              </div>
            </div>
            <div class="timer-display white-timer" id="white-timer">
              <span class="timer-label">BIAŁE</span>
              <span class="timer-value" id="white-time">∞</span>
            </div>
          </div>
          <div class="side-panel">
            <div class="panel-title">Historia Ruchów</div>
            <div class="move-log" id="move-log"></div>
            <div class="legend">
              <div class="legend-title">STREFY SZACHOWNICY</div>
              <div class="legend-item">
                <div class="legend-color center"></div>
                Centrum
              </div>
              <div class="legend-item">
                <div class="legend-color nexus-white"></div>
                Skrzydło Nexusa (Białe)
              </div>
              <div class="legend-item">
                <div class="legend-color phantom-white"></div>
                Skrzydło Phantoma (Białe)
              </div>
              <div class="legend-item">
                <div class="legend-color nexus-black"></div>
                Skrzydło Nexusa (Czarne)
              </div>
              <div class="legend-item">
                <div class="legend-color phantom-black"></div>
                Skrzydło Phantoma (Czarne)
              </div>
              <div class="zone-toggle">
                <label
                  ><input type="checkbox" id="show-zones" checked /> Pokaż
                  strefy</label
                >
              </div>
            </div>
            <div
              class="analysis-controls"
              id="analysis-controls"
              style="display: none"
            >
              <div class="panel-title">📊 ANALIZA</div>
              <div class="state-info" id="state-info">-</div>
              <div class="analysis-btns">
                <button class="analysis-btn" id="btn-first">⏮</button>
                <button class="analysis-btn" id="btn-prev">◀</button>
                <button class="analysis-btn" id="btn-next">▶</button>
                <button class="analysis-btn" id="btn-last">⏭</button>
              </div>
              <div class="whatif-panel" id="whatif-panel" style="display: none">
                <div class="whatif-info">
                  🔬 Tryb "Co jeśli?" - testuj alternatywne ruchy
                </div>
                <div class="whatif-counter">
                  Rundy: <span id="whatif-rounds">0</span>
                </div>
                <button
                  class="analysis-btn reset-btn"
                  id="btn-reset-whatif"
                  style="margin-top: 10px"
                >
                  ↺ Resetuj
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="screen rules-screen" id="rules-screen">
        <div class="rules-section">
          <h2>◈ Ikony Oceny Ruchów</h2>
          <p>Po każdym ruchu wyświetlana jest ikona oceny jakości ruchu:</p>
          <div class="rules-icons-legend">
            <div class="rules-icon-item">
              <span class="icon-item brilliant">!!</span>
              <strong>Brilliant</strong> – genialny ruch, znacząco poprawiający
              pozycję
            </div>
            <div class="rules-icon-item">
              <span class="icon-item great">!</span> <strong>Great</strong> –
              świetny ruch, dobra decyzja
            </div>
            <div class="rules-icon-item">
              <span class="icon-item good">✓</span> <strong>Good</strong> –
              dobry, solidny ruch
            </div>
            <div class="rules-icon-item">
              <span class="icon-item book">📖</span> <strong>Book</strong> –
              neutralny ruch, ani dobry ani zły
            </div>
            <div class="rules-icon-item">
              <span class="icon-item inaccuracy">?!</span>
              <strong>Inaccuracy</strong> – niedokładność, można było lepiej
            </div>
            <div class="rules-icon-item">
              <span class="icon-item mistake">?</span>
              <strong>Mistake</strong> – błąd, pogarsza pozycję
            </div>
            <div class="rules-icon-item">
              <span class="icon-item blunder">??</span>
              <strong>Blunder</strong> – poważny błąd, znacząco pogarsza pozycję
            </div>
          </div>

          <h2>◈ Podwójny Atak</h2>
          <div class="highlight-box">
            <p>
              <strong>Zasada podwójnego ataku:</strong> Jeśli jedna figura jest
              atakowana przez <strong>2 lub więcej</strong> figur jednocześnie
              (nie licząc Phantoma, który zbija natychmiast), następuje
              <strong>natychmiastowe zbicie</strong> – ofiara nie ma czasu na
              ucieczkę!
            </p>
            <p>
              • Pierwszy atakujący (ten który zaatakował wcześniej) wchodzi na
              miejsce zbitej figury
            </p>
            <p>• Pozostali atakujący zostają na swoich pozycjach</p>
            <p>
              • Jeśli Nexus jest pod podwójnym atakiem →
              <strong>natychmiastowy mat!</strong>
            </p>
          </div>

          <h2>◈ Warunki Remisu</h2>
          <div class="highlight-box">
            <p>
              <strong
                >Gra kończy się remisem w następujących sytuacjach:</strong
              >
            </p>
            <p>
              • <strong>10 ruchów bez ataku:</strong> Jeśli przez 10 kolejnych
              ruchów żaden gracz nie zaatakuje żadnej figury i nie ma aktywnych
              blokad, gra kończy się remisem. <strong>Uwaga:</strong> Ruchy
              pionkami (Shard) nie są liczone do tego limitu!
            </p>
            <p>
              • <strong>Pogromca nieaktywny:</strong> Jeśli figura lub pionek,
              który zbił <strong>przynajmniej 3 figury</strong>, nie zostanie
              użyta przez <strong>4 tury z rzędu</strong> przez swojego
              właściciela, gra kończy się remisem.
            </p>
            <p>
              • <strong>Propozycja remisu:</strong> W trybie online gracze mogą
              zaproponować remis. Jeśli przeciwnik zaakceptuje, gra kończy się
              remisem.
            </p>
            <p>• Za remis każdy gracz otrzymuje <strong>+30 ELO</strong>.</p>
          </div>

          <h2>◈ System ELO</h2>
          <div class="highlight-box">
            <p>
              <strong>Punktacja ELO:</strong> Za każdy ruch i wynik gry
              otrzymujesz lub tracisz punkty ELO.
            </p>
            <p><strong>Za ruchy:</strong></p>
            <p>• !! Brilliant: +30 | ! Great: +20 | ✓ Good: +12 | 📖 Book: 0</p>
            <p>• ?! Inaccuracy: -8 | ? Mistake: -18 | ?? Blunder: -30</p>
            <p>• Szach: +20 | Mat (ruch końcowy): +75</p>
            <p><strong>Za wygraną:</strong></p>
            <p>• Online/Bot trudny: +100 (mat) / +60 (inna wygrana)</p>
            <p>• Bot średni: +50 (mat) / +30 (wygrana)</p>
            <p>• Bot łatwy: +33 (mat) / +20 (wygrana)</p>
            <p><strong>Za przegraną:</strong></p>
            <p>
              • Bot łatwy: -50 | Bot średni: -30 | Bot trudny: -15 | Online: -30
            </p>
          </div>

          <h2>◈ 1. Wprowadzenie do Gry</h2>
          <p>
            <strong>Strzałkowe Szachy</strong> to turowa gra strategiczna dla
            dwóch graczy. Jest inspirowana klasycznymi szachami, ale posiada
            całkowicie unikalne zasady ruchu i zbijania.
          </p>

          <h3>1.1. Cel gry</h3>
          <div class="highlight-box">
            <p>
              Twoim celem jest <strong>zamatowanie</strong> wrogiego Nexusa (◆).
              Mat następuje, gdy zablokujesz Nexusa przeciwnika i nie ma on
              żadnego bezpiecznego pola, na które mógłby uciec.
            </p>
          </div>

          <h3>1.2. Gracze i kolory</h3>
          <p>
            W grze biorą udział dwaj gracze: <strong>Białe</strong> i
            <strong>Czarne</strong>.
          </p>
          <p>
            Białe zawsze wykonują pierwszy ruch. Potem gracze ruszają się na
            przemian.
          </p>

          <h3>1.3. Czym ta gra różni się od szachów?</h3>
          <div class="warning-box">
            <p><strong>Kluczowe różnice:</strong></p>
            <p>
              • Figury poruszają się krokami (nie skokami przez całą planszę)
            </p>
            <p>• Można wykonać tylko 1 krok po skosie na turę</p>
            <p>
              • Nie ma natychmiastowego zbijania – używamy systemu blokowania
            </p>
            <p>• Zablokowana figura ma czas na ucieczkę</p>
            <p>• Atakujący nie może się ruszyć dopóki blokada trwa</p>
          </div>
        </div>

        <div class="rules-section">
          <h2>◈ 2. Szachownica</h2>

          <h3>2.1. Wymiary i oznaczenia</h3>
          <p>
            Gra toczy się na planszy <strong>8×8 pól</strong> (64 pola łącznie).
          </p>
          <p>
            <strong>Kolumny</strong> oznaczone są literami od
            <strong>a</strong> do <strong>h</strong> (od lewej do prawej).
          </p>
          <p>
            <strong>Rzędy</strong> oznaczone są cyframi od <strong>1</strong> do
            <strong>8</strong> (od dołu do góry).
          </p>
          <p>
            Każde pole ma unikalny adres, np. <strong>e4</strong> (kolumna e,
            rząd 4).
          </p>

          <h3>2.2. Kolory pól</h3>
          <p>
            Pola na szachownicy mają naprzemienne kolory (jasne i ciemne), co
            ułatwia orientację.
          </p>

          <h3>2.3. Strefy strategiczne</h3>
          <p>
            Szachownica podzielona jest na kolorowe strefy, które pomagają w
            orientacji i planowaniu strategii:
          </p>
          <div class="highlight-box">
            <p>
              <strong>Centrum</strong> (żółte) – pola d4, d5, e4, e5. Kontrola
              centrum daje przewagę taktyczną, bo figury w centrum mają
              największy zasięg.
            </p>
            <p>
              <strong>Skrzydło Nexusa Białych</strong> (niebieskie) – kolumny
              e-h, rzędy 1-2. Tu zaczyna Nexus białych.
            </p>
            <p>
              <strong>Skrzydło Phantoma Białych</strong> (zielone) – kolumny
              a-d, rzędy 1-2. Tu zaczyna Phantom białych.
            </p>
            <p>
              <strong>Skrzydło Nexusa Czarnych</strong> (czerwone) – kolumny
              e-h, rzędy 7-8. Tu zaczyna Nexus czarnych.
            </p>
            <p>
              <strong>Skrzydło Phantoma Czarnych</strong> (pomarańczowe) –
              kolumny a-d, rzędy 7-8. Tu zaczyna Phantom czarnych.
            </p>
          </div>
          <p>
            Strefy można włączać/wyłączać w panelu bocznym podczas gry (na
            komputerze).
          </p>
        </div>

        <div class="rules-section">
          <h2>◈ 3. Figury</h2>

          <h3>3.1. Skład armii</h3>
          <p>Każdy gracz rozpoczyna grę z <strong>16 figurami</strong>:</p>
          <div class="highlight-box">
            <p>• 1 × <strong>Nexus</strong> (◆) – najważniejsza figura</p>
            <p>• 1 × <strong>Phantom</strong> (✧) – najpotężniejsza figura</p>
            <p>
              • 2 × <strong>Sentinel</strong> (◎) – porusza się tylko prosto
            </p>
            <p>
              • 2 × <strong>Shade</strong> (◇) – porusza się tylko po skosie
            </p>
            <p>• 2 × <strong>Drifter</strong> (⬡) – wszechstronna figura</p>
            <p>• 8 × <strong>Shard</strong> (▲) – pionki, mogą awansować</p>
          </div>

          <h3>3.2. Ustawienie początkowe</h3>
          <p><strong>Białe</strong> (rzędy 1-2, na dole planszy):</p>
          <div class="highlight-box">
            <p>
              <strong>Rząd 1 (od a1 do h1):</strong> Sentinel, Drifter, Shade,
              Phantom, Nexus, Shade, Drifter, Sentinel
            </p>
            <p><strong>Rząd 2 (od a2 do h2):</strong> 8 × Shard (pionki)</p>
          </div>
          <p><strong>Czarne</strong> (rzędy 7-8, na górze planszy):</p>
          <div class="highlight-box">
            <p>
              <strong>Rząd 8 (od a8 do h8):</strong> Sentinel, Drifter, Shade,
              Phantom, Nexus, Shade, Drifter, Sentinel
            </p>
            <p><strong>Rząd 7 (od a7 do h7):</strong> 8 × Shard (pionki)</p>
          </div>

          <h3>3.3. Szczegółowy opis figur</h3>
          <div class="piece-showcase">
            <div class="piece-card">
              <div class="piece-card-symbol">◆</div>
              <div class="piece-card-info">
                <h4>Nexus (◆) – Król</h4>
                <p>
                  <strong>Liczba kroków:</strong> 1 (dokładnie jeden krok na
                  turę)<br />
                  <strong>Dozwolone kierunki:</strong> Wszystkie 8 kierunków
                  (góra, dół, lewo, prawo + 4 skosy)<br />
                  <strong>Specjalne zasady:</strong><br />
                  • To najważniejsza figura – jej utrata kończy grę!<br />
                  • NIE MOŻE wchodzić na pola zagrożone przez wroga<br />
                  • Gdy jest zablokowany (szach), ma tylko 1 turę na ucieczkę<br />
                  • Brak możliwości ucieczki = MAT (przegrana)
                </p>
              </div>
            </div>
            <div class="piece-card">
              <div class="piece-card-symbol">✧</div>
              <div class="piece-card-info">
                <h4>Phantom (✧) – Hetman</h4>
                <p>
                  <strong>Liczba kroków:</strong> do 5 (możesz użyć 1, 2, 3, 4
                  lub 5 kroków, ale musisz użyć wszystkich jeśli nie
                  atakujesz)<br />
                  <strong>Dozwolone kierunki:</strong> Wszystkie 8 kierunków<br />
                  <strong>Specjalne zasady:</strong><br />
                  • Najpotężniejsza figura ofensywna w grze<br />
                  • <strong>NATYCHMIASTOWE ZBICIE</strong> – Phantom nie daje
                  czasu na ucieczkę!<br />
                  • Pamiętaj o zasadzie 1 skosu na turę!
                </p>
              </div>
            </div>
            <div class="piece-card">
              <div class="piece-card-symbol">◎</div>
              <div class="piece-card-info">
                <h4>Sentinel (◎) – Wieża</h4>
                <p>
                  <strong>Liczba kroków:</strong> do 4<br />
                  <strong>Dozwolone kierunki:</strong> Tylko 4 kierunki proste
                  (góra, dół, lewo, prawo)<br />
                  <strong>Specjalne zasady:</strong><br />
                  • NIE MOŻE poruszać się po skosie w ogóle<br />
                  • <strong>TARCZA SENTINELA:</strong> Gdy dwie wieże tego
                  samego koloru stoją w jednej linii (pionowej lub poziomej) bez
                  figur między nimi, tworzą "Tarczę" – przeciwnik nie może
                  przechodzić przez pola między nimi!<br />
                  • Na środku Tarczy pojawia się Strażnik (⊕)
                </p>
              </div>
            </div>
            <div class="piece-card">
              <div class="piece-card-symbol">◇</div>
              <div class="piece-card-info">
                <h4>Shade (◇) – Goniec</h4>
                <p>
                  <strong>Liczba kroków:</strong> 1<br />
                  <strong>Dozwolone kierunki:</strong> Tylko 4 kierunki
                  skośne<br />
                  <strong>Specjalne zasady:</strong><br />
                  • NIE MOŻE poruszać się prosto w ogóle<br />
                  • Krótki zasięg, ale kontroluje przekątne<br />
                  • Każdy gracz ma 2 Shade'y – jeden na jasnych polach, jeden na
                  ciemnych
                </p>
              </div>
            </div>
            <div class="piece-card">
              <div class="piece-card-symbol">⬡</div>
              <div class="piece-card-info">
                <h4>Drifter (⬡) – Skoczek</h4>
                <p>
                  <strong>Liczba kroków:</strong> do 3<br />
                  <strong>Dozwolone kierunki:</strong> Wszystkie 8 kierunków<br />
                  <strong>Specjalne zasady:</strong><br />
                  • Wszechstronna figura średniego zasięgu<br />
                  • Może łączyć kroki proste i skośne (pamiętaj: max 1 skos na
                  turę!)<br />
                  • Dobry do szybkiego reagowania na zagrożenia
                </p>
              </div>
            </div>
            <div class="piece-card">
              <div class="piece-card-symbol">▲</div>
              <div class="piece-card-info">
                <h4>Shard (▲) – Pionek</h4>
                <p>
                  <strong>Liczba kroków:</strong> 1 (dokładnie jeden krok)<br />
                  <strong>Kierunki RUCHU:</strong> Tylko do przodu (prosto) –
                  białe idą w górę, czarne w dół<br />
                  <strong>Kierunki ATAKU:</strong> Tylko po skosie do przodu (2
                  kierunki)<br />
                  <strong>Specjalne zasady:</strong><br />
                  • Jedyna figura z RÓŻNYMI kierunkami ruchu i ataku!<br />
                  • Nie może cofać się ani atakować prosto<br />
                  • Może awansować na Phantoma (patrz: sekcja Promocja)
                </p>
              </div>
            </div>
          </div>
        </div>

        <div class="rules-section">
          <h2>◈ 4. Zasady Ruchu</h2>

          <h3>4.1. Kolejność ruchów</h3>
          <p>
            Gracze wykonują ruchy <strong>na przemian</strong>. Białe zawsze
            zaczynają.
          </p>
          <p>
            W każdej turze gracz musi wykonać dokładnie
            <strong>jeden ruch</strong> jedną figurą.
          </p>
          <p>Nie można pominąć ruchu (poza sytuacją pata).</p>

          <h3>4.2. Jak wykonać ruch</h3>
          <div class="highlight-box">
            <p>
              <strong>Krok 1:</strong> Kliknij figurę, którą chcesz ruszyć. Pole
              figury podświetli się na niebiesko.
            </p>
            <p>
              <strong>Krok 2:</strong> Kliknij kolejne pola, tworząc ścieżkę.
              Żółte strzałki pokazują zaplanowaną trasę.
            </p>
            <p>
              <strong>Krok 3:</strong> Ruch wykonuje się automatycznie gdy
              wykorzystasz wszystkie kroki LUB gdy zaatakujesz wroga.
            </p>
            <p>
              <strong>Anulowanie:</strong> Kliknij ponownie na wybraną figurę
              (gdy ścieżka jest pusta) aby ją odznaczyć.
            </p>
          </div>

          <h3>4.3. Obowiązkowe wykorzystanie WSZYSTKICH kroków</h3>
          <div class="warning-box">
            <p>
              <strong>BARDZO WAŻNE:</strong> Musisz wykorzystać WSZYSTKIE kroki
              figury! Nie możesz zakończyć ruchu wcześniej.
            </p>
            <p>
              <strong>Przykład:</strong> Phantom ma 5 kroków. MUSISZ wykonać
              wszystkie 5 kroków.
            </p>
            <p>
              <strong>Jedyny wyjątek:</strong> Gdy w trakcie ruchu zaatakujesz
              wrogą figurę – wtedy ruch kończy się automatycznie w momencie
              ataku.
            </p>
          </div>
          <p>
            <strong>Przykład z atakiem:</strong> Phantom (5 kroków) idzie: krok
            1 → krok 2 → krok 3 (trafia na wroga) → KONIEC RUCHU. Kroki 4 i 5
            nie są wykonywane.
          </p>

          <h3>4.4. Zasada JEDNEGO SKOSU na turę</h3>
          <div class="warning-box">
            <p>
              <strong>KLUCZOWA ZASADA:</strong> W jednej turze możesz wykonać
              <strong>maksymalnie JEDEN krok po skosie</strong> (ukośnie).
            </p>
            <p>
              Po wykonaniu kroku po skosie, wszystkie pozostałe kroki w tej
              turze muszą być <strong>proste</strong> (góra/dół/lewo/prawo).
            </p>
          </div>
          <p><strong>Przykłady dla Phantoma (5 kroków):</strong></p>
          <div class="highlight-box">
            <p>✅ DOZWOLONE: prosto → prosto → skos → prosto → prosto</p>
            <p>✅ DOZWOLONE: skos → prosto → prosto → prosto → prosto</p>
            <p>✅ DOZWOLONE: prosto → prosto → prosto → prosto → skos</p>
            <p>❌ ZABRONIONE: skos → skos → prosto → prosto → prosto</p>
            <p>❌ ZABRONIONE: prosto → skos → prosto → skos → prosto</p>
          </div>

          <h3>4.5. Blokowanie ścieżki</h3>
          <p>
            Figura <strong>nie może przechodzić przez pola zajęte</strong> przez
            inne figury (zarówno własne jak i wrogie).
          </p>
          <p>Musisz omijać przeszkody, planując ścieżkę dookoła nich.</p>
          <p>
            <strong>Wyjątek:</strong> Możesz zakończyć ruch na polu wroga (atak)
            – ale to musi być twój ostatni krok!
          </p>

          <h3>4.6. Kiedy ruch się kończy</h3>
          <p>Ruch kończy się automatycznie w jednej z dwóch sytuacji:</p>
          <div class="highlight-box">
            <p>
              <strong>1.</strong> Wykorzystałeś wszystkie dostępne kroki figury
              (obowiązkowe!)
            </p>
            <p>
              <strong>2.</strong> Wszedłeś na pole z wrogą figurą (atak) – to
              jedyny sposób na skrócenie ruchu
            </p>
          </div>
        </div>

        <div class="rules-section">
          <h2>◈ 5. System Ataku i Zbijania</h2>
          <p>
            W Strzałkowych Szachach
            <strong>nie ma natychmiastowego zbijania</strong> jak w klasycznych
            szachach!
          </p>
          <p>
            Zamiast tego używamy systemu <strong>blokowania</strong>, który daje
            ofierze szansę na ucieczkę.
          </p>

          <h3>5.1. Jak zaatakować wrogą figurę</h3>
          <p>
            Aby zaatakować, musisz
            <strong>wejść na pole zajmowane przez wrogą figurę</strong> podczas
            swojego ruchu.
          </p>
          <div class="warning-box">
            <p>
              <strong>KRYTYCZNA ZASADA:</strong> Atak MUSI być
              <strong>ostatnim krokiem</strong> twojego ruchu!
            </p>
            <p>
              Nie możesz "przejść przez" wrogą figurę ani zaatakować "po drodze"
              i kontynuować dalej.
            </p>
            <p>
              Gdy wejdziesz na pole wroga, twój ruch natychmiast się kończy.
            </p>
          </div>
          <p>
            <strong>Przykład:</strong> Phantom (5 kroków) może zaatakować w
            kroku 1, 2, 3, 4 lub 5 – ale w momencie ataku ruch się kończy,
            niezależnie ile kroków zostało.
          </p>

          <h3>5.2. Co się dzieje po ataku – krok po kroku</h3>
          <div class="highlight-box">
            <p>
              <strong>Krok 1:</strong> Twoja figura (atakujący) ZOSTAJE na swoim
              ostatnim polu PRZED polem ofiary – NIE wchodzi na pole ofiary!
            </p>
            <p>
              <strong>Krok 2:</strong> Na polu ofiary pojawia się pulsująca
              strzałka wskazująca kierunek ataku.
            </p>
            <p>
              <strong>Krok 3:</strong> Na polu ofiary pojawia się licznik tur
              pokazujący ile czasu zostało na ucieczkę.
            </p>
            <p>
              <strong>Krok 4:</strong> Ofiara jest teraz "zablokowana" – musi
              próbować uciec w swoich następnych turach.
            </p>
            <p><strong>Krok 5:</strong> Tura przechodzi na przeciwnika.</p>
          </div>

          <h3>5.3. Zasady dla ATAKUJĄCEGO (twojej figury)</h3>
          <div class="warning-box">
            <p>Figura która atakuje (blokuje inną figurę):</p>
            <p>
              • <strong>NIE MOŻE SIĘ RUSZYĆ</strong> dopóki blokada nie zostanie
              rozwiązana!
            </p>
            <p>• Jest wizualnie przyciemniona na planszy</p>
            <p>• Nie można jej wybrać do ruchu</p>
            <p>
              • Musi czekać na swoim polu aż ofiara ucieknie LUB zostanie zbita
            </p>
            <p>
              • Jeśli w tym czasie INNA twoja figura zablokuje atakującego – on
              też musi uciekać!
            </p>
          </div>

          <h3>5.4. Zasady dla ZABLOKOWANEJ figury (ofiary)</h3>
          <div class="warning-box">
            <p>Figura która jest atakowana (zablokowana):</p>
            <p>
              • <strong>MOŻE</strong> uciekać na dowolne puste pole w zasięgu
              swoich normalnych kroków
            </p>
            <p>
              • <strong>MUSI</strong> przestrzegać wszystkich normalnych zasad
              ruchu (w tym zasady 1 skosu)
            </p>
            <p>
              • <strong>NIE MOŻE</strong> atakować innych figur podczas ucieczki
              – tylko puste pola!
            </p>
            <p>
              • <strong>NIE MOŻE</strong> zaatakować atakującego – nie da się
              "odbić"!
            </p>
            <p>• Ma ograniczony czas na ucieczkę (patrz: licznik tur)</p>
          </div>

          <h3>5.5. Czas na ucieczkę – licznik tur</h3>
          <p>
            <strong>Zwykłe figury</strong> (Phantom, Sentinel, Shade, Drifter,
            Shard):
          </p>
          <div class="highlight-box">
            <p>Mają <strong>2 tury</strong> na ucieczkę.</p>
            <p>
              Licznik: <strong>2</strong> (po ataku) → <strong>1</strong> (po
              turze wroga) → <strong>ZBICIE</strong> (jeśli nie uciekł)
            </p>
          </div>
          <p><strong>Nexus</strong> (◆):</p>
          <div class="warning-box">
            <p>Ma tylko <strong>1 turę</strong> na ucieczkę!</p>
            <p>
              Licznik: <strong>1</strong> (po ataku) →
              <strong>ZBICIE/MAT</strong> (jeśli nie uciekł)
            </p>
            <p>
              Jeśli Nexus nie może uciec (wszystkie pola zablokowane/zagrożone)
              = natychmiastowy MAT!
            </p>
          </div>

          <h3>5.6. Jak kończy się blokada – dwa scenariusze</h3>
          <div class="highlight-box">
            <p><strong>SCENARIUSZ A – Ucieczka (ofiara ucieka):</strong></p>
            <p>1. Ofiara wykonuje legalny ruch na puste pole</p>
            <p>2. Blokada zostaje anulowana</p>
            <p>
              3. Atakujący pozostaje na swoim polu (nie zajmuje pola ofiary!)
            </p>
            <p>
              4. Atakujący może normalnie się ruszyć w swojej następnej turze
            </p>
          </div>
          <div class="warning-box">
            <p><strong>SCENARIUSZ B – Zbicie (ofiara nie uciekła):</strong></p>
            <p>1. Licznik tur spada do 0</p>
            <p>2. Ofiara zostaje ZBITA i usunięta z planszy na stałe</p>
            <p>3. Atakujący automatycznie zajmuje pole, gdzie stała ofiara</p>
            <p>4. Zbita figura trafia do panelu "Zbite figury"</p>
          </div>

          <h3>5.7. Wiele blokad jednocześnie</h3>
          <p>
            Na planszy może istnieć
            <strong>wiele aktywnych blokad</strong> jednocześnie!
          </p>
          <p>Każda blokada jest niezależna i ma własny licznik tur.</p>
          <p>
            Gracz może mieć kilka figur atakujących (wszystkie będą zablokowane)
            i kilka figur uciekających.
          </p>

          <h3>5.8. Zbite figury</h3>
          <p>
            Zbite figury są usuwane z planszy <strong>na stałe</strong> – nie
            wracają do gry.
          </p>
          <p>
            Na komputerze widać je w panelu bocznym ("Zbite przez Białe" /
            "Zbite przez Czarne").
          </p>
        </div>

        <div class="rules-section">
          <h2>◈ 6. Nexus – Zasady Specjalne</h2>
          <p>
            Nexus (◆) to <strong>najważniejsza figura</strong> w grze. Jego
            utrata oznacza natychmiastową przegraną.
          </p>

          <h3>6.1. Atakowanie Nexusa</h3>
          <p>
            Atak na Nexusa działa <strong>tak samo</strong> jak atak na każdą
            inną figurę:
          </p>
          <div class="highlight-box">
            <p>
              • Musisz wejść na pole Nexusa jako
              <strong>ostatni krok</strong> swojego ruchu
            </p>
            <p>
              • Nie możesz "złapać" Nexusa po drodze – musi to być twój końcowy
              cel
            </p>
            <p>• Atakujący zostaje na swoim polu, Nexus jest zablokowany</p>
          </div>
          <div class="warning-box">
            <p>
              <strong>RÓŻNICA:</strong> Nexus ma tylko
              <strong>1 turę</strong> na ucieczkę (nie 2 jak inne figury)!
            </p>
          </div>

          <h3>6.2. Szach</h3>
          <p>
            Gdy wróg zablokuje twojego Nexusa, jesteś w stanie
            <strong>SZACH</strong>.
          </p>
          <p>Nexus pulsuje na czerwono, sygnalizując zagrożenie.</p>
          <p>
            Nexus <strong>MUSI</strong> uciec w swojej następnej turze – nie
            możesz ruszyć żadną inną figurą!
          </p>

          <h3>6.3. Ograniczenia ruchu Nexusa</h3>
          <div class="warning-box">
            <p>
              Nexus <strong>NIE MOŻE</strong> wejść na pole, które jest
              <strong>zagrożone</strong> przez jakąkolwiek wrogą figurę.
            </p>
            <p>
              Pole jest "zagrożone" jeśli wróg mógłby na nie dotrzeć jako
              ostatni krok swojego ruchu.
            </p>
            <p>
              To oznacza, że Nexus musi zawsze uciekać na "bezpieczne" pola.
            </p>
          </div>

          <h3>6.4. Mat – koniec gry</h3>
          <p><strong>MAT</strong> następuje gdy:</p>
          <div class="warning-box">
            <p>• Nexus jest zablokowany (w szachu) ORAZ</p>
            <p>• Nie ma żadnego bezpiecznego pola do ucieczki:</p>
            <p>– Wszystkie sąsiednie pola są zajęte przez własne figury, LUB</p>
            <p>– Wszystkie sąsiednie pola są zagrożone przez wroga, LUB</p>
            <p>– Wszystkie sąsiednie pola są poza planszą</p>
          </div>
          <p>Mat kończy grę natychmiast – wygrywa gracz, który zamatował.</p>
        </div>

        <div class="rules-section">
          <h2>◈ 7. Promocja Sharda</h2>

          <h3>7.1. Warunek promocji</h3>
          <p>
            Gdy Shard (▲) dotrze do <strong>ostatniego rzędu</strong> planszy,
            automatycznie awansuje na <strong>Phantoma</strong> (✧).
          </p>
          <div class="highlight-box">
            <p>
              <strong>Dla Białych:</strong> Ostatni rząd to rząd 8 (górna
              krawędź planszy)
            </p>
            <p>
              <strong>Dla Czarnych:</strong> Ostatni rząd to rząd 1 (dolna
              krawędź planszy)
            </p>
          </div>

          <h3>7.2. Jak działa promocja</h3>
          <p>
            Promocja następuje <strong>natychmiast</strong> po dotarciu Sharda
            na ostatni rząd.
          </p>
          <p>
            Shard zamienia się w Phantoma (z 5 krokami i wszystkimi kierunkami).
          </p>
          <p>Nowy Phantom może być użyty <strong>od następnej tury</strong>.</p>

          <h3>7.3. Strategia</h3>
          <p>
            Promocja to potężne narzędzie! Shard wart 1 krok zamienia się w
            Phantoma wart 5 kroków.
          </p>
          <p>
            Chroń swoje Shardy i prowadź je do promocji, jednocześnie blokując
            Shardy przeciwnika.
          </p>
        </div>

        <div class="rules-section">
          <h2>◈ 8. Koniec Gry</h2>

          <h3>8.1. Zwycięstwo przez Mat</h3>
          <p>Gracz wygrywa gdy <strong>zamatuje</strong> wrogiego Nexusa.</p>
          <p>
            Mat = Nexus jest zablokowany + nie ma bezpiecznego pola do ucieczki.
          </p>

          <h3>8.2. Remis przez Pat</h3>
          <p><strong>PAT</strong> następuje gdy:</p>
          <div class="highlight-box">
            <p>
              • Gracz nie ma żadnego legalnego ruchu (żadna figura nie może się
              ruszyć), ALE
            </p>
            <p>• Jego Nexus NIE jest zablokowany (nie jest w szachu)</p>
          </div>
          <p>Pat kończy grę <strong>remisem</strong> – nikt nie wygrywa.</p>

          <h3>8.3. Przegrana na czas</h3>
          <p>
            W grze z limitem czasu, gracz którego zegar spadnie do
            <strong>0:00</strong> natychmiast przegrywa.
          </p>
          <p>Nie ma znaczenia pozycja na planszy – brak czasu = przegrana.</p>
        </div>

        <div class="rules-section">
          <h2>◈ 9. Ustawienia Gry</h2>

          <h3>9.1. Tryby gry</h3>
          <p><strong>Gracz vs Gracz (PvP):</strong></p>
          <p>
            Dwóch graczy gra na jednym urządzeniu, na przemian. Na telefonie
            plansza obraca się automatycznie przy zmianie tury.
          </p>
          <p><strong>Gracz vs Bot:</strong></p>
          <p>
            Grasz jako Białe przeciwko komputerowi (Czarne). Dostępne 3 poziomy
            trudności:
          </p>
          <div class="highlight-box">
            <p>
              • <strong>Łatwy</strong> – Bot wykonuje losowe ruchy. Dobry do
              nauki.
            </p>
            <p>
              • <strong>Średni</strong> – Bot preferuje ataki i ucieczki. Wymaga
              uwagi.
            </p>
            <p>
              • <strong>Trudny</strong> – Bot analizuje wartość figur i pozycję.
              Prawdziwe wyzwanie!
            </p>
          </div>

          <h3>9.2. Kontrola czasu</h3>
          <p><strong>Bez limitu (∞):</strong></p>
          <p>
            Gracze mają nieograniczony czas na ruchy. Idealne do nauki i
            spokojnej gry.
          </p>
          <p><strong>Z limitem (1/3/5/10/15 minut):</strong></p>
          <p>
            Każdy gracz ma określony czas na całą grę. Zegar odlicza tylko
            podczas twojej tury.
          </p>

          <h3>9.3. Bonus po ruchu (inkrement)</h3>
          <p>
            Po wykonaniu ruchu, do zegara gracza dodawana jest określona liczba
            sekund.
          </p>
          <p>Dostępne opcje: +0s, +1s, +2s, +3s, +5s, +10s</p>
          <p>
            <strong>Przykład:</strong> Gra 5+3 oznacza: 5 minut na start + 3
            sekundy po każdym ruchu.
          </p>
        </div>

        <div class="rules-section">
          <h2>◈ 10. Analiza Partii</h2>
          <p>
            Po zakończeniu gry (mat/pat/czas) możesz analizować przebieg całej
            partii.
          </p>

          <h3>10.1. Przeglądanie historii</h3>
          <p>
            Na komputerze: Kliknij dowolny wpis w "Historii Ruchów" aby zobaczyć
            planszę w tym momencie.
          </p>
          <p>Użyj przycisków nawigacji:</p>
          <div class="highlight-box">
            <p>⏮ – Idź do początku gry</p>
            <p>◀ – Poprzedni ruch</p>
            <p>▶ – Następny ruch</p>
            <p>⏭ – Idź do końca gry</p>
          </div>

          <h3>10.2. Tryb "Co jeśli?"</h3>
          <p>Podczas analizy możesz testować alternatywne ruchy:</p>
          <div class="highlight-box">
            <p>• Kliknij figurę i wykonaj ruch jak w normalnej grze</p>
            <p>• Możesz wykonać maksymalnie <strong>3 rundy</strong> testowe</p>
            <p>• Kliknij "↺ Resetuj" aby wrócić do oryginalnej pozycji</p>
            <p>• Po 4 rundzie następuje automatyczny reset</p>
          </div>
        </div>

        <div class="rules-section">
          <h2>◈ 11. Interfejs Gry (komputer)</h2>

          <h3>11.1. Oznaczenia na planszy</h3>
          <div class="highlight-box">
            <p>
              <strong>Niebieskie pole:</strong> Wybrana figura (którą chcesz
              ruszyć)
            </p>
            <p>
              <strong>Zielone pola:</strong> Dostępne pola do następnego kroku
            </p>
            <p>
              <strong>Żółte strzałki:</strong> Twoja zaplanowana ścieżka ruchu
            </p>
            <p>
              <strong>Pulsujące strzałki:</strong> Aktywne blokady (ataki w
              toku)
            </p>
            <p><strong>Licznik na polu:</strong> Ile tur zostało do zbicia</p>
            <p>
              <strong>Czerwone pulsowanie:</strong> Nexus w szachu (zagrożony!)
            </p>
            <p>
              <strong>Przyciemniona figura:</strong> Figura która atakuje (nie
              może się ruszyć)
            </p>
          </div>

          <h3>11.2. Panele boczne</h3>
          <p><strong>Lewy panel:</strong></p>
          <p>• Wskaźnik tury (czyja kolej)</p>
          <p>• Informacje o wybranej figurze i ile kroków zostało</p>
          <p>• Zbite figury przez każdego gracza</p>
          <p>• Lista aktywnych blokad</p>
          <p><strong>Prawy panel:</strong></p>
          <p>• Historia ruchów (klikalna podczas analizy)</p>
          <p>• Legenda stref szachownicy</p>
          <p>• Kontrolki analizy (po zakończeniu gry)</p>

          <h3>11.3. Zegary</h3>
          <p>
            Zegar czarnych wyświetlany jest <strong>nad</strong> szachownicą.
          </p>
          <p>
            Zegar białych wyświetlany jest <strong>pod</strong> szachownicą.
          </p>
          <p>
            Aktywny zegar ma złotą ramkę. Gdy zostanie mniej niż 30 sekund,
            zegar pulsuje na różowo.
          </p>

          <h3>11.4. Interfejs mobilny</h3>
          <p>Na telefonie/tablecie interfejs jest uproszczony:</p>
          <p>• Szachownica zajmuje cały ekran</p>
          <p>• Zegary wyświetlane na górze i dole</p>
          <p>• Między zegarami: info o turze i wybranej figurze</p>
          <p>• W trybie PvP plansza obraca się przy zmianie tury</p>
        </div>
      </div>
    </div>
    <div class="modal-overlay" id="game-over-modal">
      <div class="modal">
        <h2 id="modal-title">Koniec Gry!</h2>
        <p id="modal-message">Białe wygrywają!</p>
        <button class="modal-btn" id="new-game-btn">Nowa Gra</button>
      </div>
    </div>
    <script>
      const PIECES = {
        KING: { symbol: "◆", name: "Nexus", moves: 1, type: "king" },
        QUEEN: { symbol: "✧", name: "Phantom", moves: 5, type: "queen" },
        ROOK: {
          symbol: "◎",
          name: "Sentinel",
          moves: 4,
          type: "rook",
          straightOnly: true,
        },
        BISHOP: {
          symbol: "◇",
          name: "Shade",
          moves: 1,
          type: "bishop",
          diagonalOnly: true,
        },
        KNIGHT: { symbol: "⬡", name: "Drifter", moves: 3, type: "knight" },
        PAWN: { symbol: "▲", name: "Shard", moves: 1, type: "pawn" },
      };
      const DIRECTIONS = {
        n: { dx: 0, dy: -1, diagonal: false, arrow: "↑" },
        s: { dx: 0, dy: 1, diagonal: false, arrow: "↓" },
        e: { dx: 1, dy: 0, diagonal: false, arrow: "→" },
        w: { dx: -1, dy: 0, diagonal: false, arrow: "←" },
        ne: { dx: 1, dy: -1, diagonal: true, arrow: "↗" },
        nw: { dx: -1, dy: -1, diagonal: true, arrow: "↖" },
        se: { dx: 1, dy: 1, diagonal: true, arrow: "↘" },
        sw: { dx: -1, dy: 1, diagonal: true, arrow: "↙" },
      };
      let G = {
        board: [],
        currentPlayer: "white",
        selectedPiece: null,
        plannedPath: [],
        usedDiagonal: false,
        gameMode: null,
        difficulty: "medium",
        pendingCaptures: [],
        capturedByWhite: [],
        capturedByBlack: [],
        moveHistory: [],
        gameOver: false,
        inCheck: null,
        showZones: true,
        showEval: true,
        timeLimit: 0,
        increment: 0,
        whiteTime: 0,
        blackTime: 0,
        timerInterval: null,
        gameStates: [],
        currentStateIndex: -1,
        analyzing: false,
        whatIfMode: false,
        whatIfBaseIndex: -1,
        whatIfRounds: 0,
        whatIfBoard: null,
        whatIfPending: null,
        whatIfCapturedW: null,
        whatIfCapturedB: null,
        whatIfPlayer: null,
        isAnimating: false,
        sentinelShields: [],
        lastMove: null,
        evalBefore: 0,
        movesWithoutAttack: 0,
        doubleAttackPieces: [],
      };

      // ===== SYSTEM DŹWIĘKÓW (jak chess.com) =====
      var audioContext = null;
      var soundEnabled = true;

      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      function playSound(type) {
        if (!soundEnabled) return;
        try {
          initAudio();
          var osc = audioContext.createOscillator();
          var gain = audioContext.createGain();
          osc.connect(gain);
          gain.connect(audioContext.destination);

          var now = audioContext.currentTime;

          switch (type) {
            case "move":
              // Krótki "klik" - ruch figury
              osc.type = "sine";
              osc.frequency.setValueAtTime(600, now);
              osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
              osc.start(now);
              osc.stop(now + 0.1);
              break;

            case "capture":
              // Głębszy dźwięk zbicia
              osc.type = "triangle";
              osc.frequency.setValueAtTime(300, now);
              osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
              gain.gain.setValueAtTime(0.4, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;

            case "check":
              // Ostrzegawczy dźwięk szacha
              osc.type = "square";
              osc.frequency.setValueAtTime(800, now);
              osc.frequency.setValueAtTime(600, now + 0.1);
              osc.frequency.setValueAtTime(800, now + 0.2);
              gain.gain.setValueAtTime(0.25, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
              osc.start(now);
              osc.stop(now + 0.3);
              break;

            case "castle":
              // Podwójny klik (roszada / tarcza)
              osc.type = "sine";
              osc.frequency.setValueAtTime(500, now);
              osc.frequency.setValueAtTime(700, now + 0.08);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.setValueAtTime(0.3, now + 0.08);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.16);
              osc.start(now);
              osc.stop(now + 0.16);
              break;

            case "promote":
              // Triumfalny dźwięk promocji
              osc.type = "sine";
              osc.frequency.setValueAtTime(400, now);
              osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
              osc.frequency.exponentialRampToValueAtTime(1000, now + 0.25);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
              osc.start(now);
              osc.stop(now + 0.35);
              break;

            case "illegal":
              // Błąd - nielegalny ruch
              osc.type = "sawtooth";
              osc.frequency.setValueAtTime(200, now);
              osc.frequency.setValueAtTime(150, now + 0.1);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              osc.start(now);
              osc.stop(now + 0.15);
              break;

            case "select":
              // Zaznaczenie figury
              osc.type = "sine";
              osc.frequency.setValueAtTime(500, now);
              osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
              gain.gain.setValueAtTime(0.15, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
              osc.start(now);
              osc.stop(now + 0.08);
              break;

            case "gameEnd":
              // Koniec gry
              osc.type = "sine";
              osc.frequency.setValueAtTime(400, now);
              osc.frequency.setValueAtTime(500, now + 0.15);
              osc.frequency.setValueAtTime(300, now + 0.3);
              osc.frequency.setValueAtTime(400, now + 0.45);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
              osc.start(now);
              osc.stop(now + 0.6);
              break;

            case "notify":
              // Powiadomienie (propozycja remisu itp)
              osc.type = "sine";
              osc.frequency.setValueAtTime(700, now);
              osc.frequency.setValueAtTime(900, now + 0.1);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;

            case "lowTime":
              // Ostrzeżenie o niskim czasie
              osc.type = "square";
              osc.frequency.setValueAtTime(1000, now);
              gain.gain.setValueAtTime(0.15, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
              osc.start(now);
              osc.stop(now + 0.05);
              break;
          }
        } catch (e) {
          console.log("Audio error:", e);
        }
      }

      // Tarcza Sentinela - specjalna figura tworzona przez dwie wieże w linii
      const SENTINEL_GUARDIAN = {
        symbol: "⊕",
        name: "Strażnik",
        moves: 4,
        type: "guardian",
        straightOnly: true,
      };

      // Sprawdź czy dwie wieże tworzą Tarczę Sentinela
      function checkSentinelShields() {
        G.sentinelShields = [];

        // Znajdź wszystkie wieże
        var rooks = [];
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var piece = G.board[y][x];
            if (piece && piece.type === "rook") {
              rooks.push({ x: x, y: y, color: piece.color });
            }
          }
        }

        // Sprawdź pary wież tego samego koloru
        for (var i = 0; i < rooks.length; i++) {
          for (var j = i + 1; j < rooks.length; j++) {
            var r1 = rooks[i],
              r2 = rooks[j];
            if (r1.color !== r2.color) continue;

            // Czy są w tej samej linii (pionowej lub poziomej)?
            if (r1.x === r2.x || r1.y === r2.y) {
              // Sprawdź czy między nimi nie ma innych figur
              var blocked = false;
              var tiles = [];

              if (r1.x === r2.x) {
                // Pionowa linia
                var minY = Math.min(r1.y, r2.y);
                var maxY = Math.max(r1.y, r2.y);
                for (var y = minY + 1; y < maxY; y++) {
                  tiles.push({ x: r1.x, y: y });
                  if (G.board[y][r1.x]) blocked = true;
                }
              } else {
                // Pozioma linia
                var minX = Math.min(r1.x, r2.x);
                var maxX = Math.max(r1.x, r2.x);
                for (var x = minX + 1; x < maxX; x++) {
                  tiles.push({ x: x, y: r1.y });
                  if (G.board[r1.y][x]) blocked = true;
                }
              }

              if (!blocked && tiles.length > 0) {
                // Środek tarczy - tam pojawi się Strażnik
                var midIndex = Math.floor(tiles.length / 2);
                var guardianPos = tiles[midIndex];

                G.sentinelShields.push({
                  color: r1.color,
                  rook1: { x: r1.x, y: r1.y },
                  rook2: { x: r2.x, y: r2.y },
                  tiles: tiles,
                  guardianX: guardianPos.x,
                  guardianY: guardianPos.y,
                });
              }
            }
          }
        }
      }

      // Sprawdź czy pole jest zablokowane przez Tarczę Sentinela (dla przeciwnika)
      function isBlockedByShield(x, y, movingColor) {
        for (var i = 0; i < G.sentinelShields.length; i++) {
          var shield = G.sentinelShields[i];
          // Tarcza blokuje tylko przeciwnika
          if (shield.color === movingColor) continue;

          for (var j = 0; j < shield.tiles.length; j++) {
            if (shield.tiles[j].x === x && shield.tiles[j].y === y) {
              return true;
            }
          }
        }
        return false;
      }

      // Profil i Online
      let playerProfile = localStorage.getItem("arrowChessProfile") || null;
      let playerElo = parseInt(localStorage.getItem("arrowChessElo")) || 0;
      let lobbyId = null;
      let isHost = false;
      let onlinePlayers = [];
      let peer = null;
      let peerConnection = null;
      let myColor = null; // 'white' lub 'black'
      let lobbyTimeLimit = 5; // Domyślny czas w lobby
      let lobbyIncrement = 2; // Domyślny increment w lobby

      // Inicjalizacja profilu
      function initProfile() {
        var display = document.getElementById("profile-display");
        if (playerProfile) {
          display.textContent = "👤 " + playerProfile;
          display.classList.remove("no-profile");
        } else {
          display.textContent = "⚙ Ustaw profil";
          display.classList.add("no-profile");
        }
        updateEloDisplay();
      }

      function updateEloDisplay() {
        var eloDisplay = document.getElementById("elo-display");
        if (eloDisplay) {
          eloDisplay.textContent = "⭐ " + playerElo + " ELO";
        }
      }

      function addElo(amount, reason) {
        playerElo += amount;
        if (playerElo < 0) playerElo = 0;
        localStorage.setItem("arrowChessElo", playerElo);
        updateEloDisplay();

        // Pokaż zmianę ELO
        showEloChange(amount, reason);
      }

      function showEloChange(amount, reason) {
        var toast = document.getElementById("elo-toast");
        if (!toast) return;

        var sign = amount >= 0 ? "+" : "";
        toast.textContent =
          sign + amount + " ELO" + (reason ? " (" + reason + ")" : "");
        toast.className =
          "elo-toast active " + (amount >= 0 ? "positive" : "negative");

        setTimeout(function () {
          toast.classList.remove("active");
        }, 2000);
      }

      // Oblicz ELO za ruch na podstawie ikony
      function calculateEloForMove(moveIcon, causedCheck, causedMate) {
        if (causedMate) return 75; // Mat = duży bonus
        if (causedCheck) return 20; // Szach

        var eloChanges = {
          brilliant: 30,
          great: 20,
          good: 12,
          book: 0,
          inaccuracy: -8,
          mistake: -18,
          blunder: -30,
        };

        return eloChanges[moveIcon] || 0;
      }

      function showProfileScreen() {
        showScreen("profile");
        document.getElementById("profile-name-input").value =
          playerProfile || "";
      }

      function saveProfile() {
        var name = document.getElementById("profile-name-input").value.trim();
        if (name.length < 2) {
          alert("Nazwa musi mieć minimum 2 znaki!");
          return;
        }
        playerProfile = name;
        localStorage.setItem("arrowChessProfile", name);
        initProfile();

        // Jeśli czekało lobby do dołączenia
        if (window.pendingLobby) {
          var lobbyToJoin = window.pendingLobby;
          window.pendingLobby = null;
          joinLobby(lobbyToJoin);
        } else {
          showScreen("menu");
        }
      }

      function showScreen(screenId) {
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(screenId + "-screen").classList.add("active");
        document
          .querySelectorAll(".nav-btn")
          .forEach((b) => b.classList.remove("active"));
        var navBtn = document.querySelector('[data-screen="' + screenId + '"]');
        if (navBtn) navBtn.classList.add("active");
      }

      // Online / Lobby z PeerJS
      function createLobby() {
        if (!playerProfile) {
          showProfileScreen();
          return;
        }

        // Pokaż lobby od razu z info o łączeniu
        isHost = true;
        myColor = "white";
        onlinePlayers = [{ name: playerProfile, isHost: true }];
        showScreen("lobby");
        document.getElementById("waiting-text").textContent =
          "Łączenie z serwerem...";

        // Generuj proste ID (tylko małe litery i cyfry)
        var randomPart = "";
        var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
        for (var i = 0; i < 8; i++) {
          randomPart += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        lobbyId = "chess" + randomPart;

        // Pokaż link od razu
        updateLobbyUI();

        // Twórz peer jako host
        peer = new Peer(lobbyId, {
          debug: 2,
        });

        peer.on("open", function (id) {
          console.log("Host peer otwarty:", id);
          lobbyId = id; // Użyj rzeczywistego ID
          updateLobbyUI();
        });

        peer.on("connection", function (conn) {
          console.log("Ktoś się łączy!");
          peerConnection = conn;

          conn.on("open", function () {
            console.log("Połączenie otwarte");
          });

          conn.on("data", function (data) {
            handlePeerData(data);
          });

          conn.on("close", function () {
            console.log("Gość rozłączony");
            onlinePlayers = [{ name: playerProfile, isHost: true }];
            if (!G.gameOver) updateLobbyUI();
          });

          conn.on("error", function (err) {
            console.error("Connection error:", err);
          });
        });

        peer.on("error", function (err) {
          console.error("Peer error:", err);
          if (err.type === "unavailable-id") {
            // ID zajęte - spróbuj z nowym
            peer.destroy();
            setTimeout(createLobby, 500);
          } else {
            document.getElementById("waiting-text").textContent =
              "Błąd: " + err.type;
          }
        });

        peer.on("disconnected", function () {
          console.log("Peer disconnected, reconnecting...");
          peer.reconnect();
        });
      }

      function updateLobbyUI() {
        var linkEl = document.getElementById("lobby-link");
        var fullUrl =
          window.location.origin +
          window.location.pathname +
          "?lobby=" +
          lobbyId;
        linkEl.textContent = fullUrl;
        linkEl.href = fullUrl;

        // Pokaż czy jesteś hostem czy gościem
        var lobbyTitle = document.querySelector(".lobby-box h2");
        if (isHost) {
          lobbyTitle.textContent = "🌐 Twoje Lobby (Host - Białe)";
        } else {
          lobbyTitle.textContent = "🌐 Dołączono (Gość - Czarne)";
        }

        var player1 = document.getElementById("player1-slot");
        var player1Name = document.getElementById("player1-name");
        player1Name.textContent = onlinePlayers[0]
          ? onlinePlayers[0].name + " ⚪"
          : "Oczekiwanie...";
        player1.classList.toggle("empty", !onlinePlayers[0]);

        var player2 = document.getElementById("player2-slot");
        var player2Name = player2.querySelector(".player-name");
        if (onlinePlayers[1]) {
          player2Name.textContent = onlinePlayers[1].name + " ⚫";
          player2.classList.remove("empty");
          player2.querySelector(".player-status").textContent = "✓ Połączony";
        } else {
          player2Name.textContent = "Oczekiwanie...";
          player2.classList.add("empty");
          player2.querySelector(".player-status").textContent = "⏳";
        }

        var playersHeader = document.querySelector(".lobby-players h3");
        playersHeader.textContent = "Gracze (" + onlinePlayers.length + "/2)";

        var startBtn = document.getElementById("start-online-btn");
        var waitingText = document.getElementById("waiting-text");
        var lobbySettings = document.getElementById("lobby-settings");
        var lobbySettingsDisplay = document.getElementById(
          "lobby-settings-display"
        );

        // Host widzi przyciski wyboru, gość widzi tylko info
        if (isHost) {
          lobbySettings.style.display = "block";
          lobbySettingsDisplay.style.display = "none";
        } else {
          lobbySettings.style.display = "none";
          lobbySettingsDisplay.style.display = "block";
        }

        if (!isHost) {
          startBtn.style.display = "none";
          if (onlinePlayers.length >= 2) {
            waitingText.textContent = "Czekam aż Host rozpocznie grę...";
            waitingText.style.color = "var(--accent-cyan)";
          } else {
            waitingText.textContent = "Łączenie z Hostem...";
            waitingText.style.color = "var(--accent-gold)";
          }
        } else {
          startBtn.style.display = "inline-block";
          if (onlinePlayers.length >= 2) {
            startBtn.disabled = false;
            waitingText.textContent = "Gotowi do gry!";
            waitingText.style.color = "var(--accent-cyan)";
          } else {
            startBtn.disabled = true;
            waitingText.textContent = "Czekam na drugiego gracza...";
            waitingText.style.color = "var(--accent-gold)";
          }
        }
      }

      function copyLobbyLink() {
        var link = document.getElementById("lobby-link").textContent;
        navigator.clipboard.writeText(link).then(function () {
          var btn = document.querySelector(".lobby-link-copy");
          btn.textContent = "✓ Skopiowano!";
          setTimeout(function () {
            btn.textContent = "📋 Kopiuj link";
          }, 2000);
        });
      }

      function leaveLobby() {
        if (peer) {
          peer.destroy();
          peer = null;
        }
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        lobbyId = null;
        isHost = false;
        onlinePlayers = [];
        myColor = null;
        G.gameMode = null;
        document.getElementById("opponent-info").style.display = "none";
        showScreen("menu");
      }

      function startOnlineGame() {
        if (!isHost || onlinePlayers.length < 2) return;

        // Wyślij info o starcie do gościa z wybranymi ustawieniami
        sendPeerData({
          type: "start",
          timeLimit: lobbyTimeLimit,
          increment: lobbyIncrement,
        });

        // Startuj grę lokalnie
        G.gameMode = "online";
        G.timeLimit = lobbyTimeLimit;
        G.increment = lobbyIncrement;
        updateOpponentDisplay();
        resetGame();
        showScreen("game");
      }

      // Wyświetl dane przeciwnika w trybie online
      function updateOpponentDisplay() {
        var opponentInfo = document.getElementById("opponent-info");
        if (G.gameMode === "online" && onlinePlayers.length >= 2) {
          // Znajdź przeciwnika (nie nas)
          var opponent = onlinePlayers.find(function (p) {
            return p.name !== playerProfile;
          });
          if (opponent) {
            document.getElementById("opponent-name").textContent =
              opponent.name;
            document.getElementById("opponent-elo").textContent =
              "⭐ " + (opponent.elo || 0);
            opponentInfo.style.display = "flex";
          }
        } else {
          opponentInfo.style.display = "none";
        }
      }

      // Sprawdzanie URL przy starcie
      function checkLobbyUrl() {
        var params = new URLSearchParams(window.location.search);
        var lobbyParam = params.get("lobby");
        if (lobbyParam) {
          if (!playerProfile) {
            showProfileScreen();
            window.pendingLobby = lobbyParam;
          } else {
            joinLobby(lobbyParam);
          }
        }
      }

      function joinLobby(id) {
        lobbyId = id;
        isHost = false;
        myColor = "black";
        onlinePlayers = [{ name: "Łączenie...", isHost: true }];

        showScreen("lobby");
        updateLobbyUI();
        document.getElementById("waiting-text").textContent =
          "Łączenie z hostem...";

        // Połącz się z hostem
        peer = new Peer({
          debug: 2,
        });

        peer.on("open", function (myId) {
          console.log("Moje peer ID:", myId);
          document.getElementById("waiting-text").textContent =
            "Nawiązywanie połączenia...";

          // Łącz się z hostem
          peerConnection = peer.connect(id, {
            reliable: true,
          });

          peerConnection.on("open", function () {
            console.log("Połączono z hostem!");
            document.getElementById("waiting-text").textContent =
              "Połączono! Wysyłanie danych...";
            // Wyślij swoje dane z ELO
            sendPeerData({ type: "join", name: playerProfile, elo: playerElo });
          });

          peerConnection.on("data", function (data) {
            handlePeerData(data);
          });

          peerConnection.on("close", function () {
            if (!G.gameOver) {
              alert("Host rozłączony!");
              leaveLobby();
            }
          });

          peerConnection.on("error", function (err) {
            console.error("Connection error:", err);
            document.getElementById("waiting-text").textContent =
              "Błąd połączenia!";
          });
        });

        peer.on("error", function (err) {
          console.error("Peer error:", err);
          if (err.type === "peer-unavailable") {
            document.getElementById("waiting-text").textContent =
              "Host nie znaleziony!";
            document.getElementById("waiting-text").style.color =
              "var(--accent-magenta)";
            setTimeout(function () {
              if (confirm("Nie znaleziono hosta. Spróbować ponownie?")) {
                peer.destroy();
                joinLobby(id);
              } else {
                leaveLobby();
              }
            }, 500);
          } else {
            document.getElementById("waiting-text").textContent =
              "Błąd: " + err.type;
          }
        });

        peer.on("disconnected", function () {
          console.log("Peer disconnected");
          if (!G.gameOver) {
            peer.reconnect();
          }
        });
      }

      function sendPeerData(data) {
        if (peerConnection && peerConnection.open) {
          peerConnection.send(data);
        }
      }

      function handlePeerData(data) {
        console.log("Otrzymano dane:", data);

        switch (data.type) {
          case "join":
            // Gość dołączył (tylko host otrzymuje)
            onlinePlayers = [
              { name: playerProfile, isHost: true, elo: playerElo },
              { name: data.name, isHost: false, elo: data.elo || 0 },
            ];
            updateLobbyUI();
            // Potwierdź dołączenie i wyślij ustawienia + ELO
            sendPeerData({
              type: "joined",
              hostName: playerProfile,
              hostElo: playerElo,
              timeLimit: lobbyTimeLimit,
              increment: lobbyIncrement,
            });
            break;

          case "joined":
            // Potwierdzenie od hosta (tylko gość otrzymuje)
            onlinePlayers = [
              { name: data.hostName, isHost: true, elo: data.hostElo || 0 },
              { name: playerProfile, isHost: false, elo: playerElo },
            ];
            // Wyświetl ustawienia hosta
            var timeDisplay = document.getElementById("lobby-time-display");
            var incDisplay = document.getElementById("lobby-inc-display");
            timeDisplay.textContent =
              data.timeLimit > 0 ? data.timeLimit + " min" : "∞";
            incDisplay.textContent = "+" + data.increment + "s";
            updateLobbyUI();
            break;

          case "start":
            // Host rozpoczął grę
            G.gameMode = "online";
            G.timeLimit = data.timeLimit;
            G.increment = data.increment;
            // Zapisz dane przeciwnika
            updateOpponentDisplay();
            resetGame();
            showScreen("game");
            break;

          case "move":
            // Przeciwnik wykonał ruch
            receiveOnlineMove(data);
            break;

          case "draw_offer":
            // Przeciwnik proponuje remis
            showDrawOffer(data.playerName);
            break;

          case "draw_response":
            // Odpowiedź na propozycję remisu
            handleDrawResponse(data.accepted, data.playerName);
            break;

          case "resign":
            // Przeciwnik się poddał
            handleOpponentResign(data.playerName);
            break;
        }
      }

      // System remisu
      var pendingDrawOffer = false; // Czy czekamy na odpowiedź
      var receivedDrawOffer = false; // Czy otrzymaliśmy propozycję

      function showDrawOffer(fromPlayer) {
        receivedDrawOffer = true;
        var modal = document.getElementById("draw-modal");
        var text = document.getElementById("draw-modal-text");
        text.textContent = fromPlayer + " proponuje remis";
        modal.classList.add("active");
        playSound("notify");
      }

      function acceptDraw() {
        receivedDrawOffer = false;
        document.getElementById("draw-modal").classList.remove("active");

        // Wyślij akceptację
        sendPeerData({
          type: "draw_response",
          accepted: true,
          playerName: playerProfile,
        });

        // Zakończ grę remisem
        endGameDraw();
      }

      function declineDraw() {
        receivedDrawOffer = false;
        document.getElementById("draw-modal").classList.remove("active");

        // Wyślij odrzucenie
        sendPeerData({
          type: "draw_response",
          accepted: false,
          playerName: playerProfile,
        });

        // Pokaż toast u nas
        showDrawToast("Odrzuciłeś remis", "declined");
      }

      function offerDraw() {
        if (pendingDrawOffer || G.gameOver) return;

        pendingDrawOffer = true;
        document.getElementById("btn-offer-draw").disabled = true;

        // Wyślij propozycję
        sendPeerData({ type: "draw_offer", playerName: playerProfile });

        // Pokaż toast
        showDrawToast("Propozycja remisu wysłana...", "sent");
      }

      function handleDrawResponse(accepted, fromPlayer) {
        pendingDrawOffer = false;
        document.getElementById("btn-offer-draw").disabled = false;

        if (accepted) {
          showDrawToast(fromPlayer + " zaakceptował remis!", "accepted");
          setTimeout(endGameDraw, 1500);
        } else {
          showDrawToast(fromPlayer + " odrzucił remis", "declined");
        }
      }

      function showDrawToast(message, type) {
        var toast = document.getElementById("draw-toast");
        toast.textContent = message;
        toast.className = "draw-toast active " + type;

        setTimeout(function () {
          toast.classList.remove("active");
        }, 2500);
      }

      function endGameDraw() {
        G.gameOver = true;
        if (G.timerInterval) clearInterval(G.timerInterval);

        document.getElementById("modal-title").textContent = "REMIS!";
        document.getElementById("modal-message").textContent =
          "Gracze zgodzili się na remis";
        document.getElementById("game-over-modal").classList.add("active");
      }

      function resignGame() {
        if (G.gameOver) return;

        if (confirm("Czy na pewno chcesz się poddać?")) {
          // Wyślij info o poddaniu
          sendPeerData({ type: "resign", playerName: playerProfile });

          // Zakończ grę - przegrywamy
          var winner = myColor === "white" ? "black" : "white";
          endGame(winner, "poddanie");
        }
      }

      function handleOpponentResign(playerName) {
        showDrawToast(playerName + " poddał się!", "accepted");
        setTimeout(function () {
          endGame(myColor, "poddanie");
        }, 1000);
      }

      // Automatyczne odrzucenie remisu przy ruchu
      function autoDeclineDrawOnMove() {
        if (receivedDrawOffer) {
          receivedDrawOffer = false;
          document.getElementById("draw-modal").classList.remove("active");
          sendPeerData({
            type: "draw_response",
            accepted: false,
            playerName: playerProfile,
          });
        }
      }

      function sendOnlineMove(startPos, endPos, path, isGuardian) {
        sendPeerData({
          type: "move",
          startX: startPos.x,
          startY: startPos.y,
          endX: endPos.x,
          endY: endPos.y,
          path: path,
          isGuardian: isGuardian || false,
        });
      }

      function receiveOnlineMove(data) {
        // Odtwórz ruch przeciwnika
        G.selectedPiece = { x: data.startX, y: data.startY };
        G.plannedPath = data.path;

        // Sprawdź czy użyto skosu
        G.usedDiagonal = false;
        for (var i = 1; i < data.path.length; i++) {
          var prev = data.path[i - 1],
            curr = data.path[i];
          if (
            Math.abs(curr.x - prev.x) === 1 &&
            Math.abs(curr.y - prev.y) === 1
          ) {
            G.usedDiagonal = true;
            break;
          }
        }

        var startPos = G.selectedPiece;
        var endPos = { x: data.endX, y: data.endY };
        var piece = G.board[startPos.y][startPos.x];
        var targetPiece = G.board[endPos.y][endPos.x];

        // Jeśli to ruch Strażnika (isGuardian w danych)
        if (data.isGuardian) {
          // Znajdź tarczę i stwórz strażnika
          for (var s = 0; s < G.sentinelShields.length; s++) {
            var shield = G.sentinelShields[s];
            if (
              shield.guardianX === data.startX &&
              shield.guardianY === data.startY &&
              shield.color !== myColor
            ) {
              piece = {
                symbol: SENTINEL_GUARDIAN.symbol,
                name: SENTINEL_GUARDIAN.name,
                moves: SENTINEL_GUARDIAN.moves,
                type: "guardian",
                straightOnly: true,
                color: shield.color,
                isGuardian: true,
                shieldIndex: s,
              };
              G.board[startPos.y][startPos.x] = piece;
              break;
            }
          }
        }

        if (!piece) return; // Brak figury

        // Atak - bez animacji
        if (targetPiece && targetPiece.color !== piece.color) {
          finishMove(startPos, endPos, piece, targetPiece, G.currentPlayer);
          return;
        }

        // Normalny ruch - z animacją
        animateMove(
          startPos.x,
          startPos.y,
          endPos.x,
          endPos.y,
          piece,
          function () {
            finishMove(startPos, endPos, piece, targetPiece, G.currentPlayer);
          }
        );
      }

      function canMakeMove() {
        // W trybie online - możesz ruszyć tylko swoje figury
        if (G.gameMode === "online") {
          return G.currentPlayer === myColor;
        }
        return true;
      }

      // Animacja ruchu figury
      function animateMove(startX, startY, endX, endY, piece, callback) {
        G.isAnimating = true;
        var board = document.getElementById("board");
        var boardRect = board.getBoundingClientRect();
        var tileSize = boardRect.width / 8;
        var flipped = shouldFlipBoard();

        // Pozycje na ekranie - jeśli obrócone, CSS już obraca więc współrzędne są odwrócone wizualnie
        var screenStartX = flipped ? 7 - startX : startX;
        var screenStartY = flipped ? 7 - startY : startY;
        var screenEndX = flipped ? 7 - endX : endX;
        var screenEndY = flipped ? 7 - endY : endY;

        // Schowaj figurę na planszy
        var tileIndex = startY * 8 + startX;
        var originalTile = board.querySelectorAll(".tile")[tileIndex];
        var originalPiece = originalTile
          ? originalTile.querySelector(".piece")
          : null;
        if (originalPiece) originalPiece.style.visibility = "hidden";

        // Tworzymy animowany element
        var movingPiece = document.createElement("div");
        movingPiece.className = "moving-piece " + piece.color;
        movingPiece.innerHTML =
          '<span class="piece-symbol">' + piece.symbol + "</span>";
        movingPiece.style.position = "fixed";
        movingPiece.style.width = tileSize + "px";
        movingPiece.style.height = tileSize + "px";
        movingPiece.style.display = "flex";
        movingPiece.style.alignItems = "center";
        movingPiece.style.justifyContent = "center";
        movingPiece.style.left =
          boardRect.left + screenStartX * tileSize + "px";
        movingPiece.style.top = boardRect.top + screenStartY * tileSize + "px";
        movingPiece.style.transition =
          "left 0.25s ease-out, top 0.25s ease-out";
        movingPiece.style.zIndex = "1000";
        document.body.appendChild(movingPiece);

        // Uruchamiamy animację
        requestAnimationFrame(function () {
          movingPiece.style.left =
            boardRect.left + screenEndX * tileSize + "px";
          movingPiece.style.top = boardRect.top + screenEndY * tileSize + "px";
        });

        // Po zakończeniu animacji
        setTimeout(function () {
          movingPiece.remove();
          G.isAnimating = false;
          if (callback) callback();
        }, 280);
      }

      function initBoard() {
        G.board = Array(8)
          .fill(null)
          .map(() => Array(8).fill(null));
        const setup = [
          PIECES.ROOK,
          PIECES.KNIGHT,
          PIECES.BISHOP,
          PIECES.QUEEN,
          PIECES.KING,
          PIECES.BISHOP,
          PIECES.KNIGHT,
          PIECES.ROOK,
        ];
        for (let x = 0; x < 8; x++) {
          G.board[0][x] = { ...setup[x], color: "black" };
          G.board[1][x] = { ...PIECES.PAWN, color: "black" };
          G.board[6][x] = { ...PIECES.PAWN, color: "white" };
          G.board[7][x] = { ...setup[x], color: "white" };
        }
      }

      function resetGame() {
        initBoard();
        if (G.timerInterval) clearInterval(G.timerInterval);
        G.whiteTime = G.timeLimit * 60;
        G.blackTime = G.timeLimit * 60;
        G.gameStates = [];
        G.currentStateIndex = -1;
        G.analyzing = false;
        Object.assign(G, {
          currentPlayer: "white",
          selectedPiece: null,
          plannedPath: [],
          usedDiagonal: false,
          pendingCaptures: [],
          capturedByWhite: [],
          capturedByBlack: [],
          moveHistory: [],
          gameOver: false,
          inCheck: null,
          movesWithoutAttack: 0,
        });
        document.getElementById("move-log").innerHTML = "";
        document.getElementById("analysis-controls").style.display = "none";

        // Pokaż/ukryj przyciski online
        var onlineActions = document.getElementById("online-actions");
        if (G.gameMode === "online") {
          onlineActions.style.display = "flex";
          pendingDrawOffer = false;
          receivedDrawOffer = false;
          document.getElementById("btn-offer-draw").disabled = false;
        } else {
          onlineActions.style.display = "none";
        }

        saveGameState("Start gry", null);
        updateTimerDisplay();
        if (G.timeLimit > 0) startTimer();
        renderBoard();
        updateUI();
      }

      function saveGameState(description, color) {
        var state = {
          board: JSON.parse(JSON.stringify(G.board)),
          pendingCaptures: JSON.parse(JSON.stringify(G.pendingCaptures)),
          capturedByWhite: JSON.parse(JSON.stringify(G.capturedByWhite)),
          capturedByBlack: JSON.parse(JSON.stringify(G.capturedByBlack)),
          currentPlayer: G.currentPlayer,
          inCheck: G.inCheck,
          description: description,
          moveColor: color,
          whiteTime: G.whiteTime,
          blackTime: G.blackTime,
          moveNumber: G.gameStates.length,
        };
        G.gameStates.push(state);
        G.currentStateIndex = G.gameStates.length - 1;
        updateMoveLogWithStates();
      }

      function updateMoveLogWithStates() {
        var log = document.getElementById("move-log");
        log.innerHTML = "";
        for (var i = G.gameStates.length - 1; i >= 0; i--) {
          var state = G.gameStates[i];
          var entry = document.createElement("div");
          entry.className =
            "log-entry" +
            (state.moveColor ? " " + state.moveColor + "-move" : "") +
            (i === G.currentStateIndex && G.analyzing ? " active-state" : "");
          entry.textContent = state.moveNumber + ". " + state.description;
          entry.dataset.stateIndex = i;
          (function (idx) {
            entry.addEventListener("click", function () {
              if (G.gameOver || G.analyzing) {
                loadGameState(idx);
              }
            });
          })(i);
          log.appendChild(entry);
        }
      }

      function loadGameState(index) {
        if (index < 0 || index >= G.gameStates.length) return;

        // Reset what-if mode gdy zmieniamy stan
        resetWhatIfMode();

        G.currentStateIndex = index;
        G.analyzing = true;
        var state = G.gameStates[index];
        G.board = JSON.parse(JSON.stringify(state.board));
        G.pendingCaptures = JSON.parse(JSON.stringify(state.pendingCaptures));
        G.capturedByWhite = JSON.parse(JSON.stringify(state.capturedByWhite));
        G.capturedByBlack = JSON.parse(JSON.stringify(state.capturedByBlack));
        G.currentPlayer = state.currentPlayer;
        G.inCheck = state.inCheck;

        document.getElementById("analysis-controls").style.display = "block";
        document.getElementById("state-info").textContent =
          "Ruch " +
          state.moveNumber +
          "/" +
          (G.gameStates.length - 1) +
          ": " +
          state.description;
        document.getElementById("whatif-panel").style.display = "block";

        renderBoard();
        updateUI();
        updateMoveLogWithStates();
      }

      function navigateState(delta) {
        var newIndex = G.currentStateIndex + delta;
        if (newIndex >= 0 && newIndex < G.gameStates.length) {
          loadGameState(newIndex);
        }
      }

      function startWhatIfMode() {
        if (!G.analyzing) return;
        G.whatIfMode = true;
        G.whatIfBaseIndex = G.currentStateIndex;
        G.whatIfRounds = 0;
        // Zapisz stan bazowy
        G.whatIfBoard = JSON.parse(JSON.stringify(G.board));
        G.whatIfPending = JSON.parse(JSON.stringify(G.pendingCaptures));
        G.whatIfCapturedW = JSON.parse(JSON.stringify(G.capturedByWhite));
        G.whatIfCapturedB = JSON.parse(JSON.stringify(G.capturedByBlack));
        G.whatIfPlayer = G.currentPlayer;
        updateWhatIfDisplay();
      }

      function resetWhatIfMode() {
        if (G.whatIfMode && G.whatIfBoard) {
          G.board = JSON.parse(JSON.stringify(G.whatIfBoard));
          G.pendingCaptures = JSON.parse(JSON.stringify(G.whatIfPending));
          G.capturedByWhite = JSON.parse(JSON.stringify(G.whatIfCapturedW));
          G.capturedByBlack = JSON.parse(JSON.stringify(G.whatIfCapturedB));
          G.currentPlayer = G.whatIfPlayer;
        }
        G.whatIfMode = false;
        G.whatIfRounds = 0;
        G.whatIfBoard = null;
        G.whatIfPending = null;
        G.whatIfCapturedW = null;
        G.whatIfCapturedB = null;
        G.whatIfPlayer = null;
        G.selectedPiece = null;
        G.plannedPath = [];
        // Wyczyść strzałki analizy
        analysisArrows = [];
        analysisArrowStart = null;
        updateWhatIfDisplay();
        renderBoard();
        updateUI();
      }

      function updateWhatIfDisplay() {
        var counter = document.getElementById("whatif-rounds");
        if (counter) {
          counter.textContent = G.whatIfRounds;
        }
      }

      function executeWhatIfMove() {
        G.whatIfRounds++;
        updateWhatIfDisplay();
      }

      function formatTime(seconds) {
        if (seconds === Infinity || (seconds <= 0 && G.timeLimit === 0))
          return "∞";
        var mins = Math.floor(seconds / 60);
        var secs = seconds % 60;
        return mins + ":" + (secs < 10 ? "0" : "") + secs;
      }

      function updateTimerDisplay() {
        var whiteEl = document.getElementById("white-time");
        var blackEl = document.getElementById("black-time");
        var whiteTimer = document.getElementById("white-timer");
        var blackTimer = document.getElementById("black-timer");

        if (G.timeLimit === 0) {
          whiteEl.textContent = "∞";
          blackEl.textContent = "∞";
          whiteTimer.classList.remove("active", "low-time");
          blackTimer.classList.remove("active", "low-time");
        } else {
          whiteEl.textContent = formatTime(G.whiteTime);
          blackEl.textContent = formatTime(G.blackTime);

          whiteTimer.classList.toggle(
            "active",
            G.currentPlayer === "white" && !G.gameOver
          );
          blackTimer.classList.toggle(
            "active",
            G.currentPlayer === "black" && !G.gameOver
          );
          whiteTimer.classList.toggle(
            "low-time",
            G.whiteTime <= 30 && G.whiteTime > 0
          );
          blackTimer.classList.toggle(
            "low-time",
            G.blackTime <= 30 && G.blackTime > 0
          );
        }
      }

      function startTimer() {
        if (G.timerInterval) clearInterval(G.timerInterval);
        var lastLowTimeSound = 0;
        G.timerInterval = setInterval(function () {
          if (G.gameOver) {
            clearInterval(G.timerInterval);
            return;
          }
          if (G.currentPlayer === "white") {
            G.whiteTime--;
            // Dźwięk niskiego czasu co 10 sekund
            if (
              G.whiteTime <= 30 &&
              G.whiteTime > 0 &&
              G.whiteTime % 10 === 0 &&
              G.whiteTime !== lastLowTimeSound
            ) {
              lastLowTimeSound = G.whiteTime;
              playSound("lowTime");
            }
            if (G.whiteTime <= 0) {
              G.whiteTime = 0;
              clearInterval(G.timerInterval);
              endGame("black", "czas");
            }
          } else {
            G.blackTime--;
            // Dźwięk niskiego czasu co 10 sekund
            if (
              G.blackTime <= 30 &&
              G.blackTime > 0 &&
              G.blackTime % 10 === 0 &&
              G.blackTime !== lastLowTimeSound
            ) {
              lastLowTimeSound = G.blackTime;
              playSound("lowTime");
            }
            if (G.blackTime <= 0) {
              G.blackTime = 0;
              clearInterval(G.timerInterval);
              endGame("white", "czas");
            }
          }
          updateTimerDisplay();
        }, 1000);
      }

      function addTimeIncrement() {
        if (G.timeLimit === 0) return;
        if (G.currentPlayer === "white") {
          G.whiteTime += G.increment;
        } else {
          G.blackTime += G.increment;
        }
        updateTimerDisplay();
      }

      function getZoneClass(x, y) {
        if (!G.showZones) return "";
        if ((x === 3 || x === 4) && (y === 3 || y === 4)) return "zone-center";
        if (x >= 4 && y >= 6) return "zone-nexus-white";
        if (x <= 3 && y >= 6) return "zone-phantom-white";
        if (x >= 4 && y <= 1) return "zone-nexus-black";
        if (x <= 3 && y <= 1) return "zone-phantom-black";
        return "";
      }

      function getArrowForMove(fromX, fromY, toX, toY) {
        var dx = toX - fromX,
          dy = toY - fromY;
        if (dx !== 0) dx = dx / Math.abs(dx);
        if (dy !== 0) dy = dy / Math.abs(dy);
        for (var key in DIRECTIONS) {
          var dir = DIRECTIONS[key];
          if (dir.dx === dx && dir.dy === dy) return dir.arrow;
        }
        return "⬤";
      }

      function isPieceLocked(x, y) {
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          if (
            G.pendingCaptures[i].targetX === x &&
            G.pendingCaptures[i].targetY === y
          )
            return true;
        }
        return false;
      }

      function renderBoard() {
        var boardEl = document.getElementById("board");
        boardEl.innerHTML = "";
        var validMoves = getValidNextSteps();

        var pathArrows = {};
        for (var i = 1; i < G.plannedPath.length; i++) {
          var prev = G.plannedPath[i - 1],
            curr = G.plannedPath[i];
          pathArrows[curr.x + "," + curr.y] = getArrowForMove(
            prev.x,
            prev.y,
            curr.x,
            curr.y
          );
        }

        var lockArrows = {};
        G.pendingCaptures.forEach(function (cap) {
          lockArrows[cap.targetX + "," + cap.targetY] = {
            arrow: getArrowForMove(
              cap.attackerX,
              cap.attackerY,
              cap.targetX,
              cap.targetY
            ),
            color: cap.attackerColor,
            turns: cap.turnsLeft,
            attackerSymbol: cap.attackerSymbol,
          };
        });

        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var tile = document.createElement("div");
            var baseClass = (x + y) % 2 === 0 ? "light" : "dark";
            var zoneClass = getZoneClass(x, y);
            tile.className =
              "tile " + baseClass + (zoneClass ? " " + zoneClass : "");
            var piece = G.board[y][x];

            var pathKey = x + "," + y;
            if (pathArrows[pathKey]) {
              var arrowEl = document.createElement("div");
              arrowEl.className = "path-arrow";
              arrowEl.textContent = pathArrows[pathKey];
              tile.appendChild(arrowEl);
            }

            var lockKey = x + "," + y;
            if (lockArrows[lockKey]) {
              var lockData = lockArrows[lockKey];
              var lockEl = document.createElement("div");
              lockEl.className = "lock-arrow " + lockData.color + "-lock";
              lockEl.textContent = lockData.arrow;
              tile.appendChild(lockEl);
              var attackerEl = document.createElement("div");
              attackerEl.className = "attacker-pos " + lockData.color + "-lock";
              attackerEl.textContent = lockData.attackerSymbol;
              tile.appendChild(attackerEl);
              if (lockData.turns > 0) {
                var timerEl = document.createElement("div");
                timerEl.className = "lock-timer " + lockData.color + "-lock";
                timerEl.textContent = lockData.turns;
                tile.appendChild(timerEl);
              }
              tile.classList.add("threat");
            }

            // Sprawdź czy pole jest częścią Tarczy Sentinela
            var shieldInfo = getShieldAtTile(x, y);
            if (shieldInfo) {
              tile.classList.add("sentinel-shield");
              tile.classList.add(shieldInfo.color + "-shield");

              // Jeśli to miejsce Strażnika
              if (shieldInfo.isGuardian && !piece) {
                var guardianEl = document.createElement("div");
                guardianEl.className = "piece guardian " + shieldInfo.color;
                guardianEl.innerHTML =
                  '<span class="piece-symbol">' +
                  SENTINEL_GUARDIAN.symbol +
                  "</span>";
                tile.appendChild(guardianEl);
              }
            }

            if (piece) {
              var pieceEl = document.createElement("div");
              pieceEl.className = "piece " + piece.color;
              if (isPieceAttacking(x, y)) {
                pieceEl.classList.add("attacking");
                pieceEl.classList.add("is-attacker"); // Żółte pulsowanie dla atakującego
              }
              // Sprawdź czy figura brała udział w podwójnym ataku
              for (var da = 0; da < G.doubleAttackPieces.length; da++) {
                if (
                  G.doubleAttackPieces[da].x === x &&
                  G.doubleAttackPieces[da].y === y
                ) {
                  pieceEl.classList.add("double-attacker");
                  break;
                }
              }
              if (piece.frozenTurns && piece.frozenTurns > 0) {
                pieceEl.classList.add("frozen");
                // Dodaj licznik zamrożenia
                var frozenTimer = document.createElement("div");
                frozenTimer.className = "frozen-timer";
                frozenTimer.textContent = "❄" + piece.frozenTurns;
                tile.appendChild(frozenTimer);
              }
              pieceEl.innerHTML =
                '<span class="piece-symbol">' + piece.symbol + "</span>";
              tile.appendChild(pieceEl);
              if (piece.type === "king" && G.inCheck === piece.color)
                tile.classList.add("threatened-king");

              // Ikona oceny ruchu (jak w chess.com)
              if (
                G.lastMove &&
                G.lastMove.endX === x &&
                G.lastMove.endY === y &&
                G.lastMove.icon
              ) {
                var iconEl = document.createElement("div");
                iconEl.className = "move-icon " + G.lastMove.icon;
                var iconText = {
                  brilliant: "!!",
                  great: "!",
                  good: "✓",
                  book: "📖",
                  inaccuracy: "?!",
                  mistake: "?",
                  blunder: "??",
                };
                iconEl.textContent = iconText[G.lastMove.icon] || "";
                tile.appendChild(iconEl);
              }
            }
            if (
              G.selectedPiece &&
              G.selectedPiece.x === x &&
              G.selectedPiece.y === y
            )
              tile.classList.add("selected");
            if (
              validMoves.some(function (m) {
                return m.x === x && m.y === y;
              })
            )
              tile.classList.add("valid-move");

            // Kliknięcie - współrzędne są poprawne, CSS tylko obraca wizualnie
            (function (tx, ty) {
              tile.addEventListener("click", function (event) {
                handleTileClick(tx, ty, event);
              });
              tile.addEventListener("mouseenter", function () {
                handleTileHover(tx, ty);
              });
            })(x, y);
            boardEl.appendChild(tile);
          }
        }

        // Renderuj strzałki analizy (SVG overlay)
        renderAnalysisArrows();
      }

      function getShieldAtTile(x, y) {
        for (var i = 0; i < G.sentinelShields.length; i++) {
          var shield = G.sentinelShields[i];
          for (var j = 0; j < shield.tiles.length; j++) {
            if (shield.tiles[j].x === x && shield.tiles[j].y === y) {
              return {
                color: shield.color,
                isGuardian: shield.guardianX === x && shield.guardianY === y,
              };
            }
          }
        }
        return null;
      }

      function getGuardianAt(x, y) {
        for (var i = 0; i < G.sentinelShields.length; i++) {
          var shield = G.sentinelShields[i];
          if (shield.guardianX === x && shield.guardianY === y) {
            return {
              color: shield.color,
              shieldIndex: i,
            };
          }
        }
        return null;
      }

      function renderAnalysisArrows() {
        // Usuń stary SVG
        var oldSvg = document.getElementById("analysis-arrows-svg");
        if (oldSvg) oldSvg.remove();

        if (analysisArrows.length === 0) return;

        var board = document.getElementById("board");
        var tiles = board.querySelectorAll(".tile");
        if (tiles.length === 0) return;

        var tileSize = tiles[0].offsetWidth;
        var boardSize = tileSize * 8;

        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.id = "analysis-arrows-svg";
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = boardSize + "px";
        svg.style.height = boardSize + "px";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "100";
        svg.setAttribute("viewBox", "0 0 " + boardSize + " " + boardSize);

        // Definicja strzałki
        var defs = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "defs"
        );
        var marker = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "marker"
        );
        marker.setAttribute("id", "arrowhead");
        marker.setAttribute("markerWidth", "10");
        marker.setAttribute("markerHeight", "7");
        marker.setAttribute("refX", "9");
        marker.setAttribute("refY", "3.5");
        marker.setAttribute("orient", "auto");
        var polygon = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "polygon"
        );
        polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
        polygon.setAttribute("fill", "#ff6600");
        marker.appendChild(polygon);
        defs.appendChild(marker);
        svg.appendChild(defs);

        analysisArrows.forEach(function (arrow) {
          var line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );

          // Znajdź rzeczywiste pozycje kafelków
          var fromTile = tiles[arrow.fromY * 8 + arrow.fromX];
          var toTile = tiles[arrow.toY * 8 + arrow.toX];

          if (!fromTile || !toTile) return;

          // Środek każdego kafelka względem board
          var x1 = fromTile.offsetLeft + fromTile.offsetWidth / 2;
          var y1 = fromTile.offsetTop + fromTile.offsetHeight / 2;
          var x2 = toTile.offsetLeft + toTile.offsetWidth / 2;
          var y2 = toTile.offsetTop + toTile.offsetHeight / 2;

          line.setAttribute("x1", x1);
          line.setAttribute("y1", y1);
          line.setAttribute("x2", x2);
          line.setAttribute("y2", y2);
          line.setAttribute("stroke", "#ff6600");
          line.setAttribute("stroke-width", "8");
          line.setAttribute("stroke-opacity", "0.85");
          line.setAttribute("stroke-linecap", "round");
          line.setAttribute("marker-end", "url(#arrowhead)");
          svg.appendChild(line);
        });

        // Dodaj SVG do board (nie wrapper) żeby było w tym samym kontekście obrotu
        board.appendChild(svg);
      }

      function updateUI() {
        var ti = document.getElementById("turn-indicator");
        ti.className = "turn-indicator " + G.currentPlayer + "-turn";
        document.getElementById("current-player").textContent =
          G.currentPlayer === "white" ? "BIAŁE" : "CZARNE";
        var mip = document.getElementById("move-info-panel");
        if (G.selectedPiece) {
          var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
          if (piece) {
            mip.style.display = "block";
            document.getElementById("selected-piece-name").textContent =
              piece.name + " " + piece.symbol;
            document.getElementById("moves-left").textContent =
              piece.moves - (G.plannedPath.length - 1);
          } else mip.style.display = "none";
        } else mip.style.display = "none";
        document.getElementById("white-captured").innerHTML = G.capturedByWhite
          .map(function (p) {
            return '<div class="captured-piece">' + p.symbol + "</div>";
          })
          .join("");
        document.getElementById("black-captured").innerHTML = G.capturedByBlack
          .map(function (p) {
            return '<div class="captured-piece">' + p.symbol + "</div>";
          })
          .join("");
        var pe = document.getElementById("pending-captures");
        if (G.pendingCaptures.length > 0) {
          pe.style.display = "block";
          document.getElementById("pending-list").innerHTML = G.pendingCaptures
            .map(function (cap) {
              var target = G.board[cap.targetY]
                ? G.board[cap.targetY][cap.targetX]
                : null;
              return target
                ? '<div class="pending-item">' +
                    cap.attackerSymbol +
                    " → " +
                    target.symbol +
                    " (" +
                    cap.turnsLeft +
                    " tur)</div>"
                : "";
            })
            .join("");
        } else pe.style.display = "none";

        // Mobile turn info
        var mobileTurnPlayer = document.getElementById("mobile-turn-player");
        var mobileTurnMoves = document.getElementById("mobile-turn-moves");
        mobileTurnPlayer.textContent =
          G.currentPlayer === "white" ? "BIAŁE" : "CZARNE";
        mobileTurnPlayer.className =
          "mobile-turn-player " + G.currentPlayer + "-turn";
        if (G.selectedPiece) {
          var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
          if (piece) {
            var movesLeft = piece.moves - (G.plannedPath.length - 1);
            mobileTurnMoves.textContent =
              piece.name +
              " • " +
              movesLeft +
              " " +
              (movesLeft === 1 ? "krok" : "kroki");
          } else {
            mobileTurnMoves.textContent = "";
          }
        } else {
          mobileTurnMoves.textContent = "Wybierz figurę";
        }

        // Obrót planszy w PvP na mobile
        updateBoardRotation();
      }

      function updateBoardRotation() {
        var boardWrapper = document.getElementById("board-wrapper");
        var boardContainer = document.querySelector(".game-board-container");
        if (!boardWrapper) return;

        var shouldRotate = false;

        // Online - czarny zawsze widzi obrócone
        if (G.gameMode === "online" && myColor === "black") {
          shouldRotate = true;
        }
        // PvP - obrót przy turze czarnych
        else if (G.gameMode === "pvp" && !G.gameOver && !G.analyzing) {
          if (G.currentPlayer === "black") {
            shouldRotate = true;
          }
        }

        if (shouldRotate) {
          boardWrapper.classList.add("rotated");
          if (boardContainer) boardContainer.classList.add("flipped");
        } else {
          boardWrapper.classList.remove("rotated");
          if (boardContainer) boardContainer.classList.remove("flipped");
        }
      }

      function shouldFlipBoard() {
        var boardWrapper = document.getElementById("board-wrapper");
        return boardWrapper && boardWrapper.classList.contains("rotated");
      }

      // Ocena pozycji - zaawansowany algorytm
      function evaluatePosition() {
        var pieceValues = {
          king: 0, // Król nie ma wartości materialnej
          queen: 9, // Phantom
          rook: 5, // Sentinel
          bishop: 3, // Shade
          knight: 3, // Drifter
          pawn: 1, // Shard
        };

        var whiteScore = 0;
        var blackScore = 0;
        var whiteMobility = 0;
        var blackMobility = 0;

        // Tablice pozycyjne (bonus za dobre pola)
        var pawnTable = [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
          [0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1],
          [0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05],
          [0, 0, 0, 0.2, 0.2, 0, 0, 0],
          [0.05, -0.05, -0.1, 0, 0, -0.1, -0.05, 0.05],
          [0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05],
          [0, 0, 0, 0, 0, 0, 0, 0],
        ];

        var knightTable = [
          [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],
          [-0.4, -0.2, 0, 0, 0, 0, -0.2, -0.4],
          [-0.3, 0, 0.1, 0.15, 0.15, 0.1, 0, -0.3],
          [-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3],
          [-0.3, 0, 0.15, 0.2, 0.2, 0.15, 0, -0.3],
          [-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3],
          [-0.4, -0.2, 0, 0.05, 0.05, 0, -0.2, -0.4],
          [-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5],
        ];

        var centerTable = [
          [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],
          [-0.1, 0, 0, 0, 0, 0, 0, -0.1],
          [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],
          [-0.1, 0, 0.1, 0.2, 0.2, 0.1, 0, -0.1],
          [-0.1, 0, 0.1, 0.2, 0.2, 0.1, 0, -0.1],
          [-0.1, 0, 0.1, 0.1, 0.1, 0.1, 0, -0.1],
          [-0.1, 0, 0, 0, 0, 0, 0, -0.1],
          [-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2],
        ];

        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var piece = G.board[y][x];
            if (!piece) continue;

            var value = pieceValues[piece.type] || 0;
            var posBonus = 0;

            // Bonus pozycyjny zależny od figury
            if (piece.type === "pawn") {
              var py = piece.color === "white" ? y : 7 - y;
              posBonus = pawnTable[py][x];
              // Bonus za zaawansowane pionki
              if (piece.color === "white") {
                posBonus += (7 - y) * 0.1;
              } else {
                posBonus += y * 0.1;
              }
            } else if (piece.type === "knight") {
              var ky = piece.color === "white" ? y : 7 - y;
              posBonus = knightTable[ky][x];
            } else if (piece.type === "queen" || piece.type === "rook") {
              posBonus = centerTable[y][x] * 0.5;
            } else if (piece.type === "bishop") {
              posBonus = centerTable[y][x] * 0.3;
            }

            value += posBonus;

            // Mobilność - ile ruchów ma figura
            if (piece.type !== "king") {
              var moves = getAllMovesForPiece(x, y, piece, false);
              var mobilityBonus = moves.length * 0.05;
              if (piece.color === "white") {
                whiteMobility += mobilityBonus;
              } else {
                blackMobility += mobilityBonus;
              }
            }

            // Bezpieczeństwo króla
            if (piece.type === "king") {
              var enemyColor = piece.color === "white" ? "black" : "white";
              // Kara jeśli król jest w centrum (niebezpiecznie)
              if (x >= 2 && x <= 5 && y >= 2 && y <= 5) {
                value -= 0.5;
              }
              // Bonus za figury obronne w pobliżu
              for (var dy = -1; dy <= 1; dy++) {
                for (var dx = -1; dx <= 1; dx++) {
                  var nx = x + dx,
                    ny = y + dy;
                  if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                    var neighbor = G.board[ny][nx];
                    if (
                      neighbor &&
                      neighbor.color === piece.color &&
                      neighbor.type !== "king"
                    ) {
                      value += 0.1;
                    }
                  }
                }
              }
            }

            // Zamrożona figura = mniejsza wartość
            if (piece.frozenTurns && piece.frozenTurns > 0) {
              value *= 0.7;
            }

            if (piece.color === "white") {
              whiteScore += value;
            } else {
              blackScore += value;
            }
          }
        }

        // Dodaj mobilność
        whiteScore += whiteMobility;
        blackScore += blackMobility;

        // Sprawdź zbite figury
        G.capturedByWhite.forEach(function (p) {
          whiteScore += pieceValues[p.type];
        });
        G.capturedByBlack.forEach(function (p) {
          blackScore += pieceValues[p.type];
        });

        // Sprawdź aktywne blokady
        G.pendingCaptures.forEach(function (cap) {
          var targetPiece = G.board[cap.targetY]
            ? G.board[cap.targetY][cap.targetX]
            : null;
          if (targetPiece) {
            var threatValue = pieceValues[targetPiece.type] * 0.3;
            // Blokada z 1 turą = bardziej groźna
            if (cap.turnsLeft === 1) threatValue *= 1.5;

            if (cap.attackerColor === "white") {
              whiteScore += threatValue;
            } else {
              blackScore += threatValue;
            }
          }
        });

        // Podwójny atak = ogromny bonus
        var attackCounts = {};
        G.pendingCaptures.forEach(function (cap) {
          var key = cap.targetX + "," + cap.targetY;
          if (!attackCounts[key]) attackCounts[key] = { white: 0, black: 0 };
          attackCounts[key][cap.attackerColor]++;
        });
        for (var key in attackCounts) {
          if (attackCounts[key].white >= 2) whiteScore += 3;
          if (attackCounts[key].black >= 2) blackScore += 3;
        }

        // Szach = bonus
        if (G.inCheck === "white") blackScore += 1.5;
        if (G.inCheck === "black") whiteScore += 1.5;

        // Tarcza Sentinela = bonus
        G.sentinelShields.forEach(function (shield) {
          if (shield.color === "white") {
            whiteScore += 0.8 + shield.tiles.length * 0.1;
          } else {
            blackScore += 0.8 + shield.tiles.length * 0.1;
          }
        });

        // ===== OCENA BLISKOŚCI MATA =====
        var whiteMateScore = evaluateMateProximity("white");
        var blackMateScore = evaluateMateProximity("black");

        // Dodaj do wyniku (ujemny = bliżej bycia zamatowanym)
        whiteScore += blackMateScore; // Jeśli czarny blisko mata = bonus dla białego
        blackScore += whiteMateScore; // Jeśli biały blisko mata = bonus dla czarnego

        var finalEval = whiteScore - blackScore;

        // ===== OCENA BLISKOŚCI REMISU =====
        // Im bliżej remisu, tym bardziej eval zbliża się do 0
        var drawProximity = getDrawProximity();
        if (drawProximity > 0) {
          // drawProximity = 0-1, gdzie 1 = remis
          // Zmniejszamy eval proporcjonalnie do bliskości remisu
          finalEval = finalEval * (1 - drawProximity * 0.9);
        }

        return finalEval;
      }

      // Oblicz jak blisko jest do remisu (0 = daleko, 1 = remis)
      function getDrawProximity() {
        var maxProximity = 0;

        // 1. Ruchy bez ataku (10 = remis)
        var attackDrawProximity = G.movesWithoutAttack / 10;
        if (attackDrawProximity > maxProximity)
          maxProximity = attackDrawProximity;

        // 2. Pogromca nieaktywny (4 tury = remis)
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (p && p.kills && p.kills >= 3 && p.turnsUnused) {
              var slayerDrawProximity = p.turnsUnused / 4;
              if (slayerDrawProximity > maxProximity)
                maxProximity = slayerDrawProximity;
            }
          }
        }

        return Math.min(maxProximity, 1);
      }

      // Ocena jak blisko dany kolor jest do bycia zamatowanym
      // Zwraca wartość dodatnią = przeciwnik blisko mata (dobrze dla nas)
      function evaluateMateProximity(kingColor) {
        var score = 0;
        var enemyColor = kingColor === "white" ? "black" : "white";

        // Znajdź króla
        var kingPos = null;
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (p && p.type === "king" && p.color === kingColor) {
              kingPos = { x: x, y: y };
              break;
            }
          }
          if (kingPos) break;
        }

        if (!kingPos) return 0;

        // 1. Czy król jest pod szachem?
        var isInCheck = G.inCheck === kingColor;
        if (isInCheck) score += 3;

        // 2. Ile pól ucieczki ma król?
        var kingPiece = G.board[kingPos.y][kingPos.x];
        var escapeMoves = getAllMovesForPiece(
          kingPos.x,
          kingPos.y,
          kingPiece,
          false
        );

        // Filtruj bezpieczne pola
        var safeEscapes = 0;
        for (var i = 0; i < escapeMoves.length; i++) {
          var path = escapeMoves[i];
          if (path.length > 1) {
            var endPos = path[path.length - 1];
            if (!isSquareThreatened(endPos.x, endPos.y, enemyColor)) {
              safeEscapes++;
            }
          }
        }

        // Mało bezpiecznych pól = bliżej mata
        if (safeEscapes === 0 && isInCheck) {
          score += 50; // Prawie mat!
        } else if (safeEscapes === 0) {
          score += 8; // Król zablokowany ale nie szach
        } else if (safeEscapes === 1) {
          score += 4; // Tylko jedno pole ucieczki
        } else if (safeEscapes === 2) {
          score += 2;
        }

        // 3. Czy król jest w rogu/na krawędzi? (łatwiej zamatować)
        if (
          (kingPos.x === 0 || kingPos.x === 7) &&
          (kingPos.y === 0 || kingPos.y === 7)
        ) {
          score += 1.5; // Róg
        } else if (
          kingPos.x === 0 ||
          kingPos.x === 7 ||
          kingPos.y === 0 ||
          kingPos.y === 7
        ) {
          score += 0.8; // Krawędź
        }

        // 4. Ile wrogich figur atakuje pola wokół króla?
        var threatsAroundKing = 0;
        for (var dy = -1; dy <= 1; dy++) {
          for (var dx = -1; dx <= 1; dx++) {
            var nx = kingPos.x + dx,
              ny = kingPos.y + dy;
            if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
              if (isSquareThreatened(nx, ny, enemyColor)) {
                threatsAroundKing++;
              }
            }
          }
        }
        score += threatsAroundKing * 0.3;

        // 5. Czy jest aktywna blokada na królu?
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          var cap = G.pendingCaptures[i];
          if (
            cap.targetX === kingPos.x &&
            cap.targetY === kingPos.y &&
            cap.isNexusLock
          ) {
            if (cap.turnsLeft === 1) {
              score += 15; // Ostatnia szansa na ucieczkę!
            } else {
              score += 8;
            }
          }
        }

        // 6. Stosunek materiału - jeśli przeciwnik ma dużo figur a my mało, bliżej mata
        var ourMaterial = 0,
          theirMaterial = 0;
        var pieceVals = { queen: 9, rook: 5, bishop: 3, knight: 3, pawn: 1 };
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (p && p.type !== "king") {
              if (p.color === kingColor) {
                ourMaterial += pieceVals[p.type] || 0;
              } else {
                theirMaterial += pieceVals[p.type] || 0;
              }
            }
          }
        }

        // Duża przewaga materialna przeciwnika = bliżej mata
        var materialDiff = theirMaterial - ourMaterial;
        if (materialDiff > 10) score += 3;
        else if (materialDiff > 5) score += 1.5;

        return score;
      }

      function updateEvalBar() {
        var eval = evaluatePosition();

        // Przekształć eval na procent (sigmoid-like)
        // eval = 0 -> 50%, eval = +10 -> ~95%, eval = -10 -> ~5%
        var percentage = 50 + (eval / (Math.abs(eval) + 5)) * 45;
        percentage = Math.max(2, Math.min(98, percentage));

        var whiteBar = document.getElementById("eval-white");
        var marker = document.getElementById("eval-marker");
        var valueDisplay = document.getElementById("eval-value");

        if (whiteBar) whiteBar.style.height = percentage + "%";
        if (marker) marker.style.top = 100 - percentage + "%";

        if (valueDisplay) {
          var displayVal = eval >= 0 ? "+" + eval.toFixed(1) : eval.toFixed(1);
          valueDisplay.textContent = displayVal;
          valueDisplay.style.top = 100 - percentage + "%";
        }
      }

      // Ocena jakości ruchu
      function getMoveIcon(evalChange, capturedPiece, causedCheck, moveInfo) {
        // moveInfo = { piece, toX, toY } - opcjonalne dodatkowe info

        // Sprawdź czy ruch prowadzi do mata lub blisko mata
        var currentEval = evaluatePosition();
        var absEval = Math.abs(currentEval);

        // Jeśli eval bardzo wysoki/niski = blisko mata
        if (absEval > 30) {
          // Ktoś jest bliski mata
          if (
            (currentEval > 0 && evalChange > 0) ||
            (currentEval < 0 && evalChange < 0)
          ) {
            return "brilliant"; // Ruch przybliżający do mata
          }
        }

        // BLUNDER: Gracz ruszył inną figurą zamiast uciec figurą pod podwójnym atakiem
        // To sprawdzamy po fakcie - jeśli eval spadł drastycznie bo figura została zbita
        if (evalChange <= -8) {
          return "blunder"; // Prawdopodobnie stracił figurę przez podwójny atak
        }

        // BLUNDER: Phantom podstawiony pod bicie (nie może uciec)
        if (moveInfo && moveInfo.piece.type === "queen" && !capturedPiece) {
          var enemyColor = moveInfo.piece.color === "white" ? "black" : "white";
          if (isSquareThreatened(moveInfo.toX, moveInfo.toY, enemyColor)) {
            return "blunder"; // Phantom zginie!
          }
        }

        // Szach na króla
        if (causedCheck) {
          // Sprawdź ile pól ucieczki ma król
          var enemyColor = G.currentPlayer; // Po ruchu tura się zmieniła
          var mateProximity = evaluateMateProximity(enemyColor);

          if (mateProximity > 40) return "brilliant"; // Prawie mat!
          if (mateProximity > 15) return "brilliant";
          if (mateProximity > 5) return "great";
          return evalChange >= 2 ? "great" : "good";
        }

        // Zbicie Phantoma = natychmiastowe, bardzo dobre
        if (capturedPiece && capturedPiece.type === "queen") {
          return "brilliant";
        }

        // Zbicie cennej figury
        if (capturedPiece) {
          var pieceValues = {
            queen: 9,
            rook: 5,
            bishop: 3,
            knight: 3,
            pawn: 1,
          };
          var captureValue = pieceValues[capturedPiece.type] || 0;
          if (captureValue >= 5) return evalChange >= 1 ? "brilliant" : "great";
          if (captureValue >= 3) return evalChange >= 0 ? "great" : "good";
        }

        // Duża zmiana eval = ważny ruch
        if (evalChange >= 8) return "brilliant"; // Ogromna poprawa
        if (evalChange >= 4) return "brilliant"; // !!
        if (evalChange >= 2) return "great"; // !
        if (evalChange >= 0.5) return "good"; // ✓
        if (evalChange >= -0.5) return "book"; // neutralny
        if (evalChange >= -2) return "inaccuracy"; // ?!
        if (evalChange >= -5) return "mistake"; // ?
        return "blunder"; // ?? (stracił dużo)
      }

      function updateMoveLog(text, color) {
        // Ta funkcja jest teraz tylko wrapperem - zapis stanu robi saveGameState
      }

      function getValidNextSteps() {
        if (!G.selectedPiece) return [];
        var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
        if (!piece) return [];
        var movesUsed = G.plannedPath.length - 1;
        var movesLeft = piece.moves - movesUsed;
        if (movesLeft <= 0) return [];
        var lastPos =
          G.plannedPath.length > 0
            ? G.plannedPath[G.plannedPath.length - 1]
            : G.selectedPiece;
        var validMoves = [];
        var isLastStep = movesLeft === 1;
        var weAreLocked = isPieceLocked(G.selectedPiece.x, G.selectedPiece.y);

        for (var key in DIRECTIONS) {
          var dir = DIRECTIONS[key];
          if (piece.straightOnly && dir.diagonal) continue;
          if (piece.diagonalOnly && !dir.diagonal) continue;
          if (dir.diagonal && G.usedDiagonal) continue;

          if (piece.type === "pawn") {
            var forward = piece.color === "white" ? "n" : "s";
            var forwardDiags =
              piece.color === "white" ? ["ne", "nw"] : ["se", "sw"];
            if (key !== forward && forwardDiags.indexOf(key) === -1) continue;
            var tx = lastPos.x + dir.dx,
              ty = lastPos.y + dir.dy;
            var tp = G.board[ty] ? G.board[ty][tx] : null;
            if (weAreLocked) {
              if (forwardDiags.indexOf(key) !== -1) continue;
            } else {
              if (
                forwardDiags.indexOf(key) !== -1 &&
                (!tp || tp.color === piece.color)
              )
                continue;
            }
            if (key === forward && tp) continue;
          }

          var newX = lastPos.x + dir.dx,
            newY = lastPos.y + dir.dy;
          if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
          var targetPiece = G.board[newY][newX];
          if (targetPiece && targetPiece.color === piece.color) continue;
          if (
            G.plannedPath.some(function (p) {
              return p.x === newX && p.y === newY;
            })
          )
            continue;
          if (weAreLocked && targetPiece) continue;
          if (targetPiece && targetPiece.color !== piece.color && !isLastStep)
            continue;

          // Nie można zbić figury która aktualnie atakuje (jest w blokadzie)
          if (targetPiece && isPieceAttacking(newX, newY)) continue;

          // Sprawdź Tarczę Sentinela - nie można wejść na pola tarczy przeciwnika
          if (isBlockedByShield(newX, newY, piece.color)) continue;

          validMoves.push({ x: newX, y: newY, diagonal: dir.diagonal });
        }
        return validMoves;
      }

      function isPieceAttacking(x, y) {
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          if (
            G.pendingCaptures[i].attackerX === x &&
            G.pendingCaptures[i].attackerY === y
          ) {
            return true;
          }
        }
        return false;
      }

      // Strzałki analizy (Shift+drag)
      var analysisArrows = []; // [{fromX, fromY, toX, toY}, ...]
      var analysisArrowStart = null; // {x, y} - początek rysowanej strzałki
      var isShiftDown = false;
      var lastHoveredTile = null; // Ostatnie pole pod myszką

      // Nasłuchuj Shift
      document.addEventListener("keydown", function (e) {
        if (e.key === "Shift" && !isShiftDown) {
          isShiftDown = true;
          // Zacznij strzałkę od pola pod myszką
          if (lastHoveredTile) {
            analysisArrowStart = { x: lastHoveredTile.x, y: lastHoveredTile.y };
          }
        }
      });

      document.addEventListener("keyup", function (e) {
        if (e.key === "Shift") {
          // Zakończ strzałkę - zamień tymczasowe na stałe
          if (isShiftDown && analysisArrowStart) {
            analysisArrows = analysisArrows.map(function (a) {
              if (a.temp) {
                return {
                  fromX: a.fromX,
                  fromY: a.fromY,
                  toX: a.toX,
                  toY: a.toY,
                };
              }
              return a;
            });
            analysisArrowStart = null;
          }
          isShiftDown = false;
        }
      });

      function handleTileHover(x, y) {
        lastHoveredTile = { x: x, y: y };

        if (!isShiftDown) return;

        if (!analysisArrowStart) {
          // Początek strzałki
          analysisArrowStart = { x: x, y: y };
        } else if (analysisArrowStart.x !== x || analysisArrowStart.y !== y) {
          // Aktualizuj lub dodaj strzałkę
          // Usuń poprzednią tymczasową strzałkę z tego samego początku
          analysisArrows = analysisArrows.filter(function (a) {
            return !(
              a.fromX === analysisArrowStart.x &&
              a.fromY === analysisArrowStart.y &&
              a.temp
            );
          });
          // Dodaj nową tymczasową
          analysisArrows.push({
            fromX: analysisArrowStart.x,
            fromY: analysisArrowStart.y,
            toX: x,
            toY: y,
            temp: true,
          });
          renderAnalysisArrows();
        }
      }

      function handleTileClick(x, y, event) {
        // Jeśli Shift - nie rób nic (strzałki przez hover)
        if (event && event.shiftKey) {
          return;
        }

        // Normalny klik - usuń strzałki analizy
        if (analysisArrows.length > 0) {
          analysisArrows = [];
          analysisArrowStart = null;
          renderAnalysisArrows();
        }

        // W normalnej grze
        if (!G.gameOver && !G.analyzing) {
          handleNormalMove(x, y);
          return;
        }

        // W trybie analizy - włącz what-if jeśli nie aktywny (bez limitu ruchów)
        if (G.analyzing) {
          if (!G.whatIfMode) {
            startWhatIfMode();
          }
          handleWhatIfMove(x, y);
        }
      }

      function handleNormalMove(x, y) {
        // W trybie online sprawdź czy to twoja tura
        if (!canMakeMove()) return;

        var piece = G.board[y][x];

        // Sprawdź czy kliknięto na Strażnika (wirtualna figura)
        var guardianInfo = getGuardianAt(x, y);
        if (guardianInfo && guardianInfo.color === G.currentPlayer && !piece) {
          piece = {
            symbol: SENTINEL_GUARDIAN.symbol,
            name: SENTINEL_GUARDIAN.name,
            moves: SENTINEL_GUARDIAN.moves,
            type: "guardian",
            straightOnly: true,
            color: guardianInfo.color,
            isGuardian: true,
            shieldIndex: guardianInfo.shieldIndex,
          };
        }

        var validMoves = getValidNextSteps();

        if (!G.selectedPiece) {
          if (piece && piece.color === G.currentPlayer) {
            if (isPieceAttacking(x, y)) return;
            // Nie można ruszać zamrożoną figurą
            if (piece.frozenTurns && piece.frozenTurns > 0) return;
            G.selectedPiece = {
              x: x,
              y: y,
              isGuardian: piece.isGuardian,
              shieldIndex: piece.shieldIndex,
            };
            G.plannedPath = [{ x: x, y: y }];
            G.usedDiagonal = false;
            // Tymczasowo "postaw" strażnika na planszy żeby getValidNextSteps działało
            if (piece.isGuardian) {
              G.board[y][x] = piece;
            }
            renderBoard();
            updateUI();
          }
          return;
        }
        if (
          G.selectedPiece.x === x &&
          G.selectedPiece.y === y &&
          G.plannedPath.length === 1
        ) {
          // Usuń tymczasowego strażnika
          if (G.selectedPiece.isGuardian) {
            G.board[y][x] = null;
          }
          G.selectedPiece = null;
          G.plannedPath = [];
          G.usedDiagonal = false;
          renderBoard();
          updateUI();
          return;
        }

        var validMove = null;
        for (var i = 0; i < validMoves.length; i++) {
          if (validMoves[i].x === x && validMoves[i].y === y) {
            validMove = validMoves[i];
            break;
          }
        }

        if (validMove) {
          if (validMove.diagonal) G.usedDiagonal = true;
          G.plannedPath.push({ x: x, y: y });
          var selectedPiece = G.board[G.selectedPiece.y][G.selectedPiece.x];
          var movesUsed = G.plannedPath.length - 1;
          var targetPiece = G.board[y][x];

          if (movesUsed >= selectedPiece.moves || targetPiece) {
            executeMove();
          } else {
            renderBoard();
            updateUI();
          }
          return;
        }

        if (piece && piece.color === G.currentPlayer) {
          if (isPieceAttacking(x, y)) return;
          G.selectedPiece = { x: x, y: y };
          G.plannedPath = [{ x: x, y: y }];
          G.usedDiagonal = false;
          playSound("select");
          renderBoard();
          updateUI();
        }
      }

      function handleWhatIfMove(x, y) {
        var piece = G.board[y][x];
        var validMoves = getValidNextSteps();

        if (!G.selectedPiece) {
          if (piece && piece.color === G.currentPlayer) {
            if (isPieceAttacking(x, y)) return;
            G.selectedPiece = { x: x, y: y };
            G.plannedPath = [{ x: x, y: y }];
            G.usedDiagonal = false;
            renderBoard();
            updateUI();
          }
          return;
        }
        if (
          G.selectedPiece.x === x &&
          G.selectedPiece.y === y &&
          G.plannedPath.length === 1
        ) {
          G.selectedPiece = null;
          G.plannedPath = [];
          G.usedDiagonal = false;
          renderBoard();
          updateUI();
          return;
        }

        var validMove = null;
        for (var i = 0; i < validMoves.length; i++) {
          if (validMoves[i].x === x && validMoves[i].y === y) {
            validMove = validMoves[i];
            break;
          }
        }

        if (validMove) {
          if (validMove.diagonal) G.usedDiagonal = true;
          G.plannedPath.push({ x: x, y: y });
          var selectedPiece = G.board[G.selectedPiece.y][G.selectedPiece.x];
          var movesUsed = G.plannedPath.length - 1;
          var targetPiece = G.board[y][x];

          if (movesUsed >= selectedPiece.moves || targetPiece) {
            executeWhatIfMoveAction();
          } else {
            renderBoard();
            updateUI();
          }
          return;
        }

        if (piece && piece.color === G.currentPlayer) {
          if (isPieceAttacking(x, y)) return;
          G.selectedPiece = { x: x, y: y };
          G.plannedPath = [{ x: x, y: y }];
          G.usedDiagonal = false;
          renderBoard();
          updateUI();
        }
      }

      function executeWhatIfMoveAction() {
        if (G.plannedPath.length < 2) return;

        var startPos = G.selectedPiece;
        var endPos = G.plannedPath[G.plannedPath.length - 1];
        var piece = G.board[startPos.y][startPos.x];
        var targetPiece = G.board[endPos.y][endPos.x];

        // Usuń z blokady jeśli uciekamy
        var wasLocked = isPieceLocked(startPos.x, startPos.y);
        if (wasLocked) {
          for (var i = G.pendingCaptures.length - 1; i >= 0; i--) {
            if (
              G.pendingCaptures[i].targetX === startPos.x &&
              G.pendingCaptures[i].targetY === startPos.y
            ) {
              G.pendingCaptures.splice(i, 1);
              break;
            }
          }
        }

        G.board[startPos.y][startPos.x] = null;

        if (targetPiece && targetPiece.color !== piece.color) {
          // Blokowanie w what-if
          if (targetPiece.type === "king") {
            G.pendingCaptures.push({
              attackerX: startPos.x,
              attackerY: startPos.y,
              attackerColor: piece.color,
              attackerSymbol: piece.symbol,
              attackerPiece: JSON.parse(JSON.stringify(piece)),
              targetX: endPos.x,
              targetY: endPos.y,
              turnsLeft: 1,
              isNexusLock: true,
            });
          } else {
            G.pendingCaptures.push({
              attackerX: startPos.x,
              attackerY: startPos.y,
              attackerColor: piece.color,
              attackerSymbol: piece.symbol,
              attackerPiece: JSON.parse(JSON.stringify(piece)),
              targetX: endPos.x,
              targetY: endPos.y,
              turnsLeft: 2,
              isNexusLock: false,
            });
          }
          G.board[startPos.y][startPos.x] = piece;
        } else {
          G.board[endPos.y][endPos.x] = piece;
          // Promocja
          if (
            piece.type === "pawn" &&
            ((piece.color === "white" && endPos.y === 0) ||
              (piece.color === "black" && endPos.y === 7))
          ) {
            Object.assign(piece, PIECES.QUEEN, { color: piece.color });
          }
        }

        G.selectedPiece = null;
        G.plannedPath = [];
        G.usedDiagonal = false;

        // Prosta zmiana gracza (bez pełnej logiki processPendingCaptures)
        G.currentPlayer = G.currentPlayer === "white" ? "black" : "white";

        G.whatIfRounds++;
        updateWhatIfDisplay();

        renderBoard();
        updateUI();
      }

      function executeMove() {
        if (G.plannedPath.length < 2) return;
        if (G.analyzing) return;
        if (G.isAnimating) return;

        // Automatycznie odrzuć propozycję remisu przy ruchu
        if (G.gameMode === "online") {
          autoDeclineDrawOnMove();
        }

        // Zapisz eval przed ruchem
        G.evalBefore = evaluatePosition();

        var startPos = G.selectedPiece;
        var endPos = G.plannedPath[G.plannedPath.length - 1];
        var piece = G.board[startPos.y][startPos.x];
        var targetPiece = G.board[endPos.y][endPos.x];
        var moveColor = G.currentPlayer;

        // Wyślij ruch do przeciwnika (online)
        if (G.gameMode === "online" && peerConnection) {
          sendOnlineMove(startPos, endPos, G.plannedPath, piece.isGuardian);
        }

        // Jeśli to atak - BEZ animacji (figura zostaje na miejscu)
        if (targetPiece && targetPiece.color !== piece.color) {
          finishMove(startPos, endPos, piece, targetPiece, moveColor);
          return;
        }

        // Normalny ruch - animacja do końcowej pozycji
        animateMove(
          startPos.x,
          startPos.y,
          endPos.x,
          endPos.y,
          piece,
          function () {
            finishMove(startPos, endPos, piece, targetPiece, moveColor);
          }
        );
      }

      function finishMove(startPos, endPos, piece, targetPiece, moveColor) {
        var moveDesc = "";
        var madeAttack = false; // Czy ten ruch to atak?

        var wasLocked = isPieceLocked(startPos.x, startPos.y);
        if (wasLocked) {
          for (var i = G.pendingCaptures.length - 1; i >= 0; i--) {
            if (
              G.pendingCaptures[i].targetX === startPos.x &&
              G.pendingCaptures[i].targetY === startPos.y
            ) {
              G.pendingCaptures.splice(i, 1);
              moveDesc = piece.symbol + " uciekł!";
              break;
            }
          }
        }

        G.board[startPos.y][startPos.x] = null;

        // Strażnik - zamraża wroga na 2 tury i znika (tarcza też znika)
        if (
          piece.isGuardian &&
          targetPiece &&
          targetPiece.color !== piece.color
        ) {
          madeAttack = true;
          // Zamroź ofiarę
          if (!targetPiece.frozenTurns) targetPiece.frozenTurns = 0;
          targetPiece.frozenTurns = 2;
          moveDesc =
            moveDesc ||
            piece.symbol + " zamraża " + targetPiece.symbol + " na 2 tury!";
          // Strażnik znika - tarcza zostaje rozwiązana automatycznie bo wieże się nie zmieniły
          // Ale musimy usunąć tymczasową figurę
          G.board[startPos.y][startPos.x] = null;
        } else if (targetPiece && targetPiece.color !== piece.color) {
          madeAttack = true;
          // Ofiara Phantom - natychmiastowe zbicie (Phantom nie może uciec)
          if (targetPiece.type === "queen") {
            (targetPiece.color === "white"
              ? G.capturedByBlack
              : G.capturedByWhite
            ).push(targetPiece);
            G.board[endPos.y][endPos.x] = piece;
            // Licznik zbić
            if (!piece.kills) piece.kills = 0;
            piece.kills++;
            piece.turnsUnused = 0;
            moveDesc =
              moveDesc || piece.symbol + " zbija " + targetPiece.symbol + "!";
            playSound("capture");
          }
          // Nexus jako ofiara - 1 tura na ucieczkę
          else if (targetPiece.type === "king") {
            G.inCheck = targetPiece.color;
            G.pendingCaptures.push({
              attackerX: startPos.x,
              attackerY: startPos.y,
              attackerColor: piece.color,
              attackerSymbol: piece.symbol,
              attackerPiece: JSON.parse(JSON.stringify(piece)),
              targetX: endPos.x,
              targetY: endPos.y,
              turnsLeft: 1,
              isNexusLock: true,
            });
            G.board[startPos.y][startPos.x] = piece;
            moveDesc =
              moveDesc || piece.symbol + " blokuje " + targetPiece.symbol + "!";
            playSound("check");
          }
          // Inne figury jako ofiara - 2 tury na ucieczkę
          else {
            G.pendingCaptures.push({
              attackerX: startPos.x,
              attackerY: startPos.y,
              attackerColor: piece.color,
              attackerSymbol: piece.symbol,
              attackerPiece: JSON.parse(JSON.stringify(piece)),
              targetX: endPos.x,
              targetY: endPos.y,
              turnsLeft: 2,
              isNexusLock: false,
            });
            G.board[startPos.y][startPos.x] = piece;
            moveDesc =
              moveDesc || piece.symbol + " blokuje " + targetPiece.symbol + "!";
            playSound("capture");
          }
        } else {
          // Strażnik nie może się ruszać bez ataku - tylko zamraża
          if (piece.isGuardian) {
            // Nic nie rób - strażnik wraca na miejsce
            G.board[startPos.y][startPos.x] = null; // Usuń tymczasowego strażnika
            playSound("castle");
          } else {
            G.board[endPos.y][endPos.x] = piece;
            // Reset turnsUnused bo figura się ruszyła
            piece.turnsUnused = 0;
            moveDesc =
              moveDesc ||
              piece.symbol +
                " " +
                String.fromCharCode(97 + startPos.x) +
                (8 - startPos.y) +
                "→" +
                String.fromCharCode(97 + endPos.x) +
                (8 - endPos.y);
            if (
              piece.type === "pawn" &&
              ((piece.color === "white" && endPos.y === 0) ||
                (piece.color === "black" && endPos.y === 7))
            ) {
              Object.assign(piece, PIECES.QUEEN, { color: piece.color });
              moveDesc += " (Promocja!)";
              playSound("promote");
            } else {
              playSound("move");
            }
          }
        }

        G.selectedPiece = null;
        G.plannedPath = [];
        G.usedDiagonal = false;
        addTimeIncrement();

        // Oblicz ocenę ruchu
        var evalAfter = evaluatePosition();
        var evalChange =
          moveColor === "white"
            ? evalAfter - G.evalBefore
            : G.evalBefore - evalAfter;

        // Zapisz ostatni ruch z oceną
        var moveIcon = getMoveIcon(evalChange, targetPiece, G.inCheck, {
          piece: piece,
          toX: endPos.x,
          toY: endPos.y,
        });
        G.lastMove = {
          endX: endPos.x,
          endY: endPos.y,
          color: moveColor,
          icon: moveIcon,
        };

        // Dodaj/odejmij ELO za ruch gracza (tylko w grze z botem lub online)
        var isPlayerMove = false;
        if (G.gameMode === "bot" && moveColor === "white") {
          isPlayerMove = true;
        } else if (G.gameMode === "online" && moveColor === myColor) {
          isPlayerMove = true;
        }

        if (isPlayerMove) {
          var eloChange = calculateEloForMove(
            moveIcon,
            G.inCheck === (moveColor === "white" ? "black" : "white"),
            false
          );
          if (eloChange !== 0) {
            addElo(eloChange, moveIcon);
          }
        }

        // Zapisz stan przed processPendingCaptures
        saveGameState(moveDesc, moveColor);

        // Licznik ruchów bez ataku (dla automatycznego remisu)
        // Ruchy pionkami (Shard) nie liczą się do tego licznika
        if (madeAttack) {
          G.movesWithoutAttack = 0;
        } else if (piece.type !== "pawn") {
          // Tylko ruchy NIE-pionkami zwiększają licznik
          G.movesWithoutAttack++;

          // Remis po 10 ruchach bez ataku (nie licząc pionków)
          if (G.movesWithoutAttack >= 10 && G.pendingCaptures.length === 0) {
            endGame(null, "pat");
            return;
          }
        }
        // Ruchy pionkami nie zmieniają licznika

        processPendingCaptures();
        switchTurn();
      }

      function processPendingCaptures() {
        var newPending = [];
        var captureHappened = false;
        var captureDesc = "";
        var captureColor = "";

        // Sprawdź czy jakieś pole jest atakowane przez 2+ figury
        var attackCounts = {};
        G.pendingCaptures.forEach(function (cap) {
          var key = cap.targetX + "," + cap.targetY;
          if (!attackCounts[key]) {
            attackCounts[key] = [];
          }
          attackCounts[key].push(cap);
        });

        // Jeśli figura jest atakowana przez 2+, natychmiastowe zbicie
        for (var key in attackCounts) {
          if (attackCounts[key].length >= 2) {
            var firstAttack = attackCounts[key][0]; // Pierwszy atakujący wchodzi
            var targetPiece = G.board[firstAttack.targetY]
              ? G.board[firstAttack.targetY][firstAttack.targetX]
              : null;

            if (
              targetPiece &&
              targetPiece.color !== firstAttack.attackerColor
            ) {
              // Nexus pod podwójnym atakiem = mat
              if (targetPiece.type === "king") {
                endGame(firstAttack.attackerColor, "mat");
                return;
              }

              // Zbij figurę
              (targetPiece.color === "white"
                ? G.capturedByBlack
                : G.capturedByWhite
              ).push(targetPiece);
              G.board[firstAttack.targetY][firstAttack.targetX] =
                firstAttack.attackerPiece;

              // Licznik zbić dla atakującego
              var attackerOnBoard =
                G.board[firstAttack.targetY][firstAttack.targetX];
              if (attackerOnBoard) {
                if (!attackerOnBoard.kills) attackerOnBoard.kills = 0;
                attackerOnBoard.kills++;
                attackerOnBoard.turnsUnused = 0;
              }

              // Usuń pierwszego atakującego z jego pozycji
              if (
                G.board[firstAttack.attackerY] &&
                G.board[firstAttack.attackerY][firstAttack.attackerX] &&
                G.board[firstAttack.attackerY][firstAttack.attackerX].symbol ===
                  firstAttack.attackerSymbol
              ) {
                G.board[firstAttack.attackerY][firstAttack.attackerX] = null;
              }

              // Usuń wszystkich atakujących z tego pola z pending (ale nie pierwszego który już wszedł)
              attackCounts[key].forEach(function (cap, index) {
                if (index > 0) {
                  // Drugi i kolejni atakujący wracają na swoje pozycje (zostają w miejscu)
                }
              });

              captureHappened = true;
              captureDesc =
                "Podwójny atak! " +
                firstAttack.attackerSymbol +
                " zbija " +
                targetPiece.symbol +
                "!";
              captureColor = firstAttack.attackerColor;

              // Zapisz pozycje atakujących do podświetlenia na zielono
              G.doubleAttackPieces = [];
              attackCounts[key].forEach(function (cap, index) {
                if (index === 0) {
                  // Pierwszy atakujący wszedł na miejsce ofiary
                  G.doubleAttackPieces.push({
                    x: firstAttack.targetX,
                    y: firstAttack.targetY,
                  });
                } else {
                  // Pozostali zostali na swoich pozycjach
                  G.doubleAttackPieces.push({
                    x: cap.attackerX,
                    y: cap.attackerY,
                  });
                }
              });

              // Oznacz te ataki jako zakończone
              attackCounts[key].forEach(function (cap) {
                cap.resolved = true;
              });
            }
          }
        }

        G.pendingCaptures.forEach(function (cap) {
          // Pomiń już rozwiązane ataki
          if (cap.resolved) return;

          var targetPiece = G.board[cap.targetY]
            ? G.board[cap.targetY][cap.targetX]
            : null;

          // Ofiara uciekła - atakujący wchodzi na jej pole
          if (!targetPiece || targetPiece.color === cap.attackerColor) {
            // Przenieś atakującego na pole gdzie była ofiara
            G.board[cap.targetY][cap.targetX] = cap.attackerPiece;
            if (
              G.board[cap.attackerY] &&
              G.board[cap.attackerY][cap.attackerX] &&
              G.board[cap.attackerY][cap.attackerX].symbol ===
                cap.attackerSymbol
            ) {
              G.board[cap.attackerY][cap.attackerX] = null;
            }
            return; // Nie dodawaj do newPending
          }

          // Zmniejsz licznik tylko gdy to tura obrońcy
          if (targetPiece.color === G.currentPlayer) {
            cap.turnsLeft--;
            if (cap.turnsLeft <= 0) {
              // Czas minął - zbicie!
              if (cap.isNexusLock) {
                // Mat - Nexus nie uciekł w czasie
                endGame(cap.attackerColor, "mat");
                return;
              }
              (targetPiece.color === "white"
                ? G.capturedByBlack
                : G.capturedByWhite
              ).push(targetPiece);
              G.board[cap.targetY][cap.targetX] = cap.attackerPiece;

              // Licznik zbić dla atakującego
              var attackerOnBoard = G.board[cap.targetY][cap.targetX];
              if (attackerOnBoard) {
                if (!attackerOnBoard.kills) attackerOnBoard.kills = 0;
                attackerOnBoard.kills++;
                attackerOnBoard.turnsUnused = 0;
              }

              if (
                G.board[cap.attackerY] &&
                G.board[cap.attackerY][cap.attackerX] &&
                G.board[cap.attackerY][cap.attackerX].symbol ===
                  cap.attackerSymbol
              ) {
                G.board[cap.attackerY][cap.attackerX] = null;
              }
              captureHappened = true;
              captureDesc =
                cap.attackerSymbol + " zbija " + targetPiece.symbol + "!";
              captureColor = cap.attackerColor;
              return;
            }
          }
          newPending.push(cap);
        });
        G.pendingCaptures = newPending;
        G.inCheck = null;
        G.pendingCaptures.forEach(function (cap) {
          if (cap.isNexusLock) {
            var t = G.board[cap.targetY]
              ? G.board[cap.targetY][cap.targetX]
              : null;
            if (t && t.type === "king") G.inCheck = t.color;
          }
        });

        if (captureHappened) {
          saveGameState(captureDesc, captureColor);
        }
      }

      // Sprawdź warunek remisu "pogromcy" - figura z 3+ zbiciami nieużywana przez 4 tury
      function checkSlayerDrawCondition() {
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (
              p &&
              p.kills &&
              p.kills >= 3 &&
              p.turnsUnused &&
              p.turnsUnused >= 4
            ) {
              return true;
            }
          }
        }
        return false;
      }

      function switchTurn() {
        G.currentPlayer = G.currentPlayer === "white" ? "black" : "white";

        // Wyczyść podświetlenie podwójnego ataku
        G.doubleAttackPieces = [];

        // Sprawdź Tarcze Sentineli
        checkSentinelShields();

        // Odliczaj zamrożenie figur aktualnego gracza
        // Zwiększaj turnsUnused dla figur z 3+ zbiciami
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (p && p.color === G.currentPlayer) {
              if (p.frozenTurns && p.frozenTurns > 0) {
                p.frozenTurns--;
              }
              // Zwiększ licznik nieużywania dla figur z 3+ zbiciami
              if (p.kills && p.kills >= 3) {
                if (p.turnsUnused === undefined) p.turnsUnused = 0;
                p.turnsUnused++;
              }
            }
          }
        }

        // Sprawdź remis "pogromcy" - figura z 3+ zbiciami nieużywana przez 4 tury
        if (checkSlayerDrawCondition()) {
          endGame(null, "slayer");
          return;
        }

        // Sprawdź czy Nexus jest zablokowany i czy ma gdzie uciec
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          var cap = G.pendingCaptures[i];
          if (cap.isNexusLock) {
            var target = G.board[cap.targetY]
              ? G.board[cap.targetY][cap.targetX]
              : null;
            if (
              target &&
              target.type === "king" &&
              target.color === G.currentPlayer
            ) {
              // Nexus jest zablokowany - sprawdź czy ma bezpieczne pola do ucieczki
              var nexusMoves = getAllMovesForPiece(
                cap.targetX,
                cap.targetY,
                target,
                true
              );
              if (nexusMoves.length === 0) {
                // Brak bezpiecznych pól = mat
                endGame(G.currentPlayer === "white" ? "black" : "white", "mat");
                return;
              }
            }
          }
        }

        renderBoard();
        updateUI();
        updateEvalBar();
        if (G.gameOver) return;
        if (!hasLegalMoves(G.currentPlayer)) {
          if (G.inCheck === G.currentPlayer) {
            endGame(G.currentPlayer === "white" ? "black" : "white", "mat");
          } else {
            endGame(null, "pat");
          }
          return;
        }
        if (
          G.gameMode === "bot" &&
          G.currentPlayer === "black" &&
          !G.gameOver
        ) {
          var delay =
            G.difficulty === "easy"
              ? 1000
              : G.difficulty === "hard"
              ? 2500
              : 1500;
          setTimeout(makeBotMove, delay);
        }
      }

      function hasLegalMoves(color) {
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var piece = G.board[y][x];
            if (piece && piece.color === color) {
              // Figura która atakuje nie może się ruszać
              if (isPieceAttacking(x, y)) continue;
              // Zamrożona figura nie może się ruszać
              if (piece.frozenTurns && piece.frozenTurns > 0) continue;
              if (
                getAllMovesForPiece(x, y, piece, isPieceLocked(x, y)).length > 0
              )
                return true;
            }
          }
        }
        return false;
      }

      // Sprawdza czy pole (x,y) może być zaatakowane przez gracza enemyColor
      function isSquareThreatened(x, y, enemyColor) {
        for (var py = 0; py < 8; py++) {
          for (var px = 0; px < 8; px++) {
            var piece = G.board[py][px];
            if (!piece || piece.color !== enemyColor) continue;
            // Sprawdź czy ta figura może dotrzeć na pole (x,y)
            if (canPieceReachSquare(px, py, x, y, piece)) return true;
          }
        }
        return false;
      }

      // Sprawdza czy figura z (fromX,fromY) może dotrzeć na (toX,toY)
      function canPieceReachSquare(fromX, fromY, toX, toY, piece) {
        var visited = {};
        var queue = [{ x: fromX, y: fromY, steps: 0, usedDiag: false }];
        visited[fromX + "," + fromY] = true;

        while (queue.length > 0) {
          var current = queue.shift();
          if (current.steps >= piece.moves) continue;

          for (var key in DIRECTIONS) {
            var dir = DIRECTIONS[key];
            if (piece.straightOnly && dir.diagonal) continue;
            if (piece.diagonalOnly && !dir.diagonal) continue;
            if (dir.diagonal && current.usedDiag) continue;

            var newX = current.x + dir.dx;
            var newY = current.y + dir.dy;
            if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;

            var visitKey =
              newX + "," + newY + "," + (current.usedDiag || dir.diagonal);
            if (visited[visitKey]) continue;

            var targetPiece = G.board[newY][newX];
            // Nie może przejść przez własne figury
            if (targetPiece && targetPiece.color === piece.color) continue;

            // Czy to jest pole docelowe?
            if (newX === toX && newY === toY) return true;

            // Nie może przejść przez wrogie figury (ale może na nich skończyć)
            if (targetPiece && targetPiece.color !== piece.color) continue;

            visited[visitKey] = true;
            queue.push({
              x: newX,
              y: newY,
              steps: current.steps + 1,
              usedDiag: current.usedDiag || dir.diagonal,
            });
          }
        }
        return false;
      }

      function getAllMovesForPiece(startX, startY, piece, isLocked) {
        var allMoves = [];
        var enemyColor = piece.color === "white" ? "black" : "white";

        function explore(path, usedDiag) {
          if (path.length > piece.moves + 1) return;
          var isLastStep = path.length === piece.moves + 1;
          if (path.length > 1) {
            var last = path[path.length - 1];
            var targetPiece = G.board[last.y] ? G.board[last.y][last.x] : null;

            // Nexus nie może wchodzić na zagrożone pola
            if (piece.type === "king") {
              // Tymczasowo usuń Nexusa z planszy do sprawdzenia zagrożeń
              var originalPiece = G.board[startY][startX];
              G.board[startY][startX] = null;
              var isThreatened = isSquareThreatened(last.x, last.y, enemyColor);
              G.board[startY][startX] = originalPiece;
              if (isThreatened) return; // Nie dodawaj tego ruchu
            }

            if (isLocked) {
              if (!targetPiece) allMoves.push(path.slice());
            } else {
              if (
                !targetPiece ||
                (targetPiece.color !== piece.color && isLastStep)
              )
                allMoves.push(path.slice());
            }
          }
          if (path.length >= piece.moves + 1) return;
          var lastPos = path[path.length - 1];
          for (var key in DIRECTIONS) {
            var dir = DIRECTIONS[key];
            if (piece.straightOnly && dir.diagonal) continue;
            if (piece.diagonalOnly && !dir.diagonal) continue;
            if (dir.diagonal && usedDiag) continue;
            if (piece.type === "pawn") {
              var forward = piece.color === "white" ? "n" : "s";
              var forwardDiags =
                piece.color === "white" ? ["ne", "nw"] : ["se", "sw"];
              if (key !== forward && forwardDiags.indexOf(key) === -1) continue;
              var tx = lastPos.x + dir.dx,
                ty = lastPos.y + dir.dy;
              var tp = G.board[ty] ? G.board[ty][tx] : null;
              if (isLocked) {
                if (forwardDiags.indexOf(key) !== -1) continue;
              } else {
                if (
                  forwardDiags.indexOf(key) !== -1 &&
                  (!tp || tp.color === piece.color)
                )
                  continue;
              }
              if (key === forward && tp) continue;
            }
            var newX = lastPos.x + dir.dx,
              newY = lastPos.y + dir.dy;
            if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
            var targetPiece = G.board[newY][newX];
            if (targetPiece && targetPiece.color === piece.color) continue;
            var inPath = false;
            for (var i = 0; i < path.length; i++) {
              if (path[i].x === newX && path[i].y === newY) {
                inPath = true;
                break;
              }
            }
            if (inPath) continue;
            if (isLocked && targetPiece) continue;

            // Sprawdź Tarczę Sentinela - nie można wejść na pola tarczy przeciwnika
            if (isBlockedByShield(newX, newY, piece.color)) continue;

            // Jeśli na polu jest wroga figura - można tam wejść tylko jako ostatni krok
            // NIE można przechodzić przez wrogie figury
            var stepsUsed = path.length; // path zawiera start, więc stepsUsed = ile kroków zrobiliśmy
            var isThisLastStep = stepsUsed >= piece.moves;
            if (targetPiece && targetPiece.color !== piece.color) {
              // Nie można zbić figury która atakuje
              if (isPieceAttacking(newX, newY)) continue;
              // Można zbić tylko w ostatnim kroku
              if (isThisLastStep) {
                var newPath = path.slice();
                newPath.push({ x: newX, y: newY });
                allMoves.push(newPath);
              }
              // Nie można iść dalej przez wroga
              continue;
            }

            var newPath = path.slice();
            newPath.push({ x: newX, y: newY });
            explore(newPath, usedDiag || dir.diagonal);
          }
        }
        explore([{ x: startX, y: startY }], false);
        return allMoves;
      }

      function endGame(winner, type) {
        G.gameOver = true;
        if (G.timerInterval) clearInterval(G.timerInterval);
        updateTimerDisplay();

        // ELO za wynik gry
        var playerWon = false;
        var playerLost = false;

        if (G.gameMode === "bot") {
          playerWon = winner === "white";
          playerLost = winner === "black";
        } else if (G.gameMode === "online") {
          playerWon = winner === myColor;
          playerLost = winner !== myColor && type !== "pat";
        }

        if (playerWon) {
          var winBonus = type === "mat" ? 100 : 60; // Mat daje więcej
          if (G.gameMode === "bot") {
            // Mat dzieli się zależnie od trudności bota
            if (G.difficulty === "easy") winBonus = Math.floor(winBonus / 3);
            else if (G.difficulty === "medium")
              winBonus = Math.floor(winBonus / 2);
            // Hard = pełna nagroda
          }
          // Online = pełna nagroda (bez dzielenia)
          addElo(winBonus, type === "mat" ? "Mat!" : "Wygrana!");
        } else if (playerLost) {
          var lossPenalty = -30; // Bazowa kara
          if (G.gameMode === "bot") {
            // Łatwy bot = większa kara (wstyd przegrać z łatwym!)
            if (G.difficulty === "easy") lossPenalty = -50;
            else if (G.difficulty === "medium") lossPenalty = -30;
            else if (G.difficulty === "hard") lossPenalty = -15; // Trudny = mniejsza kara
          }
          // Online = standardowa kara
          addElo(lossPenalty, "Przegrana");
        }

        // Remis = +30 ELO dla każdego
        if (
          (type === "pat" || type === "slayer") &&
          (G.gameMode === "bot" || G.gameMode === "online")
        ) {
          addElo(30, "Remis");
        }

        var title, message;
        if (type === "mat") {
          title = "SZACH MAT!";
          message = (winner === "white" ? "Białe" : "Czarne") + " wygrywają!";
        } else if (type === "czas") {
          title = "KONIEC CZASU!";
          message = (winner === "white" ? "Białe" : "Czarne") + " wygrywają!";
        } else if (type === "poddanie") {
          title = "PODDANIE!";
          message = (winner === "white" ? "Białe" : "Czarne") + " wygrywają!";
        } else if (type === "slayer") {
          title = "REMIS!";
          message = "Pogromca nieaktywny przez 4 tury!";
        } else {
          title = "REMIS!";
          message =
            G.movesWithoutAttack >= 10
              ? "10 ruchów bez ataku!"
              : "Gracze zgodzili się na remis";
        }

        document.getElementById("modal-title").textContent = title;
        document.getElementById("modal-message").textContent = message;
        document.getElementById("game-over-modal").classList.add("active");
        playSound("gameEnd");
      }

      function makeBotMove() {
        if (G.gameOver) return;

        // Czas namysłu zależny od trudności
        var thinkTime =
          G.difficulty === "easy" ? 800 : G.difficulty === "hard" ? 2500 : 1500;

        // Sprawdź czy Nexus jest zagrożony - PRIORYTET
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          var cap = G.pendingCaptures[i];
          if (cap.isNexusLock) {
            var target = G.board[cap.targetY]
              ? G.board[cap.targetY][cap.targetX]
              : null;
            if (target && target.type === "king" && target.color === "black") {
              var nexusMoves = getAllMovesForPiece(
                cap.targetX,
                cap.targetY,
                target,
                true
              );
              if (nexusMoves.length > 0) {
                // Wybierz najbezpieczniejsze pole
                var bestMove = selectSafestMove(
                  nexusMoves,
                  cap.targetX,
                  cap.targetY
                );
                G.selectedPiece = { x: cap.targetX, y: cap.targetY };
                G.plannedPath = bestMove;
                executeMove();
                return;
              }
            }
          }
        }

        // Uciekaj zablokowanymi figurami
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          var cap = G.pendingCaptures[i];
          if (!cap.isNexusLock) {
            var target = G.board[cap.targetY]
              ? G.board[cap.targetY][cap.targetX]
              : null;
            if (target && target.color === "black") {
              var escapeMoves = getAllMovesForPiece(
                cap.targetX,
                cap.targetY,
                target,
                true
              );
              if (escapeMoves.length > 0) {
                var bestMove = selectSafestMove(
                  escapeMoves,
                  cap.targetX,
                  cap.targetY
                );
                G.selectedPiece = { x: cap.targetX, y: cap.targetY };
                G.plannedPath = bestMove;
                executeMove();
                return;
              }
            }
          }
        }

        var allMoves = [];

        // Zbierz ruchy Strażników (czarnych tarcz)
        for (var s = 0; s < G.sentinelShields.length; s++) {
          var shield = G.sentinelShields[s];
          if (shield.color === "black") {
            var guardianPiece = {
              symbol: SENTINEL_GUARDIAN.symbol,
              name: SENTINEL_GUARDIAN.name,
              moves: SENTINEL_GUARDIAN.moves,
              type: "guardian",
              straightOnly: true,
              color: "black",
              isGuardian: true,
              shieldIndex: s,
            };
            var gx = shield.guardianX,
              gy = shield.guardianY;
            if (!G.board[gy][gx]) {
              G.board[gy][gx] = guardianPiece;
              var guardianMoves = getAllMovesForPiece(
                gx,
                gy,
                guardianPiece,
                false
              );
              G.board[gy][gx] = null;

              for (var m = 0; m < guardianMoves.length; m++) {
                var path = guardianMoves[m];
                if (path.length > 1) {
                  var endPos = path[path.length - 1];
                  var target = G.board[endPos.y][endPos.x];
                  if (target && target.color === "white") {
                    var score = evaluateMoveDeep(
                      gx,
                      gy,
                      endPos.x,
                      endPos.y,
                      guardianPiece,
                      target
                    );
                    allMoves.push({
                      from: { x: gx, y: gy, isGuardian: true, shieldIndex: s },
                      path: path,
                      piece: guardianPiece,
                      score: score,
                    });
                  }
                }
              }
            }
          }
        }

        // Zbierz ruchy normalnych figur
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var piece = G.board[y][x];
            if (piece && piece.color === "black") {
              if (isPieceAttacking(x, y)) continue;
              if (piece.frozenTurns && piece.frozenTurns > 0) continue;

              var moves = getAllMovesForPiece(x, y, piece, isPieceLocked(x, y));
              for (var m = 0; m < moves.length; m++) {
                var path = moves[m];
                if (path.length > 1) {
                  var endPos = path[path.length - 1];
                  var target = G.board[endPos.y][endPos.x];
                  var score = evaluateMoveDeep(
                    x,
                    y,
                    endPos.x,
                    endPos.y,
                    piece,
                    target
                  );
                  allMoves.push({
                    from: { x: x, y: y },
                    path: path,
                    piece: piece,
                    score: score,
                  });
                }
              }
            }
          }
        }

        if (allMoves.length === 0) return;

        // Sortuj i wybierz ruch zależnie od trudności
        allMoves.sort(function (a, b) {
          return b.score - a.score;
        });

        var selectedMove;
        if (G.difficulty === "hard") {
          // Na trudnym - zawsze najlepszy ruch lub jeden z top 2
          selectedMove =
            allMoves[Math.floor(Math.random() * Math.min(2, allMoves.length))];
        } else if (G.difficulty === "easy") {
          // Na łatwym - losowy z górnej połowy
          var poolSize = Math.max(3, Math.floor(allMoves.length / 2));
          selectedMove =
            allMoves[
              Math.floor(Math.random() * Math.min(poolSize, allMoves.length))
            ];
        } else {
          // Średni - top 5
          selectedMove =
            allMoves[Math.floor(Math.random() * Math.min(5, allMoves.length))];
        }

        G.selectedPiece = selectedMove.from;
        G.plannedPath = selectedMove.path;

        if (selectedMove.from.isGuardian) {
          G.board[selectedMove.from.y][selectedMove.from.x] =
            selectedMove.piece;
        }

        for (var j = 1; j < selectedMove.path.length; j++) {
          var prev = selectedMove.path[j - 1],
            curr = selectedMove.path[j];
          if (
            Math.abs(curr.x - prev.x) === 1 &&
            Math.abs(curr.y - prev.y) === 1
          ) {
            G.usedDiagonal = true;
            break;
          }
        }
        executeMove();
      }

      // Wybierz najbezpieczniejszy ruch ucieczki
      function selectSafestMove(moves, fromX, fromY) {
        var bestMove = moves[0];
        var bestSafety = -Infinity;

        for (var i = 0; i < moves.length; i++) {
          var path = moves[i];
          var endPos = path[path.length - 1];
          var safety = 0;

          // Czy pole jest zagrożone?
          if (!isSquareThreatened(endPos.x, endPos.y, "white")) {
            safety += 100;
          }

          // Odległość od centrum (centrum = bezpieczniej dla króla? nie zawsze)
          safety += (3.5 - Math.abs(endPos.x - 3.5)) * 2;

          // Czy jest blisko własnych figur (ochrona)?
          for (var dy = -1; dy <= 1; dy++) {
            for (var dx = -1; dx <= 1; dx++) {
              var nx = endPos.x + dx,
                ny = endPos.y + dy;
              if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                var p = G.board[ny][nx];
                if (p && p.color === "black" && p.type !== "king") {
                  safety += 5;
                }
              }
            }
          }

          if (safety > bestSafety) {
            bestSafety = safety;
            bestMove = path;
          }
        }
        return bestMove;
      }

      // Głęboka ocena ruchu
      function evaluateMoveDeep(fromX, fromY, toX, toY, piece, targetPiece) {
        var score = 0;
        var pieceValues = {
          king: 10000,
          queen: 900,
          rook: 500,
          bishop: 320,
          knight: 300,
          pawn: 100,
          guardian: 400,
        };

        // 1. Wartość zbicia
        if (targetPiece) {
          score += pieceValues[targetPiece.type] || 100;
          // Bonus za zbicie Phantoma (nie może uciec)
          if (targetPiece.type === "queen") score += 200;
          // Ogromny bonus za atak na króla
          if (targetPiece.type === "king") score += 5000;
        }

        // 2. Symuluj ruch i oceń pozycję
        var originalTarget = G.board[toY][toX];
        var originalFrom = G.board[fromY][fromX];
        G.board[toY][toX] = piece;
        G.board[fromY][fromX] = null;

        var positionScore = evaluatePositionDeep("black");

        // Przywróć
        G.board[fromY][fromX] = originalFrom;
        G.board[toY][toX] = originalTarget;

        score += positionScore * 0.5;

        // 3. Kontrola centrum
        var centerDist = Math.abs(toX - 3.5) + Math.abs(toY - 3.5);
        score += (7 - centerDist) * 15;

        // 4. Bezpieczeństwo figury po ruchu
        if (isSquareThreatened(toX, toY, "white")) {
          score -= pieceValues[piece.type] * 0.3; // Kara za wejście na zagrożone pole
        }

        // 5. Rozwój figur (wyprowadzanie z pierwszej linii)
        if (fromY === 7 && toY < 7) {
          score += 20; // Bonus za rozwój
        }

        // 6. Pionki - bonus za awans
        if (piece.type === "pawn") {
          score += toY * 25; // Im bliżej promocji tym lepiej
          if (toY >= 5) score += 50; // Dodatkowy bonus za zaawansowane pionki
        }

        // 7. Tworzenie tarczy (wieże)
        if (piece.type === "rook") {
          score += getBotShieldBonus(fromX, fromY, toX, toY) * 2;
        }

        // 8. Atakowanie wielu figur naraz
        var attackCount = countThreatenedEnemies(toX, toY, piece);
        score += attackCount * 30;

        // 9. Ochrona własnego króla
        var kingPos = findKing("black");
        if (kingPos) {
          var distToKing =
            Math.abs(toX - kingPos.x) + Math.abs(toY - kingPos.y);
          if (distToKing <= 2) score += 25; // Bonus za bycie blisko króla
        }

        // 10. KARA za podstawienie pod podwójny atak (natychmiastowe zbicie!)
        if (!targetPiece) {
          // Tylko jeśli to nie jest zbicie
          var attacksOnSquare = countAttacksOnSquare(toX, toY, "white");
          if (attacksOnSquare >= 2) {
            // Podwójny atak = natychmiastowa strata figury!
            score -= pieceValues[piece.type] * 2;
          } else if (
            attacksOnSquare === 1 &&
            isSquareThreatened(toX, toY, "white")
          ) {
            // Pojedynczy atak - figura może uciec, ale i tak kara
            score -= pieceValues[piece.type] * 0.3;
          }
        }

        // 11. OGROMNA KARA za podstawienie Phantoma pod bicie
        if (piece.type === "queen" && isSquareThreatened(toX, toY, "white")) {
          // Phantom nie może uciec! To prawie pewna strata
          score -= pieceValues[piece.type] * 1.5;
        }

        // 12. Kara za zostawienie ważnej figury bez obrony
        // Sprawdź czy po ruchu jakaś nasza figura zostaje bez obrony pod atakiem
        var originalTarget = G.board[toY][toX];
        var originalFrom = G.board[fromY][fromX];
        G.board[toY][toX] = piece;
        G.board[fromY][fromX] = null;

        for (var cy = 0; cy < 8; cy++) {
          for (var cx = 0; cx < 8; cx++) {
            var checkPiece = G.board[cy][cx];
            if (
              checkPiece &&
              checkPiece.color === "black" &&
              checkPiece.type !== "king"
            ) {
              if (isSquareThreatened(cx, cy, "white")) {
                // Czy ta figura jest broniona?
                var defended = isSquareDefended(cx, cy, "black");
                if (!defended) {
                  score -= pieceValues[checkPiece.type] * 0.5;
                }
              }
            }
          }
        }

        // Przywróć
        G.board[fromY][fromX] = originalFrom;
        G.board[toY][toX] = originalTarget;

        // 13. Losowość dla trudności
        if (G.difficulty === "easy") {
          score += Math.random() * 100;
        } else if (G.difficulty === "medium") {
          score += Math.random() * 30;
        } else {
          score += Math.random() * 10;
        }

        return score;
      }

      // Policz ile ataków jest na dane pole
      function countAttacksOnSquare(x, y, byColor) {
        var count = 0;

        // Sprawdź pending captures
        for (var i = 0; i < G.pendingCaptures.length; i++) {
          var cap = G.pendingCaptures[i];
          if (
            cap.targetX === x &&
            cap.targetY === y &&
            cap.attackerColor === byColor
          ) {
            count++;
          }
        }

        // Sprawdź czy figury mogą zaatakować to pole
        for (var py = 0; py < 8; py++) {
          for (var px = 0; px < 8; px++) {
            var p = G.board[py][px];
            if (p && p.color === byColor) {
              var moves = getAllMovesForPiece(px, py, p, false);
              for (var m = 0; m < moves.length; m++) {
                var path = moves[m];
                if (path.length > 1) {
                  var endPos = path[path.length - 1];
                  if (endPos.x === x && endPos.y === y) {
                    count++;
                    break; // Jedna figura = jeden atak
                  }
                }
              }
            }
          }
        }

        return count;
      }

      // Czy pole jest bronione przez dany kolor
      function isSquareDefended(x, y, byColor) {
        for (var py = 0; py < 8; py++) {
          for (var px = 0; px < 8; px++) {
            var p = G.board[py][px];
            if (p && p.color === byColor && !(px === x && py === y)) {
              // Sprawdź czy ta figura może "zbić" na tym polu (czyli bronić)
              var moves = getAllMovesForPiece(px, py, p, false);
              for (var m = 0; m < moves.length; m++) {
                var path = moves[m];
                if (path.length > 1) {
                  var endPos = path[path.length - 1];
                  if (endPos.x === x && endPos.y === y) {
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      }

      // Znajdź króla
      function findKing(color) {
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (p && p.type === "king" && p.color === color) {
              return { x: x, y: y };
            }
          }
        }
        return null;
      }

      // Policz ile wrogich figur zagrożonych z danego pola
      function countThreatenedEnemies(x, y, piece) {
        var count = 0;
        var directions = [];

        if (piece.straightOnly) {
          directions = ["n", "s", "e", "w"];
        } else if (piece.diagonalOnly) {
          directions = ["ne", "nw", "se", "sw"];
        } else {
          directions = ["n", "s", "e", "w", "ne", "nw", "se", "sw"];
        }

        directions.forEach(function (key) {
          var dir = DIRECTIONS[key];
          for (var step = 1; step <= piece.moves; step++) {
            var nx = x + dir.dx * step;
            var ny = y + dir.dy * step;
            if (nx < 0 || nx > 7 || ny < 0 || ny > 7) break;
            var target = G.board[ny][nx];
            if (target) {
              if (target.color === "white") count++;
              break;
            }
          }
        });

        return count;
      }

      // Głęboka ocena pozycji
      function evaluatePositionDeep(forColor) {
        var pieceValues = {
          king: 10000,
          queen: 900,
          rook: 500,
          bishop: 320,
          knight: 300,
          pawn: 100,
        };
        var score = 0;

        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var piece = G.board[y][x];
            if (!piece) continue;

            var value = pieceValues[piece.type] || 0;

            // Pozycja - centrum lepsze
            var centerBonus =
              (3.5 - Math.abs(x - 3.5)) * 5 + (3.5 - Math.abs(y - 3.5)) * 5;
            value += centerBonus;

            // Pionki - awans
            if (piece.type === "pawn") {
              if (piece.color === "white") {
                value += (7 - y) * 15;
              } else {
                value += y * 15;
              }
            }

            // Mobilność - ile ruchów ma figura
            var moves = getAllMovesForPiece(x, y, piece, false);
            value += moves.length * 3;

            // Bezpieczeństwo
            var enemyColor = piece.color === "white" ? "black" : "white";
            if (isSquareThreatened(x, y, enemyColor)) {
              value -= pieceValues[piece.type] * 0.1;
            }

            if (piece.color === forColor) {
              score += value;
            } else {
              score -= value;
            }
          }
        }

        // Sprawdź szachy
        if (G.inCheck === "white" && forColor === "black") score += 200;
        if (G.inCheck === "black" && forColor === "white") score += 200;

        return score;
      }

      // Bonus dla bota za ustawianie wież w linii (tworzenie tarczy)
      function getBotShieldBonus(fromX, fromY, toX, toY) {
        var bonus = 0;
        // Znajdź inne czarne wieże
        for (var y = 0; y < 8; y++) {
          for (var x = 0; x < 8; x++) {
            var p = G.board[y][x];
            if (
              p &&
              p.type === "rook" &&
              p.color === "black" &&
              !(x === fromX && y === fromY)
            ) {
              // Czy po ruchu będą w jednej linii?
              if (toX === x || toY === y) {
                // Sprawdź czy między nimi nie będzie figur
                var clear = true;
                if (toX === x) {
                  var minY = Math.min(toY, y),
                    maxY = Math.max(toY, y);
                  for (var cy = minY + 1; cy < maxY; cy++) {
                    if (G.board[cy][x] && !(cy === fromY && x === fromX))
                      clear = false;
                  }
                } else {
                  var minX = Math.min(toX, x),
                    maxX = Math.max(toX, x);
                  for (var cx = minX + 1; cx < maxX; cx++) {
                    if (G.board[toY][cx] && !(toY === fromY && cx === fromX))
                      clear = false;
                  }
                }
                if (clear) bonus += 25; // Bonus za tworzenie tarczy
              }
            }
          }
        }
        return bonus;
      }

      document.querySelectorAll(".nav-btn").forEach(function (btn) {
        btn.addEventListener("click", function () {
          document.querySelectorAll(".nav-btn").forEach(function (b) {
            b.classList.remove("active");
          });
          document.querySelectorAll(".screen").forEach(function (s) {
            s.classList.remove("active");
          });
          btn.classList.add("active");
          document
            .getElementById(btn.dataset.screen + "-screen")
            .classList.add("active");
        });
      });
      document.querySelectorAll(".mode-card").forEach(function (card) {
        card.addEventListener("click", function () {
          if (card.dataset.mode === "online") {
            createLobby();
            return;
          }
          G.gameMode = card.dataset.mode;
          document.getElementById("time-select").style.display = "block";
          if (card.dataset.mode === "bot") {
            document.getElementById("difficulty-select").style.display =
              "block";
          } else {
            document.getElementById("difficulty-select").style.display = "none";
          }
        });
      });
      document.querySelectorAll(".diff-btn").forEach(function (btn) {
        btn.addEventListener("click", function () {
          document.querySelectorAll(".diff-btn").forEach(function (b) {
            b.classList.remove("selected");
          });
          btn.classList.add("selected");
          G.difficulty = btn.dataset.diff;
        });
      });
      // Menu time buttons (nie lobby)
      document
        .querySelectorAll("#time-select .time-btn")
        .forEach(function (btn) {
          btn.addEventListener("click", function () {
            document
              .querySelectorAll("#time-select .time-btn")
              .forEach(function (b) {
                b.classList.remove("selected");
              });
            btn.classList.add("selected");
            G.timeLimit = parseInt(btn.dataset.time);
            if (G.timeLimit > 0) {
              document.getElementById("increment-select").style.display =
                "block";
            } else {
              document.getElementById("increment-select").style.display =
                "none";
              G.increment = 0;
              startGame();
            }
          });
        });
      document
        .querySelectorAll("#increment-select .inc-btn")
        .forEach(function (btn) {
          btn.addEventListener("click", function () {
            document
              .querySelectorAll("#increment-select .inc-btn")
              .forEach(function (b) {
                b.classList.remove("selected");
              });
            btn.classList.add("selected");
            G.increment = parseInt(btn.dataset.inc);
            startGame();
          });
        });
      // Lobby time buttons
      document.querySelectorAll(".lobby-time-btn").forEach(function (btn) {
        btn.addEventListener("click", function () {
          document.querySelectorAll(".lobby-time-btn").forEach(function (b) {
            b.classList.remove("selected");
          });
          btn.classList.add("selected");
          lobbyTimeLimit = parseInt(btn.dataset.time);
          var incSection = document.getElementById("lobby-increment");
          if (lobbyTimeLimit > 0) {
            incSection.style.display = "block";
          } else {
            incSection.style.display = "none";
            lobbyIncrement = 0;
          }
        });
      });
      document.querySelectorAll(".lobby-inc-btn").forEach(function (btn) {
        btn.addEventListener("click", function () {
          document.querySelectorAll(".lobby-inc-btn").forEach(function (b) {
            b.classList.remove("selected");
          });
          btn.classList.add("selected");
          lobbyIncrement = parseInt(btn.dataset.inc);
        });
      });
      document
        .getElementById("new-game-btn")
        .addEventListener("click", function () {
          document.getElementById("game-over-modal").classList.remove("active");
          if (G.timerInterval) clearInterval(G.timerInterval);
          document.querySelectorAll(".nav-btn").forEach(function (b) {
            b.classList.remove("active");
          });
          document.querySelectorAll(".screen").forEach(function (s) {
            s.classList.remove("active");
          });
          document
            .querySelector('[data-screen="menu"]')
            .classList.add("active");
          document.getElementById("menu-screen").classList.add("active");
          // Ukryj info o przeciwniku
          document.getElementById("opponent-info").style.display = "none";
          // Reset menu selections
          document.getElementById("difficulty-select").style.display = "none";
          document.getElementById("time-select").style.display = "none";
          document.getElementById("increment-select").style.display = "none";
          document
            .querySelectorAll(".diff-btn, .time-btn, .inc-btn")
            .forEach(function (b) {
              b.classList.remove("selected");
            });
        });
      document
        .getElementById("show-zones")
        .addEventListener("change", function () {
          G.showZones = this.checked;
          renderBoard();
        });
      document
        .getElementById("show-eval")
        .addEventListener("change", function () {
          G.showEval = this.checked;
          var evalBar = document.getElementById("eval-bar");
          if (evalBar) {
            evalBar.style.display = this.checked ? "block" : "none";
          }
        });
      document
        .getElementById("btn-first")
        .addEventListener("click", function () {
          loadGameState(0);
        });
      document
        .getElementById("btn-prev")
        .addEventListener("click", function () {
          navigateState(-1);
        });
      document
        .getElementById("btn-next")
        .addEventListener("click", function () {
          navigateState(1);
        });
      document
        .getElementById("btn-last")
        .addEventListener("click", function () {
          loadGameState(G.gameStates.length - 1);
        });
      document
        .getElementById("btn-reset-whatif")
        .addEventListener("click", function () {
          resetWhatIfMode();
        });

      // Przyciski remisu/poddania
      document
        .getElementById("btn-offer-draw")
        .addEventListener("click", offerDraw);
      document
        .getElementById("btn-resign")
        .addEventListener("click", resignGame);
      document
        .getElementById("draw-accept")
        .addEventListener("click", acceptDraw);
      document
        .getElementById("draw-decline")
        .addEventListener("click", declineDraw);

      function startGame() {
        document.querySelectorAll(".nav-btn").forEach(function (b) {
          b.classList.remove("active");
        });
        document.querySelectorAll(".screen").forEach(function (s) {
          s.classList.remove("active");
        });
        document.querySelector('[data-screen="game"]').classList.add("active");
        document.getElementById("game-screen").classList.add("active");
        resetGame();
      }

      // Inicjalizacja
      initProfile();
      checkLobbyUrl();
      initBoard();
      renderBoard();
      updateUI();
      updateEvalBar();
    </script>
  </body>
</html>

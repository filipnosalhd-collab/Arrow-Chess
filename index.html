<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strza≈Çkowe Szachy ULTRA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Exo+2:wght@300;400;500;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-dark: #030308; --bg-medium: #0a0a18; --bg-light: #12122a;
            --accent-cyan: #00f5ff; --accent-magenta: #ff00ff; --accent-gold: #ffd700;
            --neon-green: #00ff88; --neon-orange: #ff6b35; --neon-purple: #a855f7;
            --text-primary: #f0f0ff; --text-secondary: #9999cc; --white-piece: #f0f5ff;
            --black-piece: #1a1a2e;
            --tile-light: #e8dcc8; --tile-dark: #8b6914;
            --highlight: rgba(0, 245, 255, 0.5); --threat: rgba(255, 0, 100, 0.5);
            --valid-move: rgba(0, 255, 136, 0.4);
            --zone-center: rgba(255, 215, 0, 0.4);
            --zone-nexus-white: rgba(0, 150, 255, 0.35);
            --zone-phantom-white: rgba(0, 255, 150, 0.35);
            --zone-nexus-black: rgba(255, 100, 100, 0.35);
            --zone-phantom-black: rgba(255, 150, 0, 0.35);
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Exo 2', 'Rajdhani', sans-serif; background: var(--bg-dark); color: var(--text-primary); }
        .bg-pattern { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 0; overflow: hidden;
        }
        .bg-pattern::before {
            content: '';
            position: absolute;
            width: 250%; height: 250%;
            top: -75%; left: -75%;
            background: 
                radial-gradient(ellipse at 15% 25%, rgba(0, 245, 255, 0.15) 0%, transparent 45%),
                radial-gradient(ellipse at 85% 75%, rgba(255, 0, 255, 0.12) 0%, transparent 45%),
                radial-gradient(ellipse at 50% 50%, rgba(167, 139, 250, 0.08) 0%, transparent 55%),
                radial-gradient(ellipse at 20% 80%, rgba(0, 255, 136, 0.1) 0%, transparent 40%);
            animation: cosmicRotate 90s linear infinite;
        }
        .bg-pattern::after {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            background-image: 
                radial-gradient(2px 2px at 15px 25px, rgba(255,255,255,0.5), transparent),
                radial-gradient(2px 2px at 55px 85px, rgba(255,255,255,0.4), transparent),
                radial-gradient(1px 1px at 95px 35px, rgba(255,255,255,0.6), transparent),
                radial-gradient(2px 2px at 145px 95px, rgba(255,255,255,0.3), transparent),
                radial-gradient(1px 1px at 185px 145px, rgba(255,255,255,0.5), transparent),
                radial-gradient(2px 2px at 235px 55px, rgba(0, 245, 255, 0.7), transparent),
                radial-gradient(1px 1px at 275px 125px, rgba(255, 0, 255, 0.6), transparent);
            background-repeat: repeat;
            background-size: 300px 200px;
            animation: starsFloat 100s linear infinite;
            opacity: 0.85;
        }
        @keyframes cosmicRotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes starsFloat { from { transform: translateY(0); } to { transform: translateY(-200px); } }
        .container { position: relative; z-index: 1; height: 100vh; display: flex; flex-direction: column; padding: 15px; overflow: hidden; max-width: 1600px; margin: 0 auto; }
        header { text-align: center; padding: 15px 0; flex-shrink: 0; }
        h1 { 
            font-family: 'Orbitron', monospace; 
            font-size: 2.6rem; 
            font-weight: 900; 
            letter-spacing: 6px; 
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta)); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            text-transform: uppercase;
            filter: drop-shadow(0 0 25px rgba(0, 245, 255, 0.6));
            animation: titlePulse 4s infinite ease-in-out;
            position: relative;
            display: inline-block;
        }
        h1::after {
            content: 'ULTRA';
            position: absolute;
            top: -12px;
            right: -55px;
            font-size: 0.55rem;
            background: linear-gradient(135deg, var(--accent-gold), #ff9500);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
            animation: ultraBadge 2s infinite ease-in-out;
        }
        @keyframes titlePulse {
            0%, 100% { filter: drop-shadow(0 0 25px rgba(0, 245, 255, 0.6)); }
            50% { filter: drop-shadow(0 0 50px rgba(0, 245, 255, 0.9)) drop-shadow(0 0 80px rgba(255, 0, 255, 0.5)); }
        }
        @keyframes ultraBadge {
            0%, 100% { transform: scale(1) rotate(-5deg); }
            50% { transform: scale(1.15) rotate(5deg); }
        }
        .subtitle { font-size: 1rem; color: var(--text-secondary); letter-spacing: 3px; text-transform: uppercase; margin-top: 5px; }
        nav { display: flex; justify-content: center; gap: 14px; flex-wrap: wrap; padding: 10px 0; flex-shrink: 0; }
        .nav-btn { 
            font-family: 'Orbitron', monospace; 
            padding: 12px 28px; 
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            color: var(--accent-cyan); 
            font-size: 0.88rem; 
            font-weight: 600; 
            letter-spacing: 2px; 
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
        }
        .nav-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }
        .nav-btn:hover::before { left: 100%; }
        .nav-btn:hover, .nav-btn.active { 
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2), rgba(255, 0, 255, 0.2));
            border-color: var(--accent-cyan);
            color: #fff;
            transform: translateY(-4px);
            box-shadow: 0 15px 40px rgba(0, 245, 255, 0.3), 0 0 50px rgba(0, 245, 255, 0.15);
        }
        .screen { display: none; flex: 1; overflow: hidden; }
        .screen.active { display: flex; flex-direction: column; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .menu-screen { text-align: center; justify-content: center; align-items: center; padding: 20px; overflow-y: auto; }
        .menu-title { font-family: 'Orbitron', monospace; font-size: 1.5rem; margin-bottom: 25px; color: var(--accent-gold); }
        .game-modes { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-bottom: 30px; }
        .mode-card { 
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 28px; 
            width: 270px;
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }
        .mode-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 4px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s ease;
        }
        .mode-card:hover::before { transform: scaleX(1); }
        .mode-card:hover { 
            border-color: var(--accent-cyan);
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 25px 60px rgba(0, 245, 255, 0.2), 0 0 80px rgba(0, 245, 255, 0.1);
        }
        .mode-icon { 
            font-size: 3.2rem; 
            margin-bottom: 14px;
            filter: drop-shadow(0 0 20px currentColor);
            transition: transform 0.4s ease;
        }
        .mode-card:hover .mode-icon { transform: scale(1.15) rotate(5deg); }
        .mode-name { font-family: 'Orbitron', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 8px; }
        .mode-desc { font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4; }
        .difficulty-select { margin-top: 25px; }
        .difficulty-select h3 { font-family: 'Orbitron', monospace; font-size: 1.1rem; margin-bottom: 15px; color: var(--text-secondary); }
        .difficulty-btns { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        .diff-btn { padding: 12px 28px; background: var(--bg-light); border: 2px solid transparent; color: var(--text-primary); font-family: 'Rajdhani', sans-serif; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .diff-btn.easy { border-color: #00ff88; color: #00ff88; }
        .diff-btn.medium { border-color: var(--accent-gold); color: var(--accent-gold); }
        .diff-btn.hard { border-color: var(--accent-magenta); color: var(--accent-magenta); }
        .diff-btn.selected { background: currentColor; color: var(--bg-dark); }
        .time-select, .increment-select { margin-top: 20px; }
        .time-select h3, .increment-select h4 { font-family: 'Orbitron', monospace; font-size: 1rem; margin-bottom: 12px; color: var(--text-secondary); }
        .time-btns, .increment-btns { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .time-btn, .inc-btn { padding: 10px 18px; background: var(--bg-light); border: 2px solid var(--accent-cyan); color: var(--accent-cyan); font-family: 'Rajdhani', sans-serif; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .time-btn:hover, .inc-btn:hover { background: rgba(0, 212, 255, 0.2); }
        .time-btn.selected, .inc-btn.selected { background: var(--accent-cyan); color: var(--bg-dark); }
        /* Mistrzostwa */
        .championship-select { margin-top: 25px; }
        .championship-select h3 { font-family: 'Orbitron', monospace; font-size: 1.1rem; margin-bottom: 15px; color: var(--accent-gold); text-align: center; }
        .championship-list { display: flex; flex-direction: column; gap: 12px; max-width: 500px; margin: 0 auto; }
        .championship-card { display: flex; align-items: center; gap: 15px; padding: 15px 20px; background: var(--bg-light); border: 2px solid rgba(255,255,255,0.1); border-radius: 8px; cursor: pointer; transition: all 0.3s ease; }
        .championship-card:hover { border-color: var(--accent-gold); transform: translateX(5px); background: rgba(255, 215, 0, 0.1); }
        .championship-card.selected { border-color: var(--accent-gold); background: rgba(255, 215, 0, 0.2); }
        .championship-card.locked { opacity: 0.5; cursor: not-allowed; position: relative; }
        .championship-card.locked:hover { border-color: #ff4444; transform: none; background: rgba(255, 68, 68, 0.1); }
        .championship-card.locked::after { content: 'üîí'; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 1.5rem; }
        .championship-card .lock-reason { font-size: 0.75rem; color: #ff6666; margin-top: 4px; }
        .championship-card.unlocked::after { content: '‚úì'; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 1.2rem; color: #00ff88; }
        .champ-icon { font-size: 2rem; }
        .champ-info { flex: 1; }
        .champ-name { font-family: 'Orbitron', monospace; font-size: 1rem; color: var(--text-primary); margin-bottom: 4px; }
        .champ-desc { font-size: 0.85rem; color: var(--text-secondary); }
        /* Ekran turnieju */
        .tournament-screen { padding: 20px; }
        .tournament-header { text-align: center; margin-bottom: 20px; }
        .tournament-title { font-family: 'Orbitron', monospace; font-size: 1.4rem; color: var(--accent-gold); margin-bottom: 5px; }
        .tournament-round { font-size: 1rem; color: var(--accent-cyan); }
        .tournament-bracket { display: flex; flex-direction: column; gap: 15px; max-width: 600px; margin: 0 auto; }
        .bracket-match { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; background: var(--bg-light); border-radius: 8px; border: 2px solid rgba(255,255,255,0.1); }
        .bracket-match.current { border-color: var(--accent-gold); animation: currentMatch 1.5s infinite; }
        .bracket-match.won { border-color: #00ff88; background: rgba(0, 255, 136, 0.1); }
        .bracket-match.lost { border-color: #ff4444; background: rgba(255, 68, 68, 0.1); opacity: 0.7; }
        @keyframes currentMatch { 0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); } 50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); } }
        .match-player { display: flex; align-items: center; gap: 10px; flex: 1; }
        .match-player.you { color: var(--accent-cyan); }
        .match-player.opponent { justify-content: flex-end; text-align: right; }
        .player-info { display: flex; flex-direction: column; }
        .player-match-name { font-weight: bold; font-size: 0.95rem; }
        .player-match-elo { font-size: 0.8rem; color: var(--text-secondary); }
        .match-vs { font-family: 'Orbitron', monospace; color: var(--accent-magenta); font-size: 0.9rem; padding: 0 15px; }
        .match-result { font-family: 'Orbitron', monospace; font-size: 0.85rem; padding: 5px 10px; border-radius: 4px; }
        .match-result.win { background: #00ff88; color: var(--bg-dark); }
        .match-result.loss { background: #ff4444; color: white; }
        .match-result.pending { background: var(--accent-gold); color: var(--bg-dark); }
        .play-match-btn { margin-top: 20px; padding: 15px 40px; background: linear-gradient(135deg, var(--accent-gold), #ff9500); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 1.1rem; font-weight: bold; cursor: pointer; border-radius: 8px; transition: all 0.3s ease; display: block; margin-left: auto; margin-right: auto; }
        .play-match-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        .watch-btn { margin-top: 10px; padding: 12px 30px; background: linear-gradient(135deg, var(--accent-cyan), #0088ff); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 0.95rem; font-weight: bold; cursor: pointer; border-radius: 8px; transition: all 0.3s ease; display: block; margin-left: auto; margin-right: auto; }
        .watch-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
        .tournament-standings { margin-top: 25px; padding: 15px; background: var(--bg-medium); border-radius: 8px; }
        .standings-title { font-family: 'Orbitron', monospace; font-size: 1rem; color: var(--accent-cyan); margin-bottom: 10px; text-align: center; }
        /* Gablota puchar√≥w */
        .trophy-cabinet { position: fixed; bottom: 15px; left: 15px; z-index: 100; }
        .trophy-btn { background: linear-gradient(135deg, #ffd700, #ff9500); border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 1.2rem; box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3); transition: all 0.3s ease; }
        .trophy-btn:hover { transform: scale(1.1); box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5); }
        .trophy-btn .trophy-count { font-family: 'Orbitron', monospace; font-size: 0.8rem; color: var(--bg-dark); margin-left: 5px; font-weight: bold; }
        .trophy-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center; }
        .trophy-modal.active { display: flex; }
        .trophy-content { background: var(--bg-dark); border: 2px solid var(--accent-gold); border-radius: 15px; padding: 25px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .trophy-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .trophy-title { font-family: 'Orbitron', monospace; font-size: 1.3rem; color: var(--accent-gold); }
        .trophy-close { background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer; }
        .trophy-close:hover { color: var(--accent-magenta); }
        .trophy-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; }
        .trophy-item { background: var(--bg-light); border-radius: 10px; padding: 15px; text-align: center; border: 2px solid transparent; transition: all 0.3s ease; }
        .trophy-item.earned { border-color: var(--accent-gold); background: rgba(255, 215, 0, 0.1); }
        .trophy-item.locked { opacity: 0.4; }
        .trophy-icon { font-size: 2.5rem; margin-bottom: 8px; }
        .trophy-item.earned .trophy-icon { animation: trophyGlow 2s infinite; }
        @keyframes trophyGlow { 0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.5)); } 50% { filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)); } }
        .trophy-name { font-family: 'Orbitron', monospace; font-size: 0.75rem; color: var(--text-primary); margin-bottom: 4px; }
        .trophy-date { font-size: 0.65rem; color: var(--text-secondary); }
        .opponent-trophies-btn { background: none; border: 1px solid var(--accent-gold); color: var(--accent-gold); padding: 5px 10px; border-radius: 5px; font-size: 0.8rem; cursor: pointer; margin-left: 10px; }
        .opponent-trophies-btn:hover { background: rgba(255, 215, 0, 0.2); }
        
        /* ===== TOOLTIP Z ZASADAMI ===== */
        .rule-tooltip {
            position: fixed;
            z-index: 10000;
            background: linear-gradient(135deg, #1a1a2e, #2d2d44);
            border: 2px solid var(--accent-magenta);
            border-radius: 12px;
            padding: 12px 16px;
            max-width: 300px;
            box-shadow: 0 0 30px rgba(255, 0, 170, 0.5), 0 10px 40px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: tooltipAppear 0.2s ease;
        }
        @keyframes tooltipAppear {
            from { opacity: 0; transform: scale(0.9) translateY(5px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        .rule-tooltip-title {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            color: var(--accent-magenta);
            margin-bottom: 5px;
        }
        .rule-tooltip-ref {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: var(--accent-gold);
            margin-bottom: 8px;
            padding: 2px 8px;
            background: rgba(255, 215, 0, 0.15);
            border-radius: 4px;
            display: inline-block;
        }
        .rule-tooltip-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }
        
        /* ===== ULEPSZONE STRZA≈ÅKI BLOKADY ===== */
        .capture-arrow {
            position: absolute;
            z-index: 50;
            pointer-events: none;
            filter: drop-shadow(0 0 8px rgba(255, 0, 100, 0.8));
        }
        .capture-arrow-line {
            stroke: #ff0066;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 12 4;
            animation: arrowPulse 1.5s infinite, arrowDash 0.8s linear infinite;
        }
        @keyframes arrowPulse {
            0%, 100% { stroke-width: 4; filter: drop-shadow(0 0 5px #ff0066); }
            50% { stroke-width: 6; filter: drop-shadow(0 0 15px #ff0066); }
        }
        @keyframes arrowDash {
            to { stroke-dashoffset: -16; }
        }
        .capture-arrow-head {
            fill: #ff0066;
            filter: drop-shadow(0 0 8px #ff0066);
        }
        .capture-arrow-glow {
            stroke: rgba(255, 0, 102, 0.3);
            stroke-width: 12;
            stroke-linecap: round;
        }
        
        /* ===== POLE ZABLOKOWANE - CZERWONE MRUGANIE ===== */
        .tile.blocked-attack {
            animation: blockedPulse 0.6s infinite !important;
            cursor: not-allowed !important;
        }
        @keyframes blockedPulse {
            0%, 100% { 
                background: rgba(255, 0, 50, 0.3) !important;
                box-shadow: inset 0 0 20px rgba(255, 0, 50, 0.5);
            }
            50% { 
                background: rgba(255, 0, 50, 0.6) !important;
                box-shadow: inset 0 0 40px rgba(255, 0, 50, 0.8), 0 0 20px rgba(255, 0, 50, 0.5);
            }
        }
        
        .timer-display { display: flex; align-items: center; justify-content: space-between; padding: 8px 20px; background: var(--bg-medium); border: 2px solid rgba(255,255,255,0.1); min-width: 200px; }
        .timer-display.active { border-color: var(--accent-gold); box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .timer-display.low-time { border-color: var(--accent-magenta); animation: lowTimePulse 0.5s infinite; }
        @keyframes lowTimePulse { 0%, 100% { box-shadow: 0 0 8px rgba(255, 0, 170, 0.5); } 50% { box-shadow: 0 0 20px rgba(255, 0, 170, 0.8); } }
        .timer-label { font-family: 'Orbitron', monospace; font-size: 0.75rem; color: var(--text-secondary); }
        .timer-value { font-family: 'Orbitron', monospace; font-size: 1.3rem; font-weight: bold; color: var(--text-primary); }
        .white-timer .timer-value { color: var(--white-piece); }
        .black-timer .timer-value { color: var(--accent-magenta); }
        .game-screen.active { flex-direction: row; }
        .game-layout { display: flex; flex: 1; gap: 15px; align-items: stretch; height: 100%; overflow: hidden; }
        .side-panel { 
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 16px;
            width: 210px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        }
        .side-panel::-webkit-scrollbar { width: 4px; }
        .side-panel::-webkit-scrollbar-thumb { background: var(--accent-cyan); }
        .panel-title { font-family: 'Orbitron', monospace; font-size: 0.85rem; color: var(--accent-cyan); margin-bottom: 10px; letter-spacing: 1px; }
        .captured-pieces { display: flex; flex-wrap: wrap; gap: 4px; min-height: 40px; }
        .captured-piece { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; opacity: 0.7; }
        .turn-indicator { text-align: center; padding: 10px; background: var(--bg-light); margin-bottom: 12px; border-left: 3px solid var(--accent-cyan); }
        .turn-indicator.white-turn { border-left-color: var(--white-piece); }
        .turn-indicator.black-turn { border-left-color: var(--accent-magenta); }
        .turn-label { font-family: 'Orbitron'; font-size: 0.7rem; color: var(--text-secondary); }
        .turn-player { font-size: 1.1rem; font-weight: bold; }
        .move-info-panel { margin-top: 10px; padding: 10px; background: var(--bg-light); font-size: 0.85rem; text-align: center; }
        .move-info-panel .piece-name { color: var(--accent-gold); font-weight: bold; font-size: 0.9rem; }
        .move-info-panel .moves-left { color: var(--accent-cyan); font-family: 'Orbitron', monospace; font-size: 1rem; }
        .game-board-container { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; min-width: 0; }
        .game-board-container.flipped { flex-direction: column-reverse; }
        .board-with-eval { display: flex; align-items: stretch; gap: 10px; flex-direction: row; }
        .eval-bar { width: 25px; height: min(65vh, 500px); background: var(--accent-magenta); border-radius: 4px; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        .eval-toggle { writing-mode: vertical-rl; text-orientation: mixed; font-size: 0.9rem; color: var(--text-secondary); display: flex; align-items: center; margin-left: -3px; background: var(--bg-medium); padding: 8px 4px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }
        .eval-toggle label { display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap; }
        .eval-toggle input { width: 16px; height: 16px; cursor: pointer; }
        .eval-toggle:hover { background: var(--bg-light); border-color: var(--accent-cyan); }
        .eval-white { background: var(--white-piece); transition: height 0.5s ease; height: 50%; }
        .eval-black { background: var(--accent-magenta); flex: 1; }
        .eval-marker { position: absolute; left: 0; right: 0; height: 3px; background: var(--accent-gold); top: 50%; transform: translateY(-50%); transition: top 0.5s ease; box-shadow: 0 0 8px var(--accent-gold); }
        .eval-value { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-family: 'Orbitron', monospace; font-size: 0.65rem; color: var(--bg-dark); background: rgba(255,255,255,0.9); padding: 2px 4px; border-radius: 2px; white-space: nowrap; transition: top 0.5s ease; }
        .board-wrapper { 
            position: relative; 
            padding: 28px;
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 18px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6), 0 0 100px rgba(0, 245, 255, 0.08);
        }
        .board-labels { position: absolute; font-family: 'Orbitron', monospace; font-size: 0.8rem; color: var(--text-secondary); pointer-events: none; }
        .board-label-top { top: 3px; left: 25px; right: 25px; display: flex; justify-content: space-around; }
        .board-label-bottom { bottom: 3px; left: 25px; right: 25px; display: flex; justify-content: space-around; }
        .board-label-left { left: 3px; top: 25px; bottom: 25px; display: flex; flex-direction: column; justify-content: space-around; align-items: center; }
        .board-label-right { right: 3px; top: 25px; bottom: 25px; display: flex; flex-direction: column; justify-content: space-around; align-items: center; }
        .board { 
            display: grid; 
            grid-template-columns: repeat(8, 1fr); 
            gap: 3px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.65), rgba(15, 15, 35, 0.65));
            padding: 3px;
            width: min(66vh, 520px);
            height: min(66vh, 520px);
            border-radius: 10px;
            box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.5), 0 0 60px rgba(0, 245, 255, 0.08);
            position: relative;
        }
        .tile { 
            aspect-ratio: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            position: relative;
            transition: all 0.25s ease;
            border-radius: 4px;
        }
        .tile.light { 
            background: linear-gradient(145deg, #f0e4d0, #d8ccb8);
            box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.35);
        }
        .tile.dark { 
            background: linear-gradient(145deg, #a58020, #8b6914);
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.25);
        }
        .tile:hover {
            filter: brightness(1.18);
            transform: scale(1.03);
            z-index: 5;
        }
        .tile.zone-center { background: linear-gradient(135deg, var(--zone-center), var(--zone-center)), var(--tile-light); }
        .tile.dark.zone-center { background: linear-gradient(135deg, var(--zone-center), var(--zone-center)), var(--tile-dark); }
        .tile.zone-nexus-white { background: linear-gradient(135deg, var(--zone-nexus-white), var(--zone-nexus-white)), var(--tile-light); }
        .tile.dark.zone-nexus-white { background: linear-gradient(135deg, var(--zone-nexus-white), var(--zone-nexus-white)), var(--tile-dark); }
        .tile.zone-phantom-white { background: linear-gradient(135deg, var(--zone-phantom-white), var(--zone-phantom-white)), var(--tile-light); }
        .tile.dark.zone-phantom-white { background: linear-gradient(135deg, var(--zone-phantom-white), var(--zone-phantom-white)), var(--tile-dark); }
        .tile.zone-nexus-black { background: linear-gradient(135deg, var(--zone-nexus-black), var(--zone-nexus-black)), var(--tile-light); }
        .tile.dark.zone-nexus-black { background: linear-gradient(135deg, var(--zone-nexus-black), var(--zone-nexus-black)), var(--tile-dark); }
        .tile.zone-phantom-black { background: linear-gradient(135deg, var(--zone-phantom-black), var(--zone-phantom-black)), var(--tile-light); }
        .tile.dark.zone-phantom-black { background: linear-gradient(135deg, var(--zone-phantom-black), var(--zone-phantom-black)), var(--tile-dark); }
        .tile.selected { 
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.65), rgba(0, 200, 255, 0.45)) !important;
            box-shadow: inset 0 0 35px rgba(0, 245, 255, 0.65), 0 0 30px rgba(0, 245, 255, 0.5);
            animation: selectedPulse 1.2s infinite ease-in-out;
        }
        @keyframes selectedPulse {
            0%, 100% { box-shadow: inset 0 0 35px rgba(0, 245, 255, 0.65), 0 0 30px rgba(0, 245, 255, 0.5); }
            50% { box-shadow: inset 0 0 50px rgba(0, 245, 255, 0.85), 0 0 50px rgba(0, 245, 255, 0.7); }
        }
        .tile.valid-move { 
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.55), rgba(0, 200, 100, 0.35)) !important;
            cursor: pointer;
        }
        .tile.valid-move::after {
            content: '';
            position: absolute;
            width: 38%;
            height: 38%;
            background: var(--neon-green, #00ff88);
            border-radius: 50%;
            opacity: 0.75;
            animation: validMoveDot 1.2s infinite ease-in-out;
            box-shadow: 0 0 15px var(--neon-green, #00ff88);
        }
        @keyframes validMoveDot {
            0%, 100% { transform: scale(1); opacity: 0.75; }
            50% { transform: scale(1.25); opacity: 1; }
        }
        .tile.threat { background: var(--threat) !important; }
        .tile.threatened-king { animation: kingThreat 0.5s infinite; }
        @keyframes kingThreat { 0%, 100% { box-shadow: inset 0 0 20px rgba(255, 0, 100, 0.8); } 50% { box-shadow: inset 0 0 40px rgba(255, 0, 100, 1); } }
        .piece { 
            width: 100%; 
            height: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            cursor: grab;
        }
        .piece:hover { transform: scale(1.18) translateY(-4px); }
        .piece:active { cursor: grabbing; transform: scale(1.22) translateY(-6px); }
        .piece.attacking { opacity: 0.72; filter: saturate(0.65); }
        .piece.attacking:hover { transform: none; }
        .piece.white { 
            color: var(--white-piece);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.45));
        }
        .piece.white .piece-symbol {
            text-shadow: 
                0 0 20px rgba(240, 245, 255, 0.9),
                0 0 40px rgba(240, 245, 255, 0.6),
                0 3px 6px rgba(0, 0, 0, 0.35),
                0 0 3px #fff;
        }
        .piece.black { 
            color: var(--black-piece);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.55));
        }
        .piece.black .piece-symbol {
            text-shadow: 
                0 0 18px rgba(255, 0, 255, 0.7),
                0 0 35px rgba(255, 0, 255, 0.4),
                0 3px 6px rgba(0, 0, 0, 0.55),
                1px 1px 0 rgba(255, 0, 255, 0.6),
                -1px -1px 0 rgba(255, 0, 255, 0.6);
        }
        .piece-symbol { font-size: 2.3rem; font-weight: bold; line-height: 1; transition: all 0.3s ease; }
        /* Animacja ruchu figury */
        .moving-piece { position: absolute; z-index: 100; pointer-events: none; transition: left 0.3s ease-out, top 0.3s ease-out; }
        .moving-piece .piece-symbol { font-size: 2rem; font-weight: bold; }
        .moving-piece.white { color: var(--white-piece); text-shadow: 0 2px 15px rgba(224, 232, 255, 0.8); }
        .moving-piece.black { color: var(--black-piece); text-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.5); }
        .path-arrow { position: absolute; font-size: 1.5rem; color: var(--accent-gold); z-index: 1; text-shadow: 0 0 10px rgba(255, 215, 0, 0.9); pointer-events: none; }
        .lock-arrow { position: absolute; font-size: 1.3rem; z-index: 3; text-shadow: 0 0 12px currentColor; pointer-events: none; animation: lockPulse 1s infinite; }
        .lock-arrow.white-lock { color: var(--white-piece); }
        .lock-arrow.black-lock { color: var(--accent-magenta); }
        @keyframes lockPulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.15); } }
        .lock-timer { position: absolute; bottom: 3px; right: 4px; font-size: 0.75rem; font-family: 'Orbitron', monospace; z-index: 4; padding: 1px 4px; border-radius: 3px; background: rgba(0,0,0,0.8); }
        .lock-timer.white-lock { color: var(--white-piece); }
        .lock-timer.black-lock { color: var(--accent-magenta); }
        .attacker-pos { position: absolute; top: 3px; left: 4px; font-size: 0.9rem; z-index: 4; opacity: 0.7; }
        /* Tarcza Sentinela */
        .tile.sentinel-shield { position: relative; }
        .tile.sentinel-shield::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 1; }
        .tile.white-shield::after { background: linear-gradient(135deg, rgba(224, 232, 255, 0.3), rgba(224, 232, 255, 0.1)); border: 2px solid rgba(224, 232, 255, 0.5); box-shadow: inset 0 0 15px rgba(224, 232, 255, 0.4); }
        .tile.black-shield::after { background: linear-gradient(135deg, rgba(255, 0, 170, 0.3), rgba(255, 0, 170, 0.1)); border: 2px solid rgba(255, 0, 170, 0.5); box-shadow: inset 0 0 15px rgba(255, 0, 170, 0.4); }
        .piece.guardian { animation: guardianPulse 2s infinite; }
        @keyframes guardianPulse { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        /* Zamro≈ºenie */
        .piece.frozen { filter: brightness(0.7) saturate(0.5); opacity: 0.6; cursor: not-allowed; }
        .piece.frozen::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle, rgba(100, 200, 255, 0.3), transparent); pointer-events: none; }
        .frozen-timer { position: absolute; bottom: 2px; left: 2px; font-size: 0.7rem; color: #00d4ff; background: rgba(0,0,0,0.7); padding: 1px 4px; border-radius: 3px; z-index: 5; }
        /* Figura atakujƒÖca - pulsowanie na ≈º√≥≈Çto-z≈Çoto */
        .piece.is-attacker { animation: attackPulse 1.1s infinite ease-in-out; }
        @keyframes attackPulse { 
            0%, 100% { 
                background: radial-gradient(circle, rgba(255, 200, 0, 0.45) 0%, transparent 70%);
                box-shadow: 0 0 18px rgba(255, 200, 0, 0.6);
            } 
            50% { 
                background: radial-gradient(circle, rgba(255, 200, 0, 0.8) 0%, transparent 70%);
                box-shadow: 0 0 40px rgba(255, 200, 0, 1);
            } 
        }
        /* Figura kt√≥ra bra≈Ça udzia≈Ç w podw√≥jnym ataku - zielone ≈õwiecenie */
        .piece.double-attacker { animation: doubleAttackPulse 0.85s infinite ease-in-out; }
        @keyframes doubleAttackPulse {
            0%, 100% { 
                background: radial-gradient(circle, rgba(0, 255, 136, 0.45) 0%, transparent 70%);
                box-shadow: 0 0 22px rgba(0, 255, 136, 0.7);
            }
            50% { 
                background: radial-gradient(circle, rgba(0, 255, 136, 0.9) 0%, transparent 70%);
                box-shadow: 0 0 50px rgba(0, 255, 136, 1);
            }
        }
        @keyframes doubleAttackPulse { 
            0%, 100% { background: rgba(0, 255, 100, 0.4); box-shadow: 0 0 15px rgba(0, 255, 100, 0.6); } 
            50% { background: rgba(0, 255, 100, 0.8); box-shadow: 0 0 30px rgba(0, 255, 100, 1); } 
        }
        /* Kr√≥l pod szachem - czerwony b≈Çysk */
        .piece.in-check { animation: checkFlash 0.8s infinite ease-in-out; }
        @keyframes checkFlash { 
            0%, 100% { background: rgba(255, 50, 50, 0.4); box-shadow: 0 0 20px rgba(255, 0, 0, 0.6), inset 0 0 15px rgba(255, 0, 0, 0.3); } 
            50% { background: rgba(255, 0, 0, 0.7); box-shadow: 0 0 40px rgba(255, 0, 0, 1), inset 0 0 25px rgba(255, 0, 0, 0.5); } 
        }
        /* Kr√≥l zamatowany - z≈Çoty b≈Çysk */
        .piece.in-mate { animation: mateFlash 0.6s infinite ease-in-out; }
        @keyframes mateFlash { 
            0%, 100% { background: rgba(255, 215, 0, 0.5); box-shadow: 0 0 25px rgba(255, 200, 0, 0.7), inset 0 0 20px rgba(255, 180, 0, 0.4); } 
            50% { background: rgba(255, 200, 0, 0.9); box-shadow: 0 0 50px rgba(255, 180, 0, 1), inset 0 0 30px rgba(255, 150, 0, 0.6); } 
        }
        /* Online / Profil */
        .profile-bar { position: absolute; top: 5px; left: 10px; display: flex; align-items: center; gap: 10px; z-index: 50; }
        .profile-name { font-family: 'Orbitron', monospace; font-size: 0.85rem; color: var(--accent-cyan); padding: 5px 12px; background: var(--bg-medium); border: 1px solid var(--accent-cyan); cursor: pointer; }
        .profile-name:hover { background: rgba(0, 212, 255, 0.2); }
        .no-profile { color: var(--accent-magenta); border-color: var(--accent-magenta); }
        .no-profile:hover { background: rgba(255, 0, 170, 0.2); }
        .elo-display { font-family: 'Orbitron', monospace; font-size: 0.85rem; color: var(--accent-gold); padding: 5px 12px; background: var(--bg-medium); border: 1px solid var(--accent-gold); }
        .opponent-info { display: flex; align-items: center; gap: 8px; font-family: 'Orbitron', monospace; font-size: 0.85rem; padding: 5px 12px; background: var(--bg-medium); border: 1px solid var(--accent-magenta); }
        .vs-text { color: var(--text-secondary); font-size: 0.7rem; }
        .opponent-name { color: var(--accent-magenta); }
        .opponent-elo { color: var(--accent-gold); font-size: 0.75rem; }
        .elo-toast { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); padding: 10px 20px; font-family: 'Orbitron', monospace; font-size: 0.9rem; z-index: 1002; display: none; border-radius: 5px; animation: eloToastIn 0.3s ease; }
        .elo-toast.active { display: block; }
        .elo-toast.positive { background: rgba(0, 180, 100, 0.9); color: white; border: 2px solid #00ff88; }
        .elo-toast.negative { background: rgba(180, 0, 50, 0.9); color: white; border: 2px solid #ff4466; }
        @keyframes eloToastIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        @media (max-width: 900px) {
            .profile-bar { top: 30px; left: 5px; flex-direction: column; gap: 5px; align-items: flex-start; }
            .profile-name { font-size: 0.6rem; padding: 3px 8px; }
            .elo-display { font-size: 0.6rem; padding: 3px 8px; }
            .opponent-info { font-size: 0.6rem; padding: 3px 8px; }
            .elo-toast { top: 80px; font-size: 0.75rem; padding: 8px 15px; }
        }
        /* Ekran profilu */
        .profile-screen { text-align: center; justify-content: center; align-items: center; padding: 20px; }
        .profile-form { background: var(--bg-medium); border: 2px solid var(--accent-cyan); padding: 30px; max-width: 400px; }
        .profile-form h2 { font-family: 'Orbitron', monospace; font-size: 1.3rem; color: var(--accent-cyan); margin-bottom: 20px; }
        .profile-form input { width: 100%; padding: 12px; background: var(--bg-dark); border: 2px solid rgba(255,255,255,0.2); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; font-size: 1.1rem; margin-bottom: 15px; text-align: center; }
        .profile-form input:focus { outline: none; border-color: var(--accent-cyan); }
        .profile-form .save-btn { padding: 12px 30px; background: var(--accent-cyan); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 1rem; cursor: pointer; }
        .profile-form .save-btn:hover { box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
        /* Lobby Online */
        .lobby-screen { text-align: center; justify-content: center; align-items: center; padding: 20px; }
        .lobby-box { background: var(--bg-medium); border: 2px solid var(--accent-gold); padding: 30px; max-width: 500px; width: 100%; }
        .lobby-box h2 { font-family: 'Orbitron', monospace; font-size: 1.3rem; color: var(--accent-gold); margin-bottom: 20px; }
        .lobby-link { display: block; background: var(--bg-dark); padding: 15px; margin: 15px 0; border: 1px solid rgba(255,255,255,0.2); word-break: break-all; font-family: monospace; font-size: 0.9rem; color: var(--accent-cyan); text-decoration: none; }
        .lobby-link:hover { background: rgba(0, 212, 255, 0.1); border-color: var(--accent-cyan); }
        .lobby-link-copy { padding: 8px 20px; background: var(--accent-cyan); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 0.8rem; cursor: pointer; margin-top: 10px; }
        .lobby-players { margin: 20px 0; padding: 15px; background: var(--bg-light); }
        .lobby-players h3 { font-family: 'Orbitron', monospace; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px; }
        .player-slot { padding: 10px; margin: 5px 0; background: var(--bg-dark); border-left: 3px solid var(--accent-cyan); display: flex; align-items: center; justify-content: space-between; }
        .player-slot.empty { border-left-color: var(--text-secondary); opacity: 0.5; }
        .player-slot .player-name { font-family: 'Orbitron', monospace; font-size: 0.85rem; }
        .player-slot .player-status { font-size: 0.75rem; color: var(--text-secondary); }
        .waiting-text { color: var(--accent-gold); font-size: 1rem; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .start-game-btn { padding: 15px 40px; background: var(--accent-gold); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 1rem; cursor: pointer; margin-top: 15px; }
        .start-game-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .start-game-btn:not(:disabled):hover { box-shadow: 0 0 25px rgba(255, 215, 0, 0.5); }
        .leave-lobby-btn { padding: 10px 25px; background: transparent; border: 2px solid var(--accent-magenta); color: var(--accent-magenta); font-family: 'Orbitron', monospace; font-size: 0.85rem; cursor: pointer; margin-top: 15px; }
        .leave-lobby-btn:hover { background: rgba(255, 0, 170, 0.2); }
        .lobby-settings { margin: 15px 0; padding: 15px; background: var(--bg-light); }
        .lobby-settings h3 { font-family: 'Orbitron', monospace; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px; }
        .lobby-time-btns, .lobby-inc-btns { display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; }
        .lobby-time-btn, .lobby-inc-btn { padding: 8px 12px; font-size: 0.75rem; }
        .lobby-settings-display { color: var(--accent-cyan); font-size: 0.9rem; margin: 10px 0; }
        .pending-captures { margin-top: 12px; padding: 10px; background: rgba(255, 0, 100, 0.1); border: 1px solid rgba(255, 0, 100, 0.3); }
        .pending-title { font-family: 'Orbitron', monospace; font-size: 0.75rem; color: var(--accent-magenta); margin-bottom: 8px; }
        .pending-item { font-size: 0.85rem; color: var(--text-secondary); padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        /* Przyciski online (remis, poddanie) */
        .online-actions { margin-top: 15px; display: flex; flex-direction: column; gap: 8px; }
        .draw-btn, .resign-btn { padding: 10px 15px; font-family: 'Orbitron', monospace; font-size: 0.75rem; cursor: pointer; border: none; }
        .draw-btn { background: var(--accent-gold); color: var(--bg-dark); }
        .draw-btn:hover { box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .draw-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .resign-btn { background: var(--accent-magenta); color: white; }
        .resign-btn:hover { box-shadow: 0 0 15px rgba(255, 0, 170, 0.5); }
        /* Modal propozycji remisu */
        .draw-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; }
        .draw-modal.active { display: flex; }
        .draw-modal-content { background: var(--bg-medium); border: 2px solid var(--accent-gold); padding: 30px; text-align: center; max-width: 350px; animation: modalPop 0.3s ease; }
        @keyframes modalPop { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .draw-modal-text { font-family: 'Orbitron', monospace; font-size: 1.1rem; color: var(--accent-gold); margin-bottom: 20px; }
        .draw-modal-buttons { display: flex; gap: 15px; justify-content: center; margin-bottom: 15px; }
        .draw-accept { padding: 12px 25px; background: var(--accent-cyan); border: none; color: var(--bg-dark); font-family: 'Orbitron', monospace; font-size: 0.9rem; cursor: pointer; }
        .draw-accept:hover { box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
        .draw-decline { padding: 12px 25px; background: var(--accent-magenta); border: none; color: white; font-family: 'Orbitron', monospace; font-size: 0.9rem; cursor: pointer; }
        .draw-decline:hover { box-shadow: 0 0 20px rgba(255, 0, 170, 0.5); }
        .draw-modal-hint { font-size: 0.75rem; color: var(--text-secondary); }
        /* Toast z odpowiedziƒÖ */
        .draw-toast { position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: var(--bg-medium); border: 2px solid var(--accent-cyan); padding: 15px 30px; font-family: 'Orbitron', monospace; font-size: 1rem; z-index: 1001; display: none; animation: toastIn 0.3s ease; }
        .draw-toast.active { display: block; }
        .draw-toast.accepted { border-color: var(--accent-cyan); color: var(--accent-cyan); }
        .draw-toast.declined { border-color: var(--accent-magenta); color: var(--accent-magenta); }
        .draw-toast.sent { border-color: var(--accent-gold); color: var(--accent-gold); }
        @keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(-20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .legend { margin-top: 12px; padding: 10px; background: var(--bg-light); }
        .legend-title { font-family: 'Orbitron', monospace; font-size: 0.75rem; color: var(--accent-gold); margin-bottom: 8px; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 5px; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.3); }
        .legend-color.center { background: rgba(255, 215, 0, 0.5); }
        .legend-color.nexus-white { background: rgba(0, 150, 255, 0.5); }
        .legend-color.phantom-white { background: rgba(0, 255, 150, 0.5); }
        .legend-color.nexus-black { background: rgba(255, 100, 100, 0.5); }
        .legend-color.phantom-black { background: rgba(255, 150, 0, 0.5); }
        .zone-toggle { margin-top: 8px; }
        .zone-toggle label { font-size: 0.75rem; color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; gap: 6px; }
        .zone-toggle input { cursor: pointer; width: 14px; height: 14px; }
        .rules-screen { flex: 1; overflow-y: auto; padding: 20px; }
        .rules-screen::-webkit-scrollbar { width: 8px; }
        .rules-screen::-webkit-scrollbar-thumb { background: var(--accent-cyan); border-radius: 4px; }
        .rules-section { 
            background: rgba(30,30,50,0.9); 
            border: 1px solid rgba(0,212,255,0.2); 
            border-radius: 12px;
            padding: 20px; 
            margin-bottom: 15px;
        }
        .rules-section h2 { 
            font-family: 'Orbitron', monospace; 
            font-size: 1.2rem; 
            color: var(--accent-cyan); 
            margin-bottom: 15px; 
            padding-bottom: 10px; 
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
        }
        .rules-icons-legend { 
            display: flex;
            flex-direction: column;
            gap: 8px; 
            margin: 15px 0; 
            padding: 15px; 
            background: rgba(0,0,0,0.2); 
            border-radius: 8px; 
        }
        .rules-icon-item { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            font-size: 0.9rem; 
            color: var(--text-secondary);
        }
        .rules-section h3 { 
            font-family: 'Orbitron', monospace; 
            font-size: 1rem; 
            color: var(--accent-gold); 
            margin: 15px 0 8px;
        }
        .rules-section p { color: var(--text-secondary); line-height: 1.6; margin-bottom: 8px; font-size: 0.9rem; }
        .piece-showcase { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin-top: 12px; }
        .piece-card { 
            background: rgba(0,0,0,0.2); 
            padding: 12px; 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            border-left: 3px solid var(--accent-cyan);
            border-radius: 6px;
        }
        .piece-card-symbol { font-size: 2.2rem; color: var(--white-piece); }
        .piece-card-info h4 { font-family: 'Orbitron', monospace; font-size: 0.85rem; margin-bottom: 4px; color: var(--accent-cyan); }
        .piece-card-info p { font-size: 0.8rem; color: var(--text-secondary); margin: 0; line-height: 1.4; }
        .highlight-box { 
            background: rgba(0, 212, 255, 0.1); 
            border-left: 3px solid var(--accent-cyan); 
            border-radius: 6px;
            padding: 12px 15px; 
            margin: 12px 0; 
            font-size: 0.85rem;
        }
        .warning-box { 
            background: rgba(255, 0, 100, 0.1); 
            border-left: 3px solid var(--accent-magenta); 
            border-radius: 6px;
            padding: 12px 15px; 
            margin: 12px 0; 
            font-size: 0.85rem;
        }
        .modal-overlay { 
            display: none; 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(12px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal { 
            background: var(--bg-medium);
            border: 2px solid var(--accent-cyan);
            border-radius: 18px;
            padding: 38px;
            text-align: center;
            max-width: 420px;
            animation: modalIn 0.45s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 80px rgba(0, 245, 255, 0.3);
        }
        @keyframes modalIn { 
            from { transform: scale(0.45) rotate(-15deg); opacity: 0; } 
            to { transform: scale(1) rotate(0); opacity: 1; } 
        }
        .modal h2 { 
            font-family: 'Orbitron', monospace; 
            font-size: 1.9rem;
            margin-bottom: 18px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
        }
        .modal p { color: var(--text-secondary); margin-bottom: 22px; font-size: 1.15rem; }
        .modal-btn { 
            padding: 14px 40px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.35s ease;
            border-radius: 10px;
        }
        .modal-btn:hover { 
            transform: scale(1.06);
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.6);
        }
        .move-log { flex: 1; overflow-y: auto; font-size: 0.8rem; }
        .move-log::-webkit-scrollbar { width: 4px; }
        .move-log::-webkit-scrollbar-thumb { background: var(--accent-cyan); }
        .log-entry { padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--text-secondary); cursor: pointer; transition: all 0.2s ease; }
        .log-entry:hover { background: rgba(255,255,255,0.05); }
        .log-entry.active-state { background: rgba(0, 212, 255, 0.2); border-left: 2px solid var(--accent-cyan); }
        .log-entry.white-move { border-left: 2px solid var(--white-piece); }
        .log-entry.black-move { border-left: 2px solid var(--accent-magenta); }
        .analysis-controls { margin-top: 10px; padding: 10px; background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); }
        .state-info { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 8px; text-align: center; }
        .analysis-btns { display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; }
        .analysis-btn { padding: 6px 12px; background: var(--bg-light); border: 1px solid var(--accent-cyan); color: var(--accent-cyan); font-size: 0.9rem; cursor: pointer; transition: all 0.3s ease; }
        .analysis-btn:hover { background: var(--accent-cyan); color: var(--bg-dark); }
        .analysis-btn.reset-btn { border-color: var(--accent-magenta); color: var(--accent-magenta); }
        .analysis-btn.reset-btn:hover { background: var(--accent-magenta); }
        .whatif-panel { margin-top: 8px; padding: 8px; background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); text-align: center; }
        .whatif-info { font-size: 0.7rem; color: var(--accent-gold); margin-bottom: 5px; }
        .whatif-counter { font-family: 'Orbitron', monospace; font-size: 0.85rem; color: var(--accent-gold); }
        
        /* Mobile turn info - ukryte na desktop */
        .mobile-turn-info { display: none; }
        
        /* Animacja obrotu planszy */
        .board-wrapper { transition: transform 0.5s ease-in-out; }
        .board-wrapper.rotated { transform: rotate(180deg); }
        .board-wrapper.rotated .piece { transform: rotate(180deg); }
        .board-wrapper.rotated .lock-timer { transform: rotate(180deg); top: 3px; bottom: auto; right: auto; left: 4px; }
        .board-wrapper.rotated .attacker-pos { transform: rotate(180deg); bottom: 3px; top: auto; left: auto; right: 4px; }
        .board-wrapper.rotated .move-icon { transform: rotate(180deg); }
        .board-wrapper.rotated .move-icons-legend { transform: rotate(180deg); }
        
        /* Emotki ruch√≥w */
        .move-icon { position: absolute; top: -8px; right: -5px; font-size: 0.7rem; font-weight: bold; padding: 2px 4px; border-radius: 4px; z-index: 10; font-family: 'Orbitron', monospace; line-height: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .move-icon.brilliant { background: #1baca6; color: white; }
        .move-icon.great { background: #5c8bb0; color: white; }
        .move-icon.good { background: #97af8b; color: white; }
        .move-icon.book { background: #a88865; color: white; }
        .move-icon.inaccuracy { background: #e6a837; color: black; }
        .move-icon.mistake { background: #e68a37; color: white; }
        .move-icon.blunder { background: #ca3431; color: white; }
        
        /* Legenda emotek */
        .move-icons-legend { display: flex; justify-content: center; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
        .icon-item { font-size: 0.65rem; font-weight: bold; padding: 3px 6px; border-radius: 3px; font-family: 'Orbitron', monospace; }
        .icon-item.brilliant { background: #1baca6; color: white; }
        .icon-item.great { background: #5c8bb0; color: white; }
        .icon-item.good { background: #97af8b; color: white; }
        .icon-item.book { background: #a88865; color: white; }
        .icon-item.inaccuracy { background: #e6a837; color: black; }
        .icon-item.mistake { background: #e68a37; color: white; }
        .icon-item.blunder { background: #ca3431; color: white; }
        
        /* MOBILE - layout jak chess.com - szachownica fullscreen */
        @media (max-width: 900px) { 
            .container { padding: 0; height: 100vh; }
            header { display: none; }
            nav { position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: var(--bg-dark); padding: 3px; gap: 3px; justify-content: center; border-bottom: 1px solid rgba(255,255,255,0.1); }
            .nav-btn { padding: 4px 10px; font-size: 0.55rem; border-width: 1px; }
            .game-screen.active { padding-top: 28px; height: 100%; }
            .game-layout { flex-direction: column; gap: 0; height: 100%; }
            .side-panel { display: none !important; }
            .game-board-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; }
            .board { width: min(calc(100vh - 140px), calc(100vw - 10px)); height: min(calc(100vh - 140px), calc(100vw - 10px)); gap: 0; padding: 0; }
            .board-wrapper { padding: 0; }
            .board-labels { display: none; }
            .tile { border: none; }
            .piece-symbol { font-size: clamp(1.2rem, 10vmin, 3rem); }
            .path-arrow { font-size: clamp(0.8rem, 6vmin, 2rem); }
            .lock-arrow { font-size: clamp(0.7rem, 5vmin, 1.6rem); }
            .lock-timer { font-size: clamp(0.4rem, 2vmin, 0.8rem); padding: 1px 3px; bottom: 2px; right: 3px; }
            .attacker-pos { font-size: clamp(0.4rem, 2vmin, 0.8rem); top: 2px; left: 3px; }
            .timer-display { position: fixed; left: 50%; transform: translateX(-50%); padding: 4px 15px; border-width: 1px; z-index: 50; background: var(--bg-dark); }
            .timer-display.black-timer { top: 32px; }
            .timer-display.white-timer { bottom: 8px; }
            .timer-label { font-size: 0.5rem; }
            .timer-value { font-size: 0.9rem; }
            /* Mobile turn info miƒôdzy zegarami */
            .mobile-turn-info { 
                display: flex; 
                flex-direction: column; 
                align-items: center; 
                padding: 8px 20px; 
                background: var(--bg-medium); 
                border: 1px solid rgba(255,255,255,0.2); 
                border-radius: 5px;
                margin: 5px 0;
            }
            .mobile-turn-player { 
                font-family: 'Orbitron', monospace; 
                font-size: 1rem; 
                font-weight: bold; 
                color: var(--accent-cyan);
                letter-spacing: 2px;
            }
            .mobile-turn-player.white-turn { color: var(--white-piece); }
            .mobile-turn-player.black-turn { color: var(--accent-magenta); }
            .mobile-turn-moves { 
                font-size: 0.75rem; 
                color: var(--text-secondary); 
                margin-top: 2px;
            }
            .modal { padding: 25px; max-width: 300px; }
            .modal h2 { font-size: 1.4rem; }
            .modal p { font-size: 1rem; margin-bottom: 15px; }
            .modal-btn { padding: 12px 30px; font-size: 0.9rem; }
        }
        @media (max-height: 700px) and (min-width: 901px) {
            .board { width: min(55vh, 450px); height: min(55vh, 450px); }
            header { padding: 5px 0; }
            h1 { font-size: 1.5rem; }
            nav { padding: 5px 0; }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    <div class="container">
        <div class="profile-bar">
            <div class="profile-name no-profile" id="profile-display" onclick="showProfileScreen()">‚öô Ustaw profil</div>
            <div class="elo-display" id="elo-display">‚≠ê 0 ELO</div>
            <div class="opponent-info" id="opponent-info" style="display: none;">
                <span class="vs-text">vs</span>
                <span class="opponent-name" id="opponent-name">-</span>
                <span class="opponent-elo" id="opponent-elo">‚≠ê 0</span>
                <button class="opponent-trophies-btn" id="opponent-trophies-btn" onclick="showOpponentTrophies()" style="display: none;">üèÜ</button>
            </div>
        </div>
        
        <!-- Toast zmiany ELO -->
        <div class="elo-toast" id="elo-toast"></div>
        
        <!-- Gablota puchar√≥w -->
        <div class="trophy-cabinet">
            <button class="trophy-btn" onclick="showTrophyCabinet()">
                üèÜ <span class="trophy-count" id="trophy-count">0</span>
            </button>
        </div>
        
        <!-- Modal gabloty -->
        <div class="trophy-modal" id="trophy-modal">
            <div class="trophy-content">
                <div class="trophy-header">
                    <div class="trophy-title" id="trophy-modal-title">üèÜ Twoja Gablota</div>
                    <button class="trophy-close" onclick="closeTrophyCabinet()">‚úï</button>
                </div>
                <div class="trophy-grid" id="trophy-grid">
                    <!-- Generowane przez JS -->
                </div>
            </div>
        </div>
        
        <header>
            <h1>Strza≈Çkowe Szachy</h1>
            <p class="subtitle">Strategia ‚Ä¢ Planowanie ‚Ä¢ Taktyka</p>
        </header>
        <nav>
            <button class="nav-btn active" data-screen="menu">Menu</button>
            <button class="nav-btn" data-screen="game">Gra</button>
            <button class="nav-btn" data-screen="rules">Zasady</button>
        </nav>
        
        <!-- Ekran profilu -->
        <div class="screen profile-screen" id="profile-screen">
            <div class="profile-form">
                <h2>üéÆ Tw√≥j Profil</h2>
                <p style="color: var(--text-secondary); margin-bottom: 15px;">Ustaw nazwƒô aby graƒá online</p>
                <input type="text" id="profile-name-input" placeholder="Wpisz nazwƒô gracza..." maxlength="20">
                <button class="save-btn" onclick="saveProfile()">Zapisz</button>
                <button class="leave-lobby-btn" onclick="showScreen('menu')" style="margin-left: 10px;">Anuluj</button>
            </div>
        </div>
        
        <!-- Ekran Lobby -->
        <div class="screen lobby-screen" id="lobby-screen">
            <div class="lobby-box">
                <h2>üåê Lobby Online</h2>
                <a class="lobby-link" id="lobby-link" href="#" target="_blank">Generowanie linku...</a>
                <button class="lobby-link-copy" onclick="copyLobbyLink()">üìã Kopiuj link</button>
                <div class="lobby-players">
                    <h3>Gracze (1/2)</h3>
                    <div class="player-slot" id="player1-slot">
                        <span class="player-name" id="player1-name">Host</span>
                        <span class="player-status">üëë Host</span>
                    </div>
                    <div class="player-slot empty" id="player2-slot">
                        <span class="player-name">Oczekiwanie...</span>
                        <span class="player-status">‚è≥</span>
                    </div>
                </div>
                <div class="lobby-settings" id="lobby-settings">
                    <h3>‚è±Ô∏è Czas na partiƒô</h3>
                    <div class="time-options lobby-time-btns">
                        <button class="time-btn lobby-time-btn" data-time="0">‚àû</button>
                        <button class="time-btn lobby-time-btn" data-time="3">3 min</button>
                        <button class="time-btn lobby-time-btn selected" data-time="5">5 min</button>
                        <button class="time-btn lobby-time-btn" data-time="10">10 min</button>
                        <button class="time-btn lobby-time-btn" data-time="15">15 min</button>
                    </div>
                    <div class="increment-options lobby-inc-btns" id="lobby-increment">
                        <h3>‚è±Ô∏è Bonus za ruch</h3>
                        <button class="inc-btn lobby-inc-btn" data-inc="0">+0s</button>
                        <button class="inc-btn lobby-inc-btn selected" data-inc="2">+2s</button>
                        <button class="inc-btn lobby-inc-btn" data-inc="3">+3s</button>
                        <button class="inc-btn lobby-inc-btn" data-inc="5">+5s</button>
                    </div>
                </div>
                <div class="lobby-settings-display" id="lobby-settings-display" style="display: none;">
                    <p>‚è±Ô∏è Czas: <span id="lobby-time-display">5 min</span> | Bonus: <span id="lobby-inc-display">+2s</span></p>
                </div>
                <p class="waiting-text" id="waiting-text">Czekam na drugiego gracza...</p>
                <button class="start-game-btn" id="start-online-btn" disabled onclick="startOnlineGame()">‚ñ∂ Rozpocznij Grƒô</button>
                <br>
                <button class="leave-lobby-btn" onclick="leaveLobby()">‚úñ Opu≈õƒá Lobby</button>
            </div>
        </div>
        
        <div class="screen menu-screen active" id="menu-screen">
            <h2 class="menu-title">Wybierz Tryb Gry</h2>
            <div class="game-modes">
                <div class="mode-card" data-mode="pvp">
                    <div class="mode-icon">‚öîÔ∏è</div>
                    <div class="mode-name">Gracz vs Gracz</div>
                    <div class="mode-desc">Graj z przyjacielem na jednym urzƒÖdzeniu.</div>
                </div>
                <div class="mode-card" data-mode="bot">
                    <div class="mode-icon">ü§ñ</div>
                    <div class="mode-name">Gracz vs Bot</div>
                    <div class="mode-desc">Zmierz siƒô z komputerem.</div>
                </div>
                <div class="mode-card" data-mode="online">
                    <div class="mode-icon">üåê</div>
                    <div class="mode-name">Online</div>
                    <div class="mode-desc">Stw√≥rz lobby i graj przez internet.</div>
                </div>
                <div class="mode-card" data-mode="championship">
                    <div class="mode-icon">üèÜ</div>
                    <div class="mode-name">Mistrzostwa</div>
                    <div class="mode-desc">We≈∫ udzia≈Ç w turniejach z AI przeciwnikami.</div>
                </div>
            </div>
            <div class="championship-select" id="championship-select" style="display: none;">
                <h3>üèÜ Wybierz Turniej</h3>
                <div class="championship-list">
                    <div class="championship-card" data-championship="world">
                        <div class="champ-icon">üåç</div>
                        <div class="champ-info">
                            <div class="champ-name">Mistrzostwa ≈öwiata</div>
                            <div class="champ-desc">Najlepsi gracze z ca≈Çego ≈õwiata ‚Ä¢ ELO 7000-9500</div>
                        </div>
                    </div>
                    <div class="championship-card" data-championship="continental">
                        <div class="champ-icon">üåé</div>
                        <div class="champ-info">
                            <div class="champ-name">Mistrzostwa Kontynentalne</div>
                            <div class="champ-desc">Czo≈Ç√≥wka kontynentu ‚Ä¢ ELO 5500-7500</div>
                        </div>
                    </div>
                    <div class="championship-card" data-championship="national">
                        <div class="champ-icon">üèõÔ∏è</div>
                        <div class="champ-info">
                            <div class="champ-name">Mistrzostwa Krajowe</div>
                            <div class="champ-desc">Najlepsi w kraju ‚Ä¢ ELO 4000-6000</div>
                        </div>
                    </div>
                    <div class="championship-card" data-championship="regional">
                        <div class="champ-icon">üèôÔ∏è</div>
                        <div class="champ-info">
                            <div class="champ-name">Mistrzostwa Regionalne</div>
                            <div class="champ-desc">Regionalni mistrzowie ‚Ä¢ ELO 2500-4500</div>
                        </div>
                    </div>
                    <div class="championship-card" data-championship="club">
                        <div class="champ-icon">‚ôüÔ∏è</div>
                        <div class="champ-info">
                            <div class="champ-name">Turniej Klubowy</div>
                            <div class="champ-desc">Lokalni entuzja≈õci ‚Ä¢ ELO 1000-3000</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="difficulty-select" id="difficulty-select" style="display: none;">
                <h3>Wybierz Poziom Trudno≈õci</h3>
                <div class="difficulty-btns">
                    <button class="diff-btn easy" data-diff="easy">≈Åatwy</button>
                    <button class="diff-btn medium" data-diff="medium">≈öredni</button>
                    <button class="diff-btn hard" data-diff="hard">Trudny</button>
                </div>
            </div>
            <div class="time-select" id="time-select" style="display: none;">
                <h3>Czas na grƒô</h3>
                <div class="time-btns">
                    <button class="time-btn" data-time="0">‚àû Bez limitu</button>
                    <button class="time-btn" data-time="1">1 min</button>
                    <button class="time-btn" data-time="3">3 min</button>
                    <button class="time-btn" data-time="5">5 min</button>
                    <button class="time-btn" data-time="10">10 min</button>
                    <button class="time-btn" data-time="15">15 min</button>
                </div>
                <div class="increment-select" id="increment-select" style="display: none;">
                    <h4>Bonus po ruchu</h4>
                    <div class="increment-btns">
                        <button class="inc-btn" data-inc="0">+0s</button>
                        <button class="inc-btn" data-inc="1">+1s</button>
                        <button class="inc-btn" data-inc="2">+2s</button>
                        <button class="inc-btn" data-inc="3">+3s</button>
                        <button class="inc-btn" data-inc="5">+5s</button>
                        <button class="inc-btn" data-inc="10">+10s</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Ekran turnieju -->
        <div class="screen tournament-screen" id="tournament-screen">
            <div class="tournament-header">
                <div class="tournament-title" id="tournament-title">üèÜ Mistrzostwa ≈öwiata</div>
                <div class="tournament-round" id="tournament-round">Runda 1 z 4</div>
            </div>
            <div class="tournament-bracket" id="tournament-bracket">
                <!-- Generowane przez JS -->
            </div>
            <button class="play-match-btn" id="play-match-btn" onclick="playCurrentMatch()">‚ñ∂ Graj Mecz</button>
            <button class="watch-btn" id="watch-tournament-btn" style="display: none;" onclick="watchTournament()">üëÅÔ∏è Obserwuj resztƒô turnieju</button>
            <div class="tournament-standings" id="tournament-standings">
                <div class="standings-title">üìä Twoje wyniki w turnieju</div>
                <div id="standings-content">Wygrane: 0 | Przegrane: 0</div>
            </div>
        </div>
        
        <div class="screen" id="game-screen">
            <div class="game-layout">
                <div class="side-panel">
                    <div class="turn-indicator white-turn" id="turn-indicator">
                        <div class="turn-label">TURA</div>
                        <div class="turn-player" id="current-player">BIA≈ÅE</div>
                    </div>
                    <div class="move-info-panel" id="move-info-panel" style="display: none;">
                        <div class="piece-name" id="selected-piece-name">-</div>
                        <div>Pozosta≈Ço krok√≥w: <span class="moves-left" id="moves-left">0</span></div>
                    </div>
                    <div style="margin-top: 20px;">
                        <div class="panel-title">Zbite przez Bia≈Çe</div>
                        <div class="captured-pieces" id="white-captured"></div>
                    </div>
                    <div style="margin-top: 20px;">
                        <div class="panel-title">Zbite przez Czarne</div>
                        <div class="captured-pieces" id="black-captured"></div>
                    </div>
                    <div class="pending-captures" id="pending-captures" style="display: none;">
                        <div class="pending-title">‚ö†Ô∏è Aktywne Blokady</div>
                        <div id="pending-list"></div>
                    </div>
                    <div class="online-actions" id="online-actions" style="display: none;">
                        <button class="draw-btn" id="btn-offer-draw">ü§ù Zaproponuj remis</button>
                        <button class="resign-btn" id="btn-resign">üè≥Ô∏è Poddaj siƒô</button>
                    </div>
                </div>
                
                <div class="game-board-container">
                    <div class="timer-display black-timer" id="black-timer">
                        <span class="timer-label">CZARNE</span>
                        <span class="timer-value" id="black-time">‚àû</span>
                    </div>
                    <div class="mobile-turn-info" id="mobile-turn-info">
                        <div class="mobile-turn-player" id="mobile-turn-player">BIA≈ÅE</div>
                        <div class="mobile-turn-moves" id="mobile-turn-moves"></div>
                    </div>
                    <div class="board-with-eval">
                        <div class="eval-bar" id="eval-bar">
                            <div class="eval-white" id="eval-white"></div>
                            <div class="eval-black" id="eval-black"></div>
                            <div class="eval-marker" id="eval-marker"></div>
                            <div class="eval-value" id="eval-value">0.0</div>
                        </div>
                        <div class="eval-toggle">
                            <label><input type="checkbox" id="show-eval" checked> Poka≈º pasek szans</label>
                        </div>
                        <div class="board-wrapper" id="board-wrapper">
                            <div class="board-labels board-label-top"><span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span></div>
                            <div class="board-labels board-label-bottom"><span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span></div>
                            <div class="board-labels board-label-left"><span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span></div>
                            <div class="board-labels board-label-right"><span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span></div>
                            <div class="board" id="board"></div>
                            <div class="move-icons-legend">
                                <span class="icon-item brilliant">!!</span>
                                <span class="icon-item great">!</span>
                                <span class="icon-item good">‚úì</span>
                                <span class="icon-item book">üìñ</span>
                                <span class="icon-item inaccuracy">?!</span>
                                <span class="icon-item mistake">?</span>
                                <span class="icon-item blunder">??</span>
                            </div>
                        </div>
                    </div>
                    <div class="timer-display white-timer" id="white-timer">
                        <span class="timer-label">BIA≈ÅE</span>
                        <span class="timer-value" id="white-time">‚àû</span>
                    </div>
                </div>
                <div class="side-panel">
                    <div class="panel-title">Historia Ruch√≥w</div>
                    <div class="move-log" id="move-log"></div>
                    <div class="legend">
                        <div class="legend-title">STREFY SZACHOWNICY</div>
                        <div class="legend-item"><div class="legend-color center"></div>Centrum</div>
                        <div class="legend-item"><div class="legend-color nexus-white"></div>Skrzyd≈Ço Nexusa (Bia≈Çe)</div>
                        <div class="legend-item"><div class="legend-color phantom-white"></div>Skrzyd≈Ço Phantoma (Bia≈Çe)</div>
                        <div class="legend-item"><div class="legend-color nexus-black"></div>Skrzyd≈Ço Nexusa (Czarne)</div>
                        <div class="legend-item"><div class="legend-color phantom-black"></div>Skrzyd≈Ço Phantoma (Czarne)</div>
                        <div class="zone-toggle">
                            <label><input type="checkbox" id="show-zones" checked> Poka≈º strefy</label>
                        </div>
                    </div>
                    <div class="analysis-controls" id="analysis-controls" style="display: none;">
                        <div class="panel-title">üìä ANALIZA</div>
                        <div class="state-info" id="state-info">-</div>
                        <div class="analysis-btns">
                            <button class="analysis-btn" id="btn-first">‚èÆ</button>
                            <button class="analysis-btn" id="btn-prev">‚óÄ</button>
                            <button class="analysis-btn" id="btn-next">‚ñ∂</button>
                            <button class="analysis-btn" id="btn-last">‚è≠</button>
                        </div>
                        <div class="whatif-panel" id="whatif-panel" style="display: none;">
                            <div class="whatif-info">üî¨ Tryb "Co je≈õli?" - testuj alternatywne ruchy</div>
                            <div class="whatif-counter">Rundy: <span id="whatif-rounds">0</span></div>
                            <button class="analysis-btn reset-btn" id="btn-reset-whatif" style="margin-top: 10px;">‚Ü∫ Resetuj</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="screen rules-screen" id="rules-screen">
            <div class="rules-section">
                <h2>‚óà 1. Cel Gry</h2>
                <div class="highlight-box">
                    <p><strong>Zamatuj wrogiego Nexusa (‚óÜ)!</strong></p>
                    <p>Mat = Nexus jest zablokowany (w szachu) i nie ma bezpiecznego pola do ucieczki.</p>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 2. Figury</h2>
                <div class="piece-showcase">
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚óÜ</div>
                        <div class="piece-card-info">
                            <h4>Nexus (Kr√≥l)</h4>
                            <p>1 krok/turƒô ‚Ä¢ Najwa≈ºniejsza figura ‚Ä¢ Nie mo≈ºe wej≈õƒá na zagro≈ºone pole</p>
                        </div>
                    </div>
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚úß</div>
                        <div class="piece-card-info">
                            <h4>Phantom (Kr√≥lowa)</h4>
                            <p>5 krok√≥w/turƒô ‚Ä¢ Wszystkie kierunki ‚Ä¢ Zbija NATYCHMIAST (bez blokady!)</p>
                        </div>
                    </div>
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚óé</div>
                        <div class="piece-card-info">
                            <h4>Sentinel (Wie≈ºa)</h4>
                            <p>4 kroki/turƒô ‚Ä¢ Tylko prosto (g√≥ra/d√≥≈Ç/lewo/prawo)</p>
                        </div>
                    </div>
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚óá</div>
                        <div class="piece-card-info">
                            <h4>Shade (Goniec)</h4>
                            <p>1 krok/turƒô ‚Ä¢ Tylko po skosie</p>
                        </div>
                    </div>
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚¨°</div>
                        <div class="piece-card-info">
                            <h4>Drifter (Skoczek)</h4>
                            <p>3 kroki/turƒô ‚Ä¢ Wszystkie kierunki</p>
                        </div>
                    </div>
                    <div class="piece-card">
                        <div class="piece-card-symbol">‚ñ≤</div>
                        <div class="piece-card-info">
                            <h4>Shard (Pionek)</h4>
                            <p>1 krok/turƒô ‚Ä¢ Tylko do przodu ‚Ä¢ Zbija po skosie ‚Ä¢ Promocja do Phantoma</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 3. Zasady Ruchu</h2>
                
                <h3>3.1. Kroki</h3>
                <p>Ka≈ºda figura ma okre≈õlonƒÖ liczbƒô <strong>krok√≥w na turƒô</strong>.</p>
                <p>Jeden krok = przesuniƒôcie o 1 pole w dowolnym dozwolonym kierunku.</p>
                <p>Mo≈ºesz u≈ºyƒá wszystkich krok√≥w lub zatrzymaƒá siƒô wcze≈õniej (kliknij "Potwierd≈∫").</p>
                
                <h3>3.2. Limit skos√≥w</h3>
                <div class="warning-box">
                    <p><strong>Maksymalnie 1 krok po skosie na turƒô!</strong></p>
                    <p>Nawet je≈õli masz 5 krok√≥w, tylko 1 mo≈ºe byƒá sko≈õny.</p>
                </div>
                
                <h3>3.3. Blokowanie drogi</h3>
                <p>Figury nie mogƒÖ przechodziƒá przez inne figury.</p>
                <p>Nie mo≈ºesz wej≈õƒá na pole zajƒôte przez w≈ÇasnƒÖ figurƒô.</p>
            </div>

            <div class="rules-section">
                <h2>‚óà 4. System Ataku i Zbijania</h2>
                
                <h3>4.1. Atak (ostatni krok)</h3>
                <div class="highlight-box">
                    <p>Mo≈ºesz zaatakowaƒá wroga <strong>TYLKO jako ostatni krok</strong> swojego ruchu.</p>
                    <p>Przyk≈Çad: Phantom (5 krok√≥w) ‚Üí krok 1 ‚Üí krok 2 ‚Üí krok 3 ‚Üí krok 4 ‚Üí <strong>krok 5 na wroga = ATAK</strong></p>
                    <p>NIE mo≈ºesz zaatakowaƒá w ≈õrodku ruchu i kontynuowaƒá!</p>
                </div>
                
                <h3>4.2. Blokada (nie natychmiastowe zbicie)</h3>
                <p>Gdy atakujesz figurƒô (poza Phantomem), NIE zbijasz jej od razu!</p>
                <p>Tworzy siƒô <strong>blokada</strong> - ofiara ma czas na ucieczkƒô:</p>
                <div class="warning-box">
                    <p>‚Ä¢ <strong>Zwyk≈Çe figury:</strong> 2 tury na ucieczkƒô</p>
                    <p>‚Ä¢ <strong>Nexus (kr√≥l):</strong> tylko 1 tura na ucieczkƒô!</p>
                </div>
                <p>Je≈õli ofiara nie ucieknie w czasie, zostaje zbita.</p>
                
                <h3>4.3. Zamro≈ºony atakujƒÖcy</h3>
                <div class="warning-box">
                    <p>Figura kt√≥ra atakuje jest <strong>ZAMRO≈ªONA</strong> - nie mo≈ºe siƒô ruszyƒá dop√≥ki:</p>
                    <p>‚Ä¢ Ofiara ucieknie (blokada znika), LUB</p>
                    <p>‚Ä¢ Ofiara zostanie zbita (atakujƒÖcy wchodzi na jej pole)</p>
                </div>
                
                <h3>4.4. Phantom - wyjƒÖtek!</h3>
                <div class="highlight-box">
                    <p><strong>Phantom (‚úß) zbija NATYCHMIAST</strong> - bez blokady!</p>
                    <p>Jedyna figura kt√≥ra dzia≈Ça jak w normalnych szachach.</p>
                </div>
                
                <h3>4.5. Podw√≥jny atak</h3>
                <p>Je≈õli figura jest atakowana przez <strong>2+ figury jednocze≈õnie</strong>:</p>
                <div class="warning-box">
                    <p>‚Üí <strong>Natychmiastowe zbicie!</strong> Ofiara nie ma czasu na ucieczkƒô.</p>
                    <p>‚Üí Pierwszy atakujƒÖcy wchodzi na miejsce ofiary.</p>
                    <p>‚Üí Podw√≥jny atak na Nexusa = <strong>NATYCHMIASTOWY MAT!</strong></p>
                </div>
                
                <h3>4.6. ≈Åa≈Ñcuch zbiƒá (atak na atakujƒÖcego)</h3>
                <div class="highlight-box">
                    <p>Gdy zaatakujesz figurƒô kt√≥ra <strong>sama kogo≈õ atakuje</strong> (jest zamro≈ºona w blokadzie):</p>
                    <p>‚Üí AtakujƒÖcy <strong>natychmiast zbija</strong> swojƒÖ ofiarƒô i wchodzi na jej pole</p>
                    <p>‚Üí Ty zajmujesz <strong>miejsce atakujƒÖcego</strong></p>
                    <p>Przyk≈Çad: Tw√≥j Drifter atakuje wrogiego Sentinela kt√≥ry blokuje Twojego pionka ‚Üí Sentinel zbija pionka, Drifter zajmuje miejsce Sentinela!</p>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 5. Nexus - Zasady Specjalne</h2>
                
                <h3>5.1. Szach</h3>
                <p>Gdy Tw√≥j Nexus jest zablokowany (atakowany), jeste≈õ w <strong>SZACHU</strong>.</p>
                <p>Nexus pulsuje na czerwono. <strong>MUSISZ</strong> uciec - nie mo≈ºesz ruszyƒá innƒÖ figurƒÖ!</p>
                
                <h3>5.2. Bezpieczne pola</h3>
                <div class="warning-box">
                    <p>Nexus <strong>NIE MO≈ªE</strong> wej≈õƒá na pole zagro≈ºone przez wroga!</p>
                    <p>Pole jest zagro≈ºone je≈õli wr√≥g mo≈ºe na nie dotrzeƒá jako ostatni krok ruchu.</p>
                </div>
                
                <h3>5.3. Mat</h3>
                <p>Mat = Nexus w szachu + brak bezpiecznych p√≥l do ucieczki.</p>
                <p><strong>Koniec gry - wygrywa atakujƒÖcy!</strong></p>
            </div>

            <div class="rules-section">
                <h2>‚óà 6. Figura Zagro≈ºona</h2>
                <div class="warning-box">
                    <p><strong>WA≈ªNA ZASADA:</strong></p>
                    <p>Figura kt√≥ra jest <strong>zagro≈ºona</strong> (wr√≥g mo≈ºe jƒÖ zaatakowaƒá w nastƒôpnej turze) <strong>NIE MO≈ªE atakowaƒá Nexusa!</strong></p>
                    <p>Musisz najpierw siƒô wycofaƒá lub wyeliminowaƒá zagro≈ºenie.</p>
                    <p>Ta zasada dotyczy TYLKO atak√≥w na Nexusa - inne figury mo≈ºesz atakowaƒá normalnie.</p>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 7. Promocja Sharda</h2>
                <p>Gdy Shard (‚ñ≤) dotrze do ostatniego rzƒôdu, staje siƒô <strong>Phantomem (‚úß)</strong>!</p>
                <div class="highlight-box">
                    <p>‚Ä¢ Bia≈Çe: ostatni rzƒÖd = rzƒÖd 8 (g√≥ra)</p>
                    <p>‚Ä¢ Czarne: ostatni rzƒÖd = rzƒÖd 1 (d√≥≈Ç)</p>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 8. Warunki Remisu</h2>
                <div class="highlight-box">
                    <p><strong>Remis nastƒôpuje gdy:</strong></p>
                    <p>‚Ä¢ <strong>10 ruch√≥w bez ataku</strong> (ruchy Shard√≥w nie liczƒÖ siƒô)</p>
                    <p>‚Ä¢ <strong>Potr√≥jne powt√≥rzenie</strong> - ta sama figura na tym samym polu 3 razy</p>
                    <p>‚Ä¢ <strong>Akceptowana propozycja remisu</strong> (tryb online)</p>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 9. Ikony Oceny Ruch√≥w</h2>
                <div class="rules-icons-legend">
                    <div class="rules-icon-item"><span class="icon-item brilliant">!!</span> <strong>Brilliant</strong> ‚Äì genialny ruch</div>
                    <div class="rules-icon-item"><span class="icon-item great">!</span> <strong>Great</strong> ‚Äì ≈õwietny ruch</div>
                    <div class="rules-icon-item"><span class="icon-item good">‚úì</span> <strong>Good</strong> ‚Äì dobry ruch</div>
                    <div class="rules-icon-item"><span class="icon-item book">üìñ</span> <strong>Book</strong> ‚Äì neutralny</div>
                    <div class="rules-icon-item"><span class="icon-item inaccuracy">?!</span> <strong>Inaccuracy</strong> ‚Äì niedok≈Çadno≈õƒá</div>
                    <div class="rules-icon-item"><span class="icon-item mistake">?</span> <strong>Mistake</strong> ‚Äì b≈ÇƒÖd</div>
                    <div class="rules-icon-item"><span class="icon-item blunder">??</span> <strong>Blunder</strong> ‚Äì powa≈ºny b≈ÇƒÖd</div>
                </div>
            </div>

            <div class="rules-section">
                <h2>‚óà 10. Sterowanie</h2>
                <div class="highlight-box">
                    <p><strong>Klikniƒôcie figury:</strong> Wybierz figurƒô kt√≥rƒÖ chcesz ruszyƒá</p>
                    <p><strong>Klikniƒôcie zielonego pola:</strong> Dodaj krok do trasy (ruch wykona siƒô automatycznie gdy wykorzystasz wszystkie kroki lub zaatakujesz)</p>
                    <p><strong>Shift + przeciƒÖganie:</strong> Rysuj strza≈Çki analizy na planszy</p>
                    <p><strong>Prawy klik:</strong> Anuluj wyb√≥r figury</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal propozycji remisu -->
    <div class="draw-modal" id="draw-modal">
        <div class="draw-modal-content">
            <div class="draw-modal-text" id="draw-modal-text">Przeciwnik proponuje remis</div>
            <div class="draw-modal-buttons">
                <button class="draw-accept" id="draw-accept">‚úì Akceptuj</button>
                <button class="draw-decline" id="draw-decline">‚úó Odrzuƒá</button>
            </div>
            <div class="draw-modal-hint">Wykonanie ruchu automatycznie odrzuca propozycjƒô</div>
        </div>
    </div>
    
    <!-- Toast z odpowiedziƒÖ -->
    <div class="draw-toast" id="draw-toast"></div>
    
    <div class="modal-overlay" id="game-over-modal">
        <div class="modal">
            <h2 id="modal-title">Koniec Gry!</h2>
            <p id="modal-message">Bia≈Çe wygrywajƒÖ!</p>
            <div class="modal-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="modal-btn" id="new-game-btn">Nowa Gra</button>
                <button class="modal-btn" id="rematch-btn" style="display: none; background: linear-gradient(135deg, #00d9ff, #00ff88);">üîÑ Rewan≈º</button>
            </div>
            <p id="rematch-status" style="display: none; margin-top: 10px; font-size: 0.85rem; color: var(--accent-cyan);"></p>
        </div>
    </div>
    </div>
    </div>
    <script>
        const PIECES = {
            KING: { symbol: '‚óÜ', name: 'Nexus', moves: 1, type: 'king' },
            QUEEN: { symbol: '‚úß', name: 'Phantom', moves: 5, type: 'queen' },
            ROOK: { symbol: '‚óé', name: 'Sentinel', moves: 4, type: 'rook', straightOnly: true },
            BISHOP: { symbol: '‚óá', name: 'Shade', moves: 1, type: 'bishop', diagonalOnly: true },
            KNIGHT: { symbol: '‚¨°', name: 'Drifter', moves: 3, type: 'knight' },
            PAWN: { symbol: '‚ñ≤', name: 'Shard', moves: 1, type: 'pawn' }
        };
        const DIRECTIONS = {
            n: { dx: 0, dy: -1, diagonal: false, arrow: '‚Üë' },
            s: { dx: 0, dy: 1, diagonal: false, arrow: '‚Üì' },
            e: { dx: 1, dy: 0, diagonal: false, arrow: '‚Üí' },
            w: { dx: -1, dy: 0, diagonal: false, arrow: '‚Üê' },
            ne: { dx: 1, dy: -1, diagonal: true, arrow: '‚Üó' },
            nw: { dx: -1, dy: -1, diagonal: true, arrow: '‚Üñ' },
            se: { dx: 1, dy: 1, diagonal: true, arrow: '‚Üò' },
            sw: { dx: -1, dy: 1, diagonal: true, arrow: '‚Üô' }
        };
        let G = { board: [], currentPlayer: 'white', selectedPiece: null, plannedPath: [], usedDiagonal: false, gameMode: null, difficulty: 'medium', pendingCaptures: [], capturedByWhite: [], capturedByBlack: [], moveHistory: [], gameOver: false, inCheck: null, showZones: true, showEval: true, timeLimit: 0, increment: 0, whiteTime: 0, blackTime: 0, timerInterval: null, gameStates: [], currentStateIndex: -1, analyzing: false, whatIfMode: false, whatIfBaseIndex: -1, whatIfRounds: 0, whatIfBoard: null, whatIfPending: null, whatIfCapturedW: null, whatIfCapturedB: null, whatIfPlayer: null, isAnimating: false, sentinelShields: [], lastMove: null, evalBefore: 0, movesWithoutAttack: 0, doubleAttackPieces: [], piecePositionHistory: {} };
        
        // ===== SYSTEM TOOLTIP√ìW Z ZASADAMI =====
        var GAME_RULES = {
            threatened_king_attack: {
                title: '‚ö†Ô∏è Figura Zagro≈ºona',
                rule: '¬ß6.5',
                text: 'Figura kt√≥ra jest ZAGRO≈ªONA (przeciwnik mo≈ºe jƒÖ zaatakowaƒá w nastƒôpnej turze) NIE MO≈ªE atakowaƒá Nexusa!'
            },
            frozen_piece: {
                title: '‚ùÑÔ∏è Figura Zamro≈ºona',
                rule: '¬ß4.3',
                text: 'Figura kt√≥ra atakuje innƒÖ jest ZAMRO≈ªONA - nie mo≈ºe siƒô ruszyƒá dop√≥ki blokada trwa lub ofiara ucieknie.'
            },
            king_threatened_square: {
                title: 'üö´ Pole Zagro≈ºone',
                rule: '¬ß6.3',
                text: 'Nexus NIE MO≈ªE wej≈õƒá na pole zagro≈ºone przez wrogƒÖ figurƒô.'
            },
            no_diagonal_left: {
                title: '‚ÜóÔ∏è Limit Skosu',
                rule: '¬ß3.2',
                text: 'Mo≈ºesz wykonaƒá tylko 1 krok po skosie na turƒô. Ju≈º wykorzysta≈Çe≈õ ten ruch!'
            },
            piece_blocking: {
                title: 'üöß Blokada Drogi',
                rule: '¬ß3.1',
                text: 'Figury nie mogƒÖ przeskakiwaƒá przez inne figury (poza Drifterem).'
            },
            own_piece: {
                title: 'üë• W≈Çasna Figura',
                rule: '¬ß3.4',
                text: 'Nie mo≈ºesz wej≈õƒá na pole zajƒôte przez w≈ÇasnƒÖ figurƒô.'
            }
        };
        
        var ruleTooltip = null;
        var currentTooltipRule = null;
        var tooltipTimeout = null;
        
        function showRuleTooltip(x, y, ruleKey) {
            var rule = GAME_RULES[ruleKey];
            if (!rule) return;
            
            // Usu≈Ñ poprzedni tooltip
            hideRuleTooltip();
            currentTooltipRule = ruleKey;
            
            ruleTooltip = document.createElement('div');
            ruleTooltip.className = 'rule-tooltip';
            ruleTooltip.innerHTML = '<div class="rule-tooltip-title">' + rule.title + '</div>' +
                '<div class="rule-tooltip-ref">' + rule.rule + '</div>' +
                '<div class="rule-tooltip-text">' + rule.text + '</div>';
            document.body.appendChild(ruleTooltip);
            
            ruleTooltip.style.left = (x + 18) + 'px';
            ruleTooltip.style.top = (y + 18) + 'px';
            
            // Popraw pozycjƒô je≈õli wychodzi poza ekran
            setTimeout(function() {
                if (!ruleTooltip) return;
                var rect = ruleTooltip.getBoundingClientRect();
                if (rect.right > window.innerWidth - 10) {
                    ruleTooltip.style.left = (x - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight - 10) {
                    ruleTooltip.style.top = (y - rect.height - 10) + 'px';
                }
            }, 0);
            
            // Auto-ukryj po 3 sekundach
            tooltipTimeout = setTimeout(function() {
                hideRuleTooltip();
            }, 3000);
        }
        
        function hideRuleTooltip() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            if (ruleTooltip) {
                ruleTooltip.remove();
                ruleTooltip = null;
                currentTooltipRule = null;
            }
        }
        
        // Ukryj tooltip przy klikniƒôciu gdziekolwiek
        document.addEventListener('click', function(e) {
            if (ruleTooltip && !e.target.classList.contains('blocked-attack')) {
                hideRuleTooltip();
            }
        });
        
        // ===== SYSTEM MISTRZOSTW =====
        var TOURNAMENT_DATA = {
            world: {
                name: 'Mistrzostwa ≈öwiata',
                icon: 'üåç',
                eloRange: [7000, 9500],
                requiredElo: 6500,
                requiredWin: 'continental', // Trzeba wygraƒá kontynentalne
                players: [
                    { name: 'Viktor Antonov', country: 'üá∑üá∫', elo: 9487 },
                    { name: 'Magnus Lindberg', country: 'üá∏üá™', elo: 9231 },
                    { name: 'Chen Wei', country: 'üá®üá≥', elo: 8919 },
                    { name: 'Aleksandr Petrov', country: 'üá∑üá∫', elo: 8705 },
                    { name: 'Hans Mueller', country: 'üá©üá™', elo: 8488 },
                    { name: 'Rajesh Sharma', country: 'üáÆüá≥', elo: 8276 },
                    { name: 'James Wilson', country: 'üá∫üá∏', elo: 8061 },
                    { name: 'Kenji Nakamura', country: 'üáØüáµ', elo: 7845 },
                    { name: 'Carlos Garcia', country: 'üá™üá∏', elo: 7632 },
                    { name: 'Dmitri Volkov', country: 'üá∫üá¶', elo: 7518 },
                    { name: 'Pierre Dubois', country: 'üá´üá∑', elo: 7404 },
                    { name: 'Erik Johansson', country: 'üá≥üá¥', elo: 7291 },
                    { name: 'Luca Rossi', country: 'üáÆüáπ', elo: 7178 },
                    { name: 'Ahmed Hassan', country: 'üá™üá¨', elo: 7065 },
                    { name: 'Tomasz Kowalski', country: 'üáµüá±', elo: 6952 },
                    { name: 'David Smith', country: 'üá¨üáß', elo: 6838 }
                ]
            },
            continental: {
                name: 'Mistrzostwa Kontynentalne',
                icon: 'üåé',
                eloRange: [5500, 7500],
                requiredElo: 5000,
                requiredWin: 'national', // Trzeba wygraƒá krajowe
                players: [
                    { name: 'Adrian Ionescu', country: 'üá∑üá¥', elo: 7445 },
                    { name: 'Sergei Kuznetsov', country: 'üá∑üá∫', elo: 7228 },
                    { name: 'Marco Bianchi', country: 'üáÆüáπ', elo: 7012 },
                    { name: 'Stefan Horvat', country: 'üá≠üá∑', elo: 6795 },
                    { name: 'Andrei Popescu', country: 'üá∑üá¥', elo: 6578 },
                    { name: 'Pavel Novak', country: 'üá®üáø', elo: 6361 },
                    { name: 'Georg Fischer', country: 'üá¶üáπ', elo: 6244 },
                    { name: 'Mikael Andersson', country: 'üá∏üá™', elo: 6127 },
                    { name: 'Jan Kowalczyk', country: 'üáµüá±', elo: 6010 },
                    { name: 'Henrik Nielsen', country: 'üá©üá∞', elo: 5893 },
                    { name: 'Florian Weber', country: 'üá®üá≠', elo: 5776 },
                    { name: 'Marius Olsen', country: 'üá≥üá¥', elo: 5659 },
                    { name: 'Balazs Nagy', country: 'üá≠üá∫', elo: 5542 },
                    { name: 'Yuri Ivanov', country: 'üáßüá¨', elo: 5525 },
                    { name: 'Klaus Schmidt', country: 'üá©üá™', elo: 5508 },
                    { name: 'Peter Eriksson', country: 'üá´üáÆ', elo: 5491 }
                ]
            },
            national: {
                name: 'Mistrzostwa Krajowe',
                icon: 'üèõÔ∏è',
                eloRange: [4000, 6000],
                requiredElo: 3500,
                requiredWin: 'regional', // Trzeba wygraƒá regionalne
                players: [
                    { name: 'Krzysztof Wi≈õniewski', country: 'üáµüá±', elo: 5995 },
                    { name: 'Piotr Kowalski', country: 'üáµüá±', elo: 5768 },
                    { name: 'Micha≈Ç Nowak', country: 'üáµüá±', elo: 5541 },
                    { name: 'Adam W√≥jcik', country: 'üáµüá±', elo: 5314 },
                    { name: 'Jakub Kami≈Ñski', country: 'üáµüá±', elo: 5087 },
                    { name: 'Mateusz Lewandowski', country: 'üáµüá±', elo: 4860 },
                    { name: 'Bartosz Zieli≈Ñski', country: 'üáµüá±', elo: 4733 },
                    { name: '≈Åukasz Szyma≈Ñski', country: 'üáµüá±', elo: 4606 },
                    { name: 'Pawe≈Ç Wo≈∫niak', country: 'üáµüá±', elo: 4479 },
                    { name: 'Marcin DƒÖbrowski', country: 'üáµüá±', elo: 4352 },
                    { name: 'Tomasz Koz≈Çowski', country: 'üáµüá±', elo: 4225 },
                    { name: 'Kamil Jankowski', country: 'üáµüá±', elo: 4098 },
                    { name: 'Dawid Mazur', country: 'üáµüá±', elo: 4171 },
                    { name: 'Sebastian Krawczyk', country: 'üáµüá±', elo: 4044 },
                    { name: 'Rafa≈Ç Piotrowski', country: 'üáµüá±', elo: 4017 },
                    { name: 'Grzegorz Grabowski', country: 'üáµüá±', elo: 3990 }
                ]
            },
            regional: {
                name: 'Mistrzostwa Regionalne',
                icon: 'üèôÔ∏è',
                eloRange: [2500, 4500],
                requiredElo: 2000,
                requiredWin: 'club', // Trzeba wygraƒá klubowy
                players: [
                    { name: 'Artur Kaczmarek', country: 'üáµüá±', elo: 4485 },
                    { name: 'Robert Pawlak', country: 'üáµüá±', elo: 4248 },
                    { name: 'Wojciech Michalski', country: 'üáµüá±', elo: 4011 },
                    { name: 'Szymon Kr√≥l', country: 'üáµüá±', elo: 3774 },
                    { name: 'Maciej Adamski', country: 'üáµüá±', elo: 3537 },
                    { name: 'Daniel Walczak', country: 'üáµüá±', elo: 3300 },
                    { name: 'Patryk Sikora', country: 'üáµüá±', elo: 3163 },
                    { name: 'Damian Baran', country: 'üáµüá±', elo: 3026 },
                    { name: 'Karol Dudek', country: 'üáµüá±', elo: 2889 },
                    { name: 'Filip Sawicki', country: 'üáµüá±', elo: 2752 },
                    { name: 'Oskar G√≥rski', country: 'üáµüá±', elo: 2615 },
                    { name: 'Igor Rutkowski', country: 'üáµüá±', elo: 2678 },
                    { name: 'Emil Ostrowski', country: 'üáµüá±', elo: 2841 },
                    { name: 'Wiktor Chmielewski', country: 'üáµüá±', elo: 2704 },
                    { name: 'Kacper Jaworski', country: 'üáµüá±', elo: 2567 },
                    { name: 'Nikodem B≈Çaszczyk', country: 'üáµüá±', elo: 2530 }
                ]
            },
            club: {
                name: 'Turniej Klubowy',
                icon: '‚ôüÔ∏è',
                eloRange: [1000, 3000],
                requiredElo: 500,
                requiredWin: null, // Nie wymaga wygranej w innym turnieju
                players: [
                    { name: 'Tadeusz Kowal', country: 'üáµüá±', elo: 2985 },
                    { name: 'Zbigniew Nowicki', country: 'üáµüá±', elo: 2748 },
                    { name: 'Andrzej Malinowski', country: 'üáµüá±', elo: 2511 },
                    { name: 'Stanis≈Çaw Kucharski', country: 'üáµüá±', elo: 2274 },
                    { name: 'Henryk Witkowski', country: 'üáµüá±', elo: 2037 },
                    { name: 'W≈Çadys≈Çaw Stƒôpie≈Ñ', country: 'üáµüá±', elo: 1800 },
                    { name: 'Bogdan Wr√≥bel', country: 'üáµüá±', elo: 1663 },
                    { name: 'Zdzis≈Çaw Kubiak', country: 'üáµüá±', elo: 1526 },
                    { name: 'Jerzy Zawadzki', country: 'üáµüá±', elo: 1389 },
                    { name: 'Ryszard Kalinowski', country: 'üáµüá±', elo: 1252 },
                    { name: 'Kazimierz Sobczak', country: 'üáµüá±', elo: 1215 },
                    { name: 'Janusz Kwiatkowski', country: 'üáµüá±', elo: 1178 },
                    { name: 'Miros≈Çaw Czerwi≈Ñski', country: 'üáµüá±', elo: 1441 },
                    { name: 'Leszek Urba≈Ñski', country: 'üáµüá±', elo: 1304 },
                    { name: 'Eugeniusz Mr√≥z', country: 'üáµüá±', elo: 1167 },
                    { name: 'Czes≈Çaw Borkowski', country: 'üáµüá±', elo: 1030 }
                ]
            }
        };
        
        // Zapisane wygrane turnieje
        var wonTournaments = JSON.parse(localStorage.getItem('wonTournaments') || '{}');
        
        function isTournamentUnlocked(type) {
            var tournament = TOURNAMENT_DATA[type];
            var playerElo = parseInt(localStorage.getItem('arrowChessElo')) || 0;
            
            // Sprawd≈∫ wymagane ELO
            if (playerElo < tournament.requiredElo) {
                return { unlocked: false, reason: 'elo', required: tournament.requiredElo, current: playerElo };
            }
            
            // Sprawd≈∫ czy wygra≈Ç wymagany turniej
            if (tournament.requiredWin && !wonTournaments[tournament.requiredWin]) {
                var reqTournament = TOURNAMENT_DATA[tournament.requiredWin];
                return { unlocked: false, reason: 'win', requiredTournament: reqTournament.name };
            }
            
            return { unlocked: true };
        }
        
        function saveTournamentWin(type) {
            wonTournaments[type] = true;
            localStorage.setItem('wonTournaments', JSON.stringify(wonTournaments));
        }
        
        function updateChampionshipCards() {
            var types = ['club', 'regional', 'national', 'continental', 'world'];
            types.forEach(function(type) {
                var card = document.querySelector('.championship-card[data-championship="' + type + '"]');
                if (!card) return;
                
                var status = isTournamentUnlocked(type);
                var tournament = TOURNAMENT_DATA[type];
                
                // Usu≈Ñ stare klasy i elementy
                card.classList.remove('locked', 'unlocked');
                var oldReasons = card.querySelectorAll('.lock-reason');
                oldReasons.forEach(function(el) { el.remove(); });
                
                if (status.unlocked) {
                    // ODBLOKOWANY
                    if (wonTournaments[type]) {
                        card.classList.add('unlocked'); // Ju≈º wygrany - poka≈º ‚úì
                    }
                    // Je≈õli nie wygrany ale odblokowany - brak dodatkowej klasy
                } else {
                    // ZABLOKOWANY
                    card.classList.add('locked');
                    
                    // Dodaj pow√≥d blokady
                    var reasonEl = document.createElement('div');
                    reasonEl.className = 'lock-reason';
                    if (status.reason === 'elo') {
                        reasonEl.textContent = '‚ö†Ô∏è Wymagane: ' + status.required + ' ELO';
                    } else if (status.reason === 'win') {
                        reasonEl.textContent = '‚ö†Ô∏è Wygraj: ' + status.requiredTournament;
                    }
                    card.querySelector('.champ-info').appendChild(reasonEl);
                }
            });
        }
        
        var currentTournament = null;
        var currentTournamentType = null;
        var tournamentBracket = [];
        var tournamentRound = 0;
        var tournamentWins = 0;
        var tournamentLosses = 0;
        var currentOpponent = null;
        var championshipOvertimeCount = 0;
        
        function selectChampionship(type) {
            var unlockStatus = isTournamentUnlocked(type);
            
            if (!unlockStatus.unlocked) {
                var msg = '';
                if (unlockStatus.reason === 'elo') {
                    msg = 'Potrzebujesz minimum ' + unlockStatus.required + ' ELO!\n(Masz: ' + unlockStatus.current + ')';
                } else if (unlockStatus.reason === 'win') {
                    msg = 'Musisz najpierw wygraƒá:\n' + unlockStatus.requiredTournament + '!';
                }
                alert('üîí Turniej zablokowany!\n\n' + msg);
                return;
            }
            
            currentTournament = TOURNAMENT_DATA[type];
            currentTournamentType = type;
            generateBracket();
            showScreen('tournament');
            renderTournament();
        }
        
        function generateBracket() {
            // Losuj 8 graczy do turnieju (w tym gracza)
            var players = currentTournament.players.slice();
            shuffleArray(players);
            var selectedPlayers = players.slice(0, 7);
            
            // Gracz jest zawsze w turnieju
            var playerName = localStorage.getItem('playerName') || 'Ty';
            var playerElo = parseInt(localStorage.getItem('arrowChessElo')) || 1500;
            
            tournamentBracket = [
                { player: { name: playerName, country: 'üéÆ', elo: playerElo, isPlayer: true }, opponent: selectedPlayers[0], result: null },
                { player: selectedPlayers[1], opponent: selectedPlayers[2], result: 'pending' },
                { player: selectedPlayers[3], opponent: selectedPlayers[4], result: 'pending' },
                { player: selectedPlayers[5], opponent: selectedPlayers[6], result: 'pending' }
            ];
            
            tournamentRound = 1;
            tournamentWins = 0;
            tournamentLosses = 0;
        }
        
        function shuffleArray(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        
        function renderTournament() {
            var titleEl = document.getElementById('tournament-title');
            var roundEl = document.getElementById('tournament-round');
            var bracketEl = document.getElementById('tournament-bracket');
            var standingsEl = document.getElementById('standings-content');
            var playBtn = document.getElementById('play-match-btn');
            
            titleEl.textContent = currentTournament.icon + ' ' + currentTournament.name;
            
            var roundNames = ['', 'ƒÜwierƒáfina≈Çy', 'P√≥≈Çfina≈Çy', 'Fina≈Ç', 'Zako≈Ñczone'];
            roundEl.textContent = roundNames[tournamentRound] || 'Runda ' + tournamentRound;
            
            // Generuj bracket HTML
            var html = '';
            tournamentBracket.forEach(function(match, index) {
                var matchClass = 'bracket-match';
                var playerMatch = match.player.isPlayer || (match.opponent && match.opponent.isPlayer);
                
                if (playerMatch && match.result === null) {
                    matchClass += ' current';
                } else if (match.result === 'win' && playerMatch) {
                    matchClass += ' won';
                } else if (match.result === 'loss' && playerMatch) {
                    matchClass += ' lost';
                }
                
                var p1Class = match.player.isPlayer ? 'match-player you' : 'match-player';
                var p2Class = match.opponent ? (match.opponent.isPlayer ? 'match-player opponent you' : 'match-player opponent') : 'match-player opponent';
                
                html += '<div class="' + matchClass + '">';
                html += '<div class="' + p1Class + '">';
                html += '<div class="player-info">';
                html += '<div class="player-match-name">' + match.player.country + ' ' + match.player.name + '</div>';
                html += '<div class="player-match-elo">‚≠ê ' + match.player.elo + '</div>';
                html += '</div></div>';
                html += '<div class="match-vs">VS</div>';
                
                if (match.opponent) {
                    html += '<div class="' + p2Class + '">';
                    html += '<div class="player-info">';
                    html += '<div class="player-match-name">' + match.opponent.country + ' ' + match.opponent.name + '</div>';
                    html += '<div class="player-match-elo">‚≠ê ' + match.opponent.elo + '</div>';
                    html += '</div></div>';
                } else {
                    html += '<div class="match-player opponent"><div class="player-info"><div class="player-match-name">---</div></div></div>';
                }
                
                // Wynik
                if (match.result === 'win' && playerMatch) {
                    html += '<div class="match-result win">W</div>';
                } else if (match.result === 'loss' && playerMatch) {
                    html += '<div class="match-result loss">L</div>';
                } else if (match.result === 'p1win') {
                    html += '<div class="match-result" style="background: #888; color: white;">1</div>';
                } else if (match.result === 'p2win') {
                    html += '<div class="match-result" style="background: #888; color: white;">2</div>';
                } else if (match.result === 'pending') {
                    html += '<div class="match-result pending">?</div>';
                } else if (match.result === null && playerMatch) {
                    html += '<div class="match-result pending">‚ñ∂</div>';
                }
                
                html += '</div>';
            });
            
            bracketEl.innerHTML = html;
            standingsEl.textContent = 'Wygrane: ' + tournamentWins + ' | Przegrane: ' + tournamentLosses;
            
            // Sprawd≈∫ czy gracz ma mecz do rozegrania
            var playerMatch = tournamentBracket.find(function(m) {
                return (m.player.isPlayer || (m.opponent && m.opponent.isPlayer)) && m.result === null;
            });
            
            if (playerMatch) {
                playBtn.style.display = 'block';
                playBtn.textContent = '‚ñ∂ Graj przeciwko ' + (playerMatch.player.isPlayer ? playerMatch.opponent.name : playerMatch.player.name);
            } else {
                playBtn.style.display = 'none';
                
                // Sprawd≈∫ czy turniej zako≈Ñczony
                if (tournamentRound >= 4 || tournamentLosses > 0) {
                    if (tournamentWins >= 3) {
                        roundEl.textContent = 'üèÜ MISTRZ! Wygra≈Çe≈õ turniej!';
                        // Zapisz wygranƒÖ turnieju
                        if (currentTournamentType) {
                            saveTournamentWinWithDate(currentTournamentType);
                        }
                    } else {
                        roundEl.textContent = '‚ùå Koniec turnieju';
                        // Poka≈º przycisk obserwowania je≈õli sƒÖ jeszcze mecze
                        var remainingMatches = tournamentBracket.filter(function(m) {
                            return m.result === 'pending' || (m.result === null && !m.player.isPlayer && (!m.opponent || !m.opponent.isPlayer));
                        });
                        var watchBtn = document.getElementById('watch-tournament-btn');
                        if ((remainingMatches.length > 0 || tournamentRound < 4) && watchBtn) {
                            watchBtn.style.display = 'block';
                        }
                    }
                } else {
                    // Przejd≈∫ do nastƒôpnej rundy
                    advanceTournament();
                }
            }
            
            // Ukryj przycisk obserwowania je≈õli turniej zako≈Ñczony lub gracz wciƒÖ≈º gra
            var watchBtnHide = document.getElementById('watch-tournament-btn');
            if (watchBtnHide && (tournamentWins >= 3 || (playerMatch && !watchingTournament))) {
                watchBtnHide.style.display = 'none';
            }
        }
        
        function playCurrentMatch() {
            var playerMatch = tournamentBracket.find(function(m) {
                return (m.player.isPlayer || (m.opponent && m.opponent.isPlayer)) && m.result === null;
            });
            
            if (!playerMatch) return;
            
            currentOpponent = playerMatch.player.isPlayer ? playerMatch.opponent : playerMatch.player;
            
            // Ustaw trudno≈õƒá bota na podstawie ELO przeciwnika
            // Skala: easy <2000, medium 2000-5000, hard >5000
            var opponentElo = currentOpponent.elo;
            
            if (opponentElo >= 5000) {
                G.difficulty = 'hard';
            } else if (opponentElo >= 2000) {
                G.difficulty = 'medium';
            } else {
                G.difficulty = 'easy';
            }
            
            // Czas my≈õlenia ro≈õnie z ELO
            if (opponentElo >= 8000) {
                G.botThinkMultiplier = 3.0; // Legendy my≈õlƒÖ bardzo d≈Çugo
            } else if (opponentElo >= 6000) {
                G.botThinkMultiplier = 2.5;
            } else if (opponentElo >= 5000) {
                G.botThinkMultiplier = 2.0;
            } else if (opponentElo >= 4000) {
                G.botThinkMultiplier = 1.7;
            } else if (opponentElo >= 3000) {
                G.botThinkMultiplier = 1.4;
            } else if (opponentElo >= 2000) {
                G.botThinkMultiplier = 1.2;
            } else {
                G.botThinkMultiplier = 1.0;
            }
            
            // Losowo≈õƒá MALEJE z ELO (im wy≈ºsze ELO = mniej b≈Çƒôd√≥w)
            // Skala dostosowana do wy≈ºszych ELO
            if (opponentElo >= 8000) {
                G.botRandomness = 1; // Prawie perfekcyjny
            } else if (opponentElo >= 7000) {
                G.botRandomness = 2;
            } else if (opponentElo >= 6000) {
                G.botRandomness = 4;
            } else if (opponentElo >= 5000) {
                G.botRandomness = 8;
            } else if (opponentElo >= 4000) {
                G.botRandomness = 15;
            } else if (opponentElo >= 3000) {
                G.botRandomness = 30;
            } else if (opponentElo >= 2500) {
                G.botRandomness = 50;
            } else if (opponentElo >= 2000) {
                G.botRandomness = 70;
            } else if (opponentElo >= 1500) {
                G.botRandomness = 100;
            } else {
                G.botRandomness = 150;
            }
            
            // Poka≈º przeciwnika w UI
            var oppInfo = document.getElementById('opponent-info');
            var oppName = document.getElementById('opponent-name');
            var oppElo = document.getElementById('opponent-elo');
            if (oppInfo) oppInfo.style.display = 'flex';
            if (oppName) oppName.textContent = currentOpponent.country + ' ' + currentOpponent.name;
            if (oppElo) oppElo.textContent = '‚≠ê ' + currentOpponent.elo;
            
            G.gameMode = 'championship';
            G.timeLimit = 10; // 10 minut na mecz turniejowy
            G.increment = 5;
            
            initBoard();
            showScreen('game');
            startGame();
        }
        
        function advanceTournament() {
            // Symuluj wyniki innych mecz√≥w
            tournamentBracket.forEach(function(match) {
                if (match.result === 'pending') {
                    // Losowy wynik na podstawie ELO
                    var p1Elo = match.player.elo;
                    var p2Elo = match.opponent.elo;
                    var p1WinChance = 1 / (1 + Math.pow(10, (p2Elo - p1Elo) / 400));
                    match.result = Math.random() < p1WinChance ? 'p1win' : 'p2win';
                    match.winner = match.result === 'p1win' ? match.player : match.opponent;
                }
            });
            
            tournamentRound++;
            
            // Utw√≥rz nowe mecze z wygranych
            var winners = tournamentBracket.map(function(m) {
                if (m.result === 'win') return m.player.isPlayer ? m.player : m.opponent;
                if (m.result === 'p1win') return m.player;
                if (m.result === 'p2win') return m.opponent;
                return m.winner;
            }).filter(function(w) { return w; });
            
            if (winners.length >= 2) {
                var newBracket = [];
                for (var i = 0; i < winners.length; i += 2) {
                    if (i + 1 < winners.length) {
                        var isPlayerMatch = winners[i].isPlayer || winners[i+1].isPlayer;
                        newBracket.push({
                            player: winners[i],
                            opponent: winners[i+1],
                            result: isPlayerMatch ? null : 'pending'
                        });
                    }
                }
                tournamentBracket = newBracket;
            }
            
            renderTournament();
        }
        
        function finishTournamentMatch(playerWon) {
            var playerMatch = tournamentBracket.find(function(m) {
                return (m.player.isPlayer || (m.opponent && m.opponent.isPlayer)) && m.result === null;
            });
            
            if (playerMatch) {
                playerMatch.result = playerWon ? 'win' : 'loss';
                if (playerWon) {
                    tournamentWins++;
                    playerMatch.winner = playerMatch.player.isPlayer ? playerMatch.player : playerMatch.opponent;
                } else {
                    tournamentLosses++;
                    playerMatch.winner = playerMatch.player.isPlayer ? playerMatch.opponent : playerMatch.player;
                }
            }
            
            currentOpponent = null;
            var oppInfo = document.getElementById('opponent-info');
            if (oppInfo) oppInfo.style.display = 'none';
        }
        
        function exitTournament() {
            currentTournament = null;
            currentTournamentType = null;
            tournamentBracket = [];
            watchingTournament = false;
            var watchBtn = document.getElementById('watch-tournament-btn');
            if (watchBtn) watchBtn.style.display = 'none';
            // Ukryj championship-select
            var champSelect = document.getElementById('championship-select');
            if (champSelect) champSelect.style.display = 'none';
            showScreen('menu');
        }
        
        // ===== GABLOTA PUCHAR√ìW =====
        var TROPHY_DATA = {
            club: { icon: 'ü•â', name: 'Mistrz Klubu', tier: 1 },
            regional: { icon: 'ü•à', name: 'Mistrz Regionu', tier: 2 },
            national: { icon: 'ü•á', name: 'Mistrz Kraju', tier: 3 },
            continental: { icon: 'üèÜ', name: 'Mistrz Kontynentu', tier: 4 },
            world: { icon: 'üëë', name: 'Mistrz ≈öwiata', tier: 5 }
        };
        
        function updateTrophyCount() {
            var count = Object.keys(wonTournaments || {}).filter(function(k) { return wonTournaments[k]; }).length;
            var el = document.getElementById('trophy-count');
            if (el) el.textContent = count;
        }
        
        function showTrophyCabinet(opponentTrophies) {
            var trophies = opponentTrophies || wonTournaments || {};
            var isOpponent = !!opponentTrophies;
            
            var titleEl = document.getElementById('trophy-modal-title');
            if (titleEl) titleEl.textContent = isOpponent ? 'üèÜ Puchary Przeciwnika' : 'üèÜ Twoja Gablota';
            
            var grid = document.getElementById('trophy-grid');
            if (!grid) return;
            
            var html = '';
            
            var types = ['club', 'regional', 'national', 'continental', 'world'];
            types.forEach(function(type) {
                var trophy = TROPHY_DATA[type];
                var earned = trophies[type];
                var itemClass = earned ? 'trophy-item earned' : 'trophy-item locked';
                
                html += '<div class="' + itemClass + '">';
                html += '<div class="trophy-icon">' + trophy.icon + '</div>';
                html += '<div class="trophy-name">' + trophy.name + '</div>';
                if (earned) {
                    var date = typeof earned === 'string' ? earned : 'Zdobyty!';
                    html += '<div class="trophy-date">' + date + '</div>';
                } else {
                    html += '<div class="trophy-date">üîí Niezdobyty</div>';
                }
                html += '</div>';
            });
            
            grid.innerHTML = html;
            var modal = document.getElementById('trophy-modal');
            if (modal) modal.classList.add('active');
        }
        
        function closeTrophyCabinet() {
            var modal = document.getElementById('trophy-modal');
            if (modal) modal.classList.remove('active');
        }
        
        var opponentTrophiesData = null;
        
        function showOpponentTrophies() {
            if (opponentTrophiesData) {
                showTrophyCabinet(opponentTrophiesData);
            }
        }
        
        function setOpponentTrophies(trophies) {
            opponentTrophiesData = trophies || {};
            var btn = document.getElementById('opponent-trophies-btn');
            if (btn) {
                var count = Object.keys(opponentTrophiesData).filter(function(k) { return opponentTrophiesData[k]; }).length;
                btn.style.display = count > 0 ? 'inline-block' : 'none';
                btn.textContent = 'üèÜ ' + count;
            }
        }
        
        function saveTournamentWinWithDate(type) {
            var date = new Date().toLocaleDateString('pl-PL');
            wonTournaments[type] = date;
            localStorage.setItem('wonTournaments', JSON.stringify(wonTournaments));
            updateTrophyCount();
        }
        
        // ===== OBSERWOWANIE TURNIEJU =====
        var watchingTournament = false;
        
        function watchTournament() {
            watchingTournament = true;
            simulateRemainingMatches();
        }
        
        function simulateRemainingMatches() {
            // Symuluj wszystkie pozosta≈Çe mecze z animacjƒÖ
            var pendingMatches = tournamentBracket.filter(function(m) {
                return m.result === 'pending' || m.result === null;
            });
            
            if (pendingMatches.length === 0) {
                // Sprawd≈∫ czy przej≈õƒá do nastƒôpnej rundy
                if (tournamentRound < 4) {
                    advanceTournament();
                    setTimeout(function() {
                        if (watchingTournament) simulateRemainingMatches();
                    }, 1500);
                } else {
                    watchingTournament = false;
                    renderTournament();
                }
                return;
            }
            
            // Symuluj pierwszy pending mecz
            var match = pendingMatches[0];
            simulateSingleMatch(match, function() {
                renderTournament();
                setTimeout(function() {
                    if (watchingTournament) simulateRemainingMatches();
                }, 1000);
            });
        }
        
        function simulateSingleMatch(match, callback) {
            // Oblicz szanse na podstawie ELO
            var p1Elo = match.player.elo;
            var p2Elo = match.opponent.elo;
            var p1WinChance = 1 / (1 + Math.pow(10, (p2Elo - p1Elo) / 400));
            
            // Losuj wynik
            var p1Wins = Math.random() < p1WinChance;
            
            match.result = p1Wins ? 'p1win' : 'p2win';
            match.winner = p1Wins ? match.player : match.opponent;
            
            if (callback) callback();
        }
        
        
        // ===== SYSTEM D≈πWIƒòK√ìW (jak chess.com) =====
        var audioContext = null;
        var soundEnabled = true;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(type) {
            if (!soundEnabled) return;
            try {
                initAudio();
                var osc = audioContext.createOscillator();
                var gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                var now = audioContext.currentTime;
                
                switch(type) {
                    case 'move':
                        // Kr√≥tki "klik" - ruch figury
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;
                        
                    case 'capture':
                        // G≈Çƒôbszy d≈∫wiƒôk zbicia
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                        gain.gain.setValueAtTime(0.4, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                        
                    case 'check':
                        // Ostrzegawczy d≈∫wiƒôk szacha
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.setValueAtTime(600, now + 0.1);
                        osc.frequency.setValueAtTime(800, now + 0.2);
                        gain.gain.setValueAtTime(0.25, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                        
                    case 'castle':
                        // Podw√≥jny klik (roszada / tarcza)
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(500, now);
                        osc.frequency.setValueAtTime(700, now + 0.08);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.setValueAtTime(0.3, now + 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.16);
                        osc.start(now);
                        osc.stop(now + 0.16);
                        break;
                        
                    case 'promote':
                        // Triumfalny d≈∫wiƒôk promocji
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.25);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                        osc.start(now);
                        osc.stop(now + 0.35);
                        break;
                        
                    case 'illegal':
                        // B≈ÇƒÖd - nielegalny ruch
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.setValueAtTime(150, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;
                        
                    case 'select':
                        // Zaznaczenie figury
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(500, now);
                        osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        osc.start(now);
                        osc.stop(now + 0.08);
                        break;
                        
                    case 'gameEnd':
                        // Koniec gry
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.setValueAtTime(500, now + 0.15);
                        osc.frequency.setValueAtTime(300, now + 0.3);
                        osc.frequency.setValueAtTime(400, now + 0.45);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                        osc.start(now);
                        osc.stop(now + 0.6);
                        break;
                        
                    case 'notify':
                        // Powiadomienie (propozycja remisu itp)
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(700, now);
                        osc.frequency.setValueAtTime(900, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                        
                    case 'lowTime':
                        // Ostrze≈ºenie o niskim czasie
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(1000, now);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;
                }
            } catch(e) {
                console.log('Audio error:', e);
            }
        }
        
        // Tarcza Sentinela - specjalna figura tworzona przez dwie wie≈ºe w linii
        const SENTINEL_GUARDIAN = { symbol: '‚äï', name: 'Stra≈ºnik', moves: 4, type: 'guardian', straightOnly: true };
        
        // Sprawd≈∫ czy dwie wie≈ºe tworzƒÖ Tarczƒô Sentinela
        function checkSentinelShields() {
            G.sentinelShields = [];
            
            // Znajd≈∫ wszystkie wie≈ºe
            var rooks = [];
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var piece = G.board[y][x];
                    if (piece && piece.type === 'rook') {
                        rooks.push({x: x, y: y, color: piece.color});
                    }
                }
            }
            
            // Sprawd≈∫ pary wie≈º tego samego koloru
            for (var i = 0; i < rooks.length; i++) {
                for (var j = i + 1; j < rooks.length; j++) {
                    var r1 = rooks[i], r2 = rooks[j];
                    if (r1.color !== r2.color) continue;
                    
                    // Czy sƒÖ w tej samej linii (pionowej lub poziomej)?
                    if (r1.x === r2.x || r1.y === r2.y) {
                        // Sprawd≈∫ czy miƒôdzy nimi nie ma innych figur
                        var blocked = false;
                        var tiles = [];
                        
                        if (r1.x === r2.x) {
                            // Pionowa linia
                            var minY = Math.min(r1.y, r2.y);
                            var maxY = Math.max(r1.y, r2.y);
                            for (var y = minY + 1; y < maxY; y++) {
                                tiles.push({x: r1.x, y: y});
                                if (G.board[y][r1.x]) blocked = true;
                            }
                        } else {
                            // Pozioma linia
                            var minX = Math.min(r1.x, r2.x);
                            var maxX = Math.max(r1.x, r2.x);
                            for (var x = minX + 1; x < maxX; x++) {
                                tiles.push({x: x, y: r1.y});
                                if (G.board[r1.y][x]) blocked = true;
                            }
                        }
                        
                        if (!blocked && tiles.length > 0) {
                            // ≈örodek tarczy - tam pojawi siƒô Stra≈ºnik
                            var midIndex = Math.floor(tiles.length / 2);
                            var guardianPos = tiles[midIndex];
                            
                            G.sentinelShields.push({
                                color: r1.color,
                                rook1: {x: r1.x, y: r1.y},
                                rook2: {x: r2.x, y: r2.y},
                                tiles: tiles,
                                guardianX: guardianPos.x,
                                guardianY: guardianPos.y
                            });
                        }
                    }
                }
            }
        }
        
        // Sprawd≈∫ czy pole jest zablokowane przez Tarczƒô Sentinela (dla przeciwnika)
        function isBlockedByShield(x, y, movingColor) {
            for (var i = 0; i < G.sentinelShields.length; i++) {
                var shield = G.sentinelShields[i];
                // Tarcza blokuje tylko przeciwnika
                if (shield.color === movingColor) continue;
                
                for (var j = 0; j < shield.tiles.length; j++) {
                    if (shield.tiles[j].x === x && shield.tiles[j].y === y) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Profil i Online
        let playerProfile = localStorage.getItem('arrowChessProfile') || null;
        let playerElo = parseInt(localStorage.getItem('arrowChessElo')) || 0;
        let lobbyId = null;
        let isHost = false;
        let onlinePlayers = [];
        let peer = null;
        let peerConnection = null;
        let myColor = null; // 'white' lub 'black'
        let lobbyTimeLimit = 5; // Domy≈õlny czas w lobby
        let lobbyIncrement = 2; // Domy≈õlny increment w lobby
        let rematchRequested = false; // Czy zaproponowali≈õmy rewan≈º
        let rematchAccepted = false; // Czy przeciwnik zaakceptowa≈Ç rewan≈º
        
        // Inicjalizacja profilu
        function initProfile() {
            var display = document.getElementById('profile-display');
            if (playerProfile) {
                display.textContent = 'üë§ ' + playerProfile;
                display.classList.remove('no-profile');
            } else {
                display.textContent = '‚öô Ustaw profil';
                display.classList.add('no-profile');
            }
            updateEloDisplay();
        }
        
        function updateEloDisplay() {
            var eloDisplay = document.getElementById('elo-display');
            if (eloDisplay) {
                eloDisplay.textContent = '‚≠ê ' + playerElo + ' ELO';
            }
        }
        
        function addElo(amount, reason) {
            playerElo += amount;
            if (playerElo < 0) playerElo = 0;
            localStorage.setItem('arrowChessElo', playerElo);
            updateEloDisplay();
            
            // Poka≈º zmianƒô ELO
            showEloChange(amount, reason);
        }
        
        function showEloChange(amount, reason) {
            var toast = document.getElementById('elo-toast');
            if (!toast) return;
            
            var sign = amount >= 0 ? '+' : '';
            toast.textContent = sign + amount + ' ELO' + (reason ? ' (' + reason + ')' : '');
            toast.className = 'elo-toast active ' + (amount >= 0 ? 'positive' : 'negative');
            
            setTimeout(function() {
                toast.classList.remove('active');
            }, 2000);
        }
        
        // Oblicz ELO za ruch na podstawie ikony
        function calculateEloForMove(moveIcon, causedCheck, causedMate) {
            if (causedMate) return 75; // Mat = du≈ºy bonus
            if (causedCheck) return 20; // Szach
            
            var eloChanges = {
                'brilliant': 30,
                'great': 20,
                'good': 12,
                'book': 0,
                'inaccuracy': -8,
                'mistake': -18,
                'blunder': -30
            };
            
            return eloChanges[moveIcon] || 0;
        }
        
        function showProfileScreen() {
            showScreen('profile');
            document.getElementById('profile-name-input').value = playerProfile || '';
        }
        
        function saveProfile() {
            var name = document.getElementById('profile-name-input').value.trim();
            if (name.length < 2) {
                alert('Nazwa musi mieƒá minimum 2 znaki!');
                return;
            }
            playerProfile = name;
            localStorage.setItem('arrowChessProfile', name);
            initProfile();
            
            // Je≈õli czeka≈Ço lobby do do≈ÇƒÖczenia
            if (window.pendingLobby) {
                var lobbyToJoin = window.pendingLobby;
                window.pendingLobby = null;
                joinLobby(lobbyToJoin);
            } else {
                showScreen('menu');
            }
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            var screen = document.getElementById(screenId + '-screen');
            if (screen) screen.classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            var navBtn = document.querySelector('[data-screen="' + screenId + '"]');
            if (navBtn) navBtn.classList.add('active');
        }
        
        // Online / Lobby z PeerJS
        function createLobby() {
            if (!playerProfile) {
                showProfileScreen();
                return;
            }
            
            // Poka≈º lobby od razu z info o ≈ÇƒÖczeniu
            isHost = true;
            myColor = 'white';
            onlinePlayers = [{ name: playerProfile, isHost: true }];
            showScreen('lobby');
            document.getElementById('waiting-text').textContent = '≈ÅƒÖczenie z serwerem...';
            
            // Generuj proste ID (tylko ma≈Çe litery i cyfry)
            var randomPart = '';
            var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            for (var i = 0; i < 8; i++) {
                randomPart += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            lobbyId = 'chess' + randomPart;
            
            // Poka≈º link od razu
            updateLobbyUI();
            
            // Tw√≥rz peer jako host
            peer = new Peer(lobbyId, {
                debug: 2
            });
            
            peer.on('open', function(id) {
                console.log('Host peer otwarty:', id);
                lobbyId = id; // U≈ºyj rzeczywistego ID
                updateLobbyUI();
            });
            
            peer.on('connection', function(conn) {
                console.log('Kto≈õ siƒô ≈ÇƒÖczy!');
                peerConnection = conn;
                
                conn.on('open', function() {
                    console.log('Po≈ÇƒÖczenie otwarte');
                });
                
                conn.on('data', function(data) {
                    handlePeerData(data);
                });
                
                conn.on('close', function() {
                    console.log('Go≈õƒá roz≈ÇƒÖczony');
                    onlinePlayers = [{ name: playerProfile, isHost: true }];
                    if (!G.gameOver) updateLobbyUI();
                });
                
                conn.on('error', function(err) {
                    console.error('Connection error:', err);
                });
            });
            
            peer.on('error', function(err) {
                console.error('Peer error:', err);
                if (err.type === 'unavailable-id') {
                    // ID zajƒôte - spr√≥buj z nowym
                    peer.destroy();
                    setTimeout(createLobby, 500);
                } else {
                    document.getElementById('waiting-text').textContent = 'B≈ÇƒÖd: ' + err.type;
                }
            });
            
            peer.on('disconnected', function() {
                console.log('Peer disconnected, reconnecting...');
                peer.reconnect();
            });
        }
        
        function updateLobbyUI() {
            var linkEl = document.getElementById('lobby-link');
            var fullUrl = window.location.origin + window.location.pathname + '?lobby=' + lobbyId;
            linkEl.textContent = fullUrl;
            linkEl.href = fullUrl;
            
            // Poka≈º czy jeste≈õ hostem czy go≈õciem
            var lobbyTitle = document.querySelector('.lobby-box h2');
            if (isHost) {
                lobbyTitle.textContent = 'üåê Twoje Lobby (Host - Bia≈Çe)';
            } else {
                lobbyTitle.textContent = 'üåê Do≈ÇƒÖczono (Go≈õƒá - Czarne)';
            }
            
            var player1 = document.getElementById('player1-slot');
            var player1Name = document.getElementById('player1-name');
            player1Name.textContent = onlinePlayers[0] ? onlinePlayers[0].name + ' ‚ö™' : 'Oczekiwanie...';
            player1.classList.toggle('empty', !onlinePlayers[0]);
            
            var player2 = document.getElementById('player2-slot');
            var player2Name = player2.querySelector('.player-name');
            if (onlinePlayers[1]) {
                player2Name.textContent = onlinePlayers[1].name + ' ‚ö´';
                player2.classList.remove('empty');
                player2.querySelector('.player-status').textContent = '‚úì Po≈ÇƒÖczony';
            } else {
                player2Name.textContent = 'Oczekiwanie...';
                player2.classList.add('empty');
                player2.querySelector('.player-status').textContent = '‚è≥';
            }
            
            var playersHeader = document.querySelector('.lobby-players h3');
            playersHeader.textContent = 'Gracze (' + onlinePlayers.length + '/2)';
            
            var startBtn = document.getElementById('start-online-btn');
            var waitingText = document.getElementById('waiting-text');
            var lobbySettings = document.getElementById('lobby-settings');
            var lobbySettingsDisplay = document.getElementById('lobby-settings-display');
            
            // Host widzi przyciski wyboru, go≈õƒá widzi tylko info
            if (isHost) {
                lobbySettings.style.display = 'block';
                lobbySettingsDisplay.style.display = 'none';
            } else {
                lobbySettings.style.display = 'none';
                lobbySettingsDisplay.style.display = 'block';
            }
            
            if (!isHost) {
                startBtn.style.display = 'none';
                if (onlinePlayers.length >= 2) {
                    waitingText.textContent = 'Czekam a≈º Host rozpocznie grƒô...';
                    waitingText.style.color = 'var(--accent-cyan)';
                } else {
                    waitingText.textContent = '≈ÅƒÖczenie z Hostem...';
                    waitingText.style.color = 'var(--accent-gold)';
                }
            } else {
                startBtn.style.display = 'inline-block';
                if (onlinePlayers.length >= 2) {
                    startBtn.disabled = false;
                    waitingText.textContent = 'Gotowi do gry!';
                    waitingText.style.color = 'var(--accent-cyan)';
                } else {
                    startBtn.disabled = true;
                    waitingText.textContent = 'Czekam na drugiego gracza...';
                    waitingText.style.color = 'var(--accent-gold)';
                }
            }
        }
        
        function copyLobbyLink() {
            var link = document.getElementById('lobby-link').textContent;
            navigator.clipboard.writeText(link).then(function() {
                var btn = document.querySelector('.lobby-link-copy');
                btn.textContent = '‚úì Skopiowano!';
                setTimeout(function() { btn.textContent = 'üìã Kopiuj link'; }, 2000);
            });
        }
        
        function leaveLobby() {
            if (peer) {
                peer.destroy();
                peer = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            lobbyId = null;
            isHost = false;
            onlinePlayers = [];
            myColor = null;
            G.gameMode = null;
            document.getElementById('opponent-info').style.display = 'none';
            showScreen('menu');
        }
        
        function startOnlineGame() {
            if (!isHost || onlinePlayers.length < 2) return;
            
            // Wy≈õlij info o starcie do go≈õcia z wybranymi ustawieniami
            sendPeerData({ type: 'start', timeLimit: lobbyTimeLimit, increment: lobbyIncrement });
            
            // Startuj grƒô lokalnie
            G.gameMode = 'online';
            G.timeLimit = lobbyTimeLimit;
            G.increment = lobbyIncrement;
            updateOpponentDisplay();
            resetGame();
            showScreen('game');
        }
        
        // Wy≈õwietl dane przeciwnika w trybie online
        function updateOpponentDisplay() {
            var opponentInfo = document.getElementById('opponent-info');
            if (G.gameMode === 'online' && onlinePlayers.length >= 2) {
                // Znajd≈∫ przeciwnika (nie nas)
                var opponent = onlinePlayers.find(function(p) { return p.name !== playerProfile; });
                if (opponent) {
                    document.getElementById('opponent-name').textContent = opponent.name;
                    document.getElementById('opponent-elo').textContent = '‚≠ê ' + (opponent.elo || 0);
                    opponentInfo.style.display = 'flex';
                }
            } else {
                opponentInfo.style.display = 'none';
            }
        }
        
        // Sprawdzanie URL przy starcie
        function checkLobbyUrl() {
            var params = new URLSearchParams(window.location.search);
            var lobbyParam = params.get('lobby');
            if (lobbyParam) {
                if (!playerProfile) {
                    showProfileScreen();
                    window.pendingLobby = lobbyParam;
                } else {
                    joinLobby(lobbyParam);
                }
            }
        }
        
        function joinLobby(id) {
            lobbyId = id;
            isHost = false;
            myColor = 'black';
            onlinePlayers = [{ name: '≈ÅƒÖczenie...', isHost: true }];
            
            showScreen('lobby');
            updateLobbyUI();
            document.getElementById('waiting-text').textContent = '≈ÅƒÖczenie z hostem...';
            
            // Po≈ÇƒÖcz siƒô z hostem
            peer = new Peer({
                debug: 2
            });
            
            peer.on('open', function(myId) {
                console.log('Moje peer ID:', myId);
                document.getElementById('waiting-text').textContent = 'NawiƒÖzywanie po≈ÇƒÖczenia...';
                
                // ≈ÅƒÖcz siƒô z hostem
                peerConnection = peer.connect(id, {
                    reliable: true
                });
                
                peerConnection.on('open', function() {
                    console.log('Po≈ÇƒÖczono z hostem!');
                    document.getElementById('waiting-text').textContent = 'Po≈ÇƒÖczono! Wysy≈Çanie danych...';
                    // Wy≈õlij swoje dane z ELO i pucharami
                    sendPeerData({ type: 'join', name: playerProfile, elo: playerElo, trophies: wonTournaments });
                });
                
                peerConnection.on('data', function(data) {
                    handlePeerData(data);
                });
                
                peerConnection.on('close', function() {
                    if (!G.gameOver) {
                        alert('Host roz≈ÇƒÖczony!');
                        leaveLobby();
                    }
                });
                
                peerConnection.on('error', function(err) {
                    console.error('Connection error:', err);
                    document.getElementById('waiting-text').textContent = 'B≈ÇƒÖd po≈ÇƒÖczenia!';
                });
            });
            
            peer.on('error', function(err) {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    document.getElementById('waiting-text').textContent = 'Host nie znaleziony!';
                    document.getElementById('waiting-text').style.color = 'var(--accent-magenta)';
                    setTimeout(function() {
                        if (confirm('Nie znaleziono hosta. Spr√≥bowaƒá ponownie?')) {
                            peer.destroy();
                            joinLobby(id);
                        } else {
                            leaveLobby();
                        }
                    }, 500);
                } else {
                    document.getElementById('waiting-text').textContent = 'B≈ÇƒÖd: ' + err.type;
                }
            });
            
            peer.on('disconnected', function() {
                console.log('Peer disconnected');
                if (!G.gameOver) {
                    peer.reconnect();
                }
            });
        }
        
        function sendPeerData(data) {
            if (peerConnection && peerConnection.open) {
                peerConnection.send(data);
            }
        }
        
        function handlePeerData(data) {
            console.log('Otrzymano dane:', data);
            
            switch (data.type) {
                case 'join':
                    // Go≈õƒá do≈ÇƒÖczy≈Ç (tylko host otrzymuje)
                    onlinePlayers = [
                        { name: playerProfile, isHost: true, elo: playerElo },
                        { name: data.name, isHost: false, elo: data.elo || 0 }
                    ];
                    // Zapisz puchary przeciwnika
                    setOpponentTrophies(data.trophies);
                    updateLobbyUI();
                    // Potwierd≈∫ do≈ÇƒÖczenie i wy≈õlij ustawienia + ELO + puchary
                    sendPeerData({ 
                        type: 'joined', 
                        hostName: playerProfile,
                        hostElo: playerElo,
                        hostTrophies: wonTournaments,
                        timeLimit: lobbyTimeLimit,
                        increment: lobbyIncrement
                    });
                    break;
                    
                case 'joined':
                    // Potwierdzenie od hosta (tylko go≈õƒá otrzymuje)
                    onlinePlayers = [
                        { name: data.hostName, isHost: true, elo: data.hostElo || 0 },
                        { name: playerProfile, isHost: false, elo: playerElo }
                    ];
                    // Zapisz puchary hosta
                    setOpponentTrophies(data.hostTrophies);
                    // Wy≈õwietl ustawienia hosta
                    var timeDisplay = document.getElementById('lobby-time-display');
                    var incDisplay = document.getElementById('lobby-inc-display');
                    timeDisplay.textContent = data.timeLimit > 0 ? data.timeLimit + ' min' : '‚àû';
                    incDisplay.textContent = '+' + data.increment + 's';
                    updateLobbyUI();
                    break;
                    
                case 'start':
                    // Host rozpoczƒÖ≈Ç grƒô
                    G.gameMode = 'online';
                    G.timeLimit = data.timeLimit;
                    G.increment = data.increment;
                    // Zapisz dane przeciwnika
                    updateOpponentDisplay();
                    resetGame();
                    showScreen('game');
                    break;
                    
                case 'move':
                    // Przeciwnik wykona≈Ç ruch
                    receiveOnlineMove(data);
                    break;
                    
                case 'draw_offer':
                    // Przeciwnik proponuje remis
                    showDrawOffer(data.playerName);
                    break;
                    
                case 'draw_response':
                    // Odpowied≈∫ na propozycjƒô remisu
                    handleDrawResponse(data.accepted, data.playerName);
                    break;
                    
                case 'resign':
                    // Przeciwnik siƒô podda≈Ç
                    handleOpponentResign(data.playerName);
                    break;
                    
                case 'rematch_request':
                    // Przeciwnik proponuje rewan≈º
                    handleRematchRequest();
                    break;
                    
                case 'rematch_accept':
                    // Przeciwnik zaakceptowa≈Ç rewan≈º
                    handleRematchAccept();
                    break;
                    
                case 'rematch_decline':
                    // Przeciwnik odrzuci≈Ç rewan≈º
                    handleRematchDecline();
                    break;
            }
        }
        
        // System remisu
        var pendingDrawOffer = false; // Czy czekamy na odpowied≈∫
        var receivedDrawOffer = false; // Czy otrzymali≈õmy propozycjƒô
        
        function showDrawOffer(fromPlayer) {
            receivedDrawOffer = true;
            var modal = document.getElementById('draw-modal');
            var text = document.getElementById('draw-modal-text');
            text.textContent = fromPlayer + ' proponuje remis';
            modal.classList.add('active');
            playSound('notify');
        }
        
        function acceptDraw() {
            receivedDrawOffer = false;
            document.getElementById('draw-modal').classList.remove('active');
            
            // Wy≈õlij akceptacjƒô
            sendPeerData({ type: 'draw_response', accepted: true, playerName: playerProfile });
            
            // Zako≈Ñcz grƒô remisem
            endGameDraw();
        }
        
        function declineDraw() {
            receivedDrawOffer = false;
            document.getElementById('draw-modal').classList.remove('active');
            
            // Wy≈õlij odrzucenie
            sendPeerData({ type: 'draw_response', accepted: false, playerName: playerProfile });
            
            // Poka≈º toast u nas
            showDrawToast('Odrzuci≈Çe≈õ remis', 'declined');
        }
        
        function offerDraw() {
            if (pendingDrawOffer || G.gameOver) return;
            
            // Mistrzostwa - bot decyduje czy przyjƒÖƒá remis
            if (G.gameMode === 'championship') {
                pendingDrawOffer = true;
                var drawBtn = document.getElementById('btn-offer-draw');
                if (drawBtn) drawBtn.disabled = true;
                
                showDrawToast('Propozycja remisu wys≈Çana...', 'sent');
                
                // Bot decyduje na podstawie oceny pozycji
                setTimeout(function() {
                    var eval = evaluatePosition('black');
                    // Bot przyjmuje remis je≈õli przegrywa lub pozycja r√≥wna
                    // Im wy≈ºsze ELO bota, tym mniej chƒôtnie przyjmuje remis gdy wygrywa
                    var acceptThreshold = currentOpponent ? (currentOpponent.elo / 100) : 20;
                    var botAccepts = eval < acceptThreshold;
                    
                    pendingDrawOffer = false;
                    if (drawBtn) drawBtn.disabled = false;
                    
                    if (botAccepts) {
                        showDrawToast(currentOpponent.name + ' zaakceptowa≈Ç remis!', 'accepted');
                        setTimeout(function() {
                            endGame(null, 'draw_agreed');
                        }, 1500);
                    } else {
                        showDrawToast(currentOpponent.name + ' odrzuci≈Ç remis', 'declined');
                    }
                }, 1500);
                return;
            }
            
            // Online
            if (G.gameMode !== 'online') return;
            
            pendingDrawOffer = true;
            var drawBtn2 = document.getElementById('btn-offer-draw');
            if (drawBtn2) drawBtn2.disabled = true;
            
            // Wy≈õlij propozycjƒô
            sendPeerData({ type: 'draw_offer', playerName: playerProfile });
            
            // Poka≈º toast
            showDrawToast('Propozycja remisu wys≈Çana...', 'sent');
        }
        
        function handleDrawResponse(accepted, fromPlayer) {
            pendingDrawOffer = false;
            document.getElementById('btn-offer-draw').disabled = false;
            
            if (accepted) {
                showDrawToast(fromPlayer + ' zaakceptowa≈Ç remis!', 'accepted');
                setTimeout(endGameDraw, 1500);
            } else {
                showDrawToast(fromPlayer + ' odrzuci≈Ç remis', 'declined');
            }
        }
        
        function showDrawToast(message, type) {
            var toast = document.getElementById('draw-toast');
            toast.textContent = message;
            toast.className = 'draw-toast active ' + type;
            
            setTimeout(function() {
                toast.classList.remove('active');
            }, 2500);
        }
        
        function endGameDraw() {
            G.gameOver = true;
            if (G.timerInterval) clearInterval(G.timerInterval);
            
            document.getElementById('modal-title').textContent = 'REMIS!';
            document.getElementById('modal-message').textContent = 'Gracze zgodzili siƒô na remis';
            document.getElementById('game-over-modal').classList.add('active');
        }
        
        function resignGame() {
            if (G.gameOver) return;
            
            if (confirm('Czy na pewno chcesz siƒô poddaƒá?')) {
                // Mistrzostwa - poddanie = przegrana
                if (G.gameMode === 'championship') {
                    endGame('black', 'poddanie');
                    return;
                }
                
                // Online
                if (G.gameMode === 'online') {
                    // Wy≈õlij info o poddaniu
                    sendPeerData({ type: 'resign', playerName: playerProfile });
                    
                    // Zako≈Ñcz grƒô - przegrywamy
                    var winner = myColor === 'white' ? 'black' : 'white';
                    endGame(winner, 'poddanie');
                }
            }
        }
        
        function handleOpponentResign(playerName) {
            showDrawToast(playerName + ' podda≈Ç siƒô!', 'accepted');
            setTimeout(function() {
                endGame(myColor, 'poddanie');
            }, 1000);
        }
        
        // Automatyczne odrzucenie remisu przy ruchu
        function autoDeclineDrawOnMove() {
            if (receivedDrawOffer) {
                receivedDrawOffer = false;
                document.getElementById('draw-modal').classList.remove('active');
                sendPeerData({ type: 'draw_response', accepted: false, playerName: playerProfile });
            }
        }
        
        function sendOnlineMove(startPos, endPos, path, isGuardian) {
            sendPeerData({
                type: 'move',
                startX: startPos.x,
                startY: startPos.y,
                endX: endPos.x,
                endY: endPos.y,
                path: path,
                isGuardian: isGuardian || false
            });
        }
        
        function receiveOnlineMove(data) {
            // Odtw√≥rz ruch przeciwnika
            G.selectedPiece = { x: data.startX, y: data.startY };
            G.plannedPath = data.path;
            
            // Sprawd≈∫ czy u≈ºyto skosu
            G.usedDiagonal = false;
            for (var i = 1; i < data.path.length; i++) {
                var prev = data.path[i-1], curr = data.path[i];
                if (Math.abs(curr.x - prev.x) === 1 && Math.abs(curr.y - prev.y) === 1) {
                    G.usedDiagonal = true;
                    break;
                }
            }
            
            var startPos = G.selectedPiece;
            var endPos = { x: data.endX, y: data.endY };
            var piece = G.board[startPos.y][startPos.x];
            var targetPiece = G.board[endPos.y][endPos.x];
            
            // Je≈õli to ruch Stra≈ºnika (isGuardian w danych)
            if (data.isGuardian) {
                // Znajd≈∫ tarczƒô i stw√≥rz stra≈ºnika
                for (var s = 0; s < G.sentinelShields.length; s++) {
                    var shield = G.sentinelShields[s];
                    if (shield.guardianX === data.startX && shield.guardianY === data.startY && shield.color !== myColor) {
                        piece = {
                            symbol: SENTINEL_GUARDIAN.symbol,
                            name: SENTINEL_GUARDIAN.name,
                            moves: SENTINEL_GUARDIAN.moves,
                            type: 'guardian',
                            straightOnly: true,
                            color: shield.color,
                            isGuardian: true,
                            shieldIndex: s
                        };
                        G.board[startPos.y][startPos.x] = piece;
                        break;
                    }
                }
            }
            
            if (!piece) return; // Brak figury
            
            // Atak - bez animacji
            if (targetPiece && targetPiece.color !== piece.color) {
                finishMove(startPos, endPos, piece, targetPiece, G.currentPlayer);
                return;
            }
            
            // Normalny ruch - z animacjƒÖ
            animateMove(startPos.x, startPos.y, endPos.x, endPos.y, piece, function() {
                finishMove(startPos, endPos, piece, targetPiece, G.currentPlayer);
            });
        }
        
        function canMakeMove() {
            // W trybie online - mo≈ºesz ruszyƒá tylko swoje figury
            if (G.gameMode === 'online') {
                return G.currentPlayer === myColor;
            }
            return true;
        }
        
        // Animacja ruchu figury
        function animateMove(startX, startY, endX, endY, piece, callback) {
            G.isAnimating = true;
            var board = document.getElementById('board');
            var boardRect = board.getBoundingClientRect();
            var tileSize = boardRect.width / 8;
            var flipped = shouldFlipBoard();
            
            // Pozycje na ekranie - je≈õli obr√≥cone, CSS ju≈º obraca wiƒôc wsp√≥≈Çrzƒôdne sƒÖ odwr√≥cone wizualnie
            var screenStartX = flipped ? (7 - startX) : startX;
            var screenStartY = flipped ? (7 - startY) : startY;
            var screenEndX = flipped ? (7 - endX) : endX;
            var screenEndY = flipped ? (7 - endY) : endY;
            
            // Schowaj figurƒô na planszy
            var tileIndex = startY * 8 + startX;
            var originalTile = board.querySelectorAll('.tile')[tileIndex];
            var originalPiece = originalTile ? originalTile.querySelector('.piece') : null;
            if (originalPiece) originalPiece.style.visibility = 'hidden';
            
            // Tworzymy animowany element
            var movingPiece = document.createElement('div');
            movingPiece.className = 'moving-piece ' + piece.color;
            movingPiece.innerHTML = '<span class="piece-symbol">' + piece.symbol + '</span>';
            movingPiece.style.position = 'fixed';
            movingPiece.style.width = tileSize + 'px';
            movingPiece.style.height = tileSize + 'px';
            movingPiece.style.display = 'flex';
            movingPiece.style.alignItems = 'center';
            movingPiece.style.justifyContent = 'center';
            movingPiece.style.left = (boardRect.left + screenStartX * tileSize) + 'px';
            movingPiece.style.top = (boardRect.top + screenStartY * tileSize) + 'px';
            movingPiece.style.transition = 'left 0.25s ease-out, top 0.25s ease-out';
            movingPiece.style.zIndex = '1000';
            document.body.appendChild(movingPiece);
            
            // Uruchamiamy animacjƒô
            requestAnimationFrame(function() {
                movingPiece.style.left = (boardRect.left + screenEndX * tileSize) + 'px';
                movingPiece.style.top = (boardRect.top + screenEndY * tileSize) + 'px';
            });
            
            // Po zako≈Ñczeniu animacji
            setTimeout(function() {
                movingPiece.remove();
                G.isAnimating = false;
                if (callback) callback();
            }, 280);
        }
        
        function initBoard() {
            G.board = Array(8).fill(null).map(() => Array(8).fill(null));
            const setup = [PIECES.ROOK, PIECES.KNIGHT, PIECES.BISHOP, PIECES.QUEEN, PIECES.KING, PIECES.BISHOP, PIECES.KNIGHT, PIECES.ROOK];
            for (let x = 0; x < 8; x++) {
                G.board[0][x] = { ...setup[x], color: 'black' };
                G.board[1][x] = { ...PIECES.PAWN, color: 'black' };
                G.board[6][x] = { ...PIECES.PAWN, color: 'white' };
                G.board[7][x] = { ...setup[x], color: 'white' };
            }
        }
        
        function resetGame() {
            initBoard();
            if (G.timerInterval) clearInterval(G.timerInterval);
            G.whiteTime = G.timeLimit * 60;
            G.blackTime = G.timeLimit * 60;
            G.gameStates = [];
            G.currentStateIndex = -1;
            G.analyzing = false;
            Object.assign(G, { currentPlayer: 'white', selectedPiece: null, plannedPath: [], usedDiagonal: false, pendingCaptures: [], capturedByWhite: [], capturedByBlack: [], moveHistory: [], gameOver: false, inCheck: null, movesWithoutAttack: 0, piecePositionHistory: {} });
            document.getElementById('move-log').innerHTML = '';
            document.getElementById('analysis-controls').style.display = 'none';
            
            // Poka≈º/ukryj przyciski online
            var onlineActions = document.getElementById('online-actions');
            if (onlineActions) {
                if (G.gameMode === 'online' || G.gameMode === 'championship') {
                    onlineActions.style.display = 'flex';
                    pendingDrawOffer = false;
                    receivedDrawOffer = false;
                    var drawBtn = document.getElementById('btn-offer-draw');
                    if (drawBtn) drawBtn.disabled = false;
                } else {
                    onlineActions.style.display = 'none';
                }
            }
            
            saveGameState('Start gry', null);
            updateTimerDisplay();
            if (G.timeLimit > 0) startTimer();
            renderBoard(); updateUI();
        }
        
        function saveGameState(description, color) {
            var state = {
                board: JSON.parse(JSON.stringify(G.board)),
                pendingCaptures: JSON.parse(JSON.stringify(G.pendingCaptures)),
                capturedByWhite: JSON.parse(JSON.stringify(G.capturedByWhite)),
                capturedByBlack: JSON.parse(JSON.stringify(G.capturedByBlack)),
                currentPlayer: G.currentPlayer,
                inCheck: G.inCheck,
                description: description,
                moveColor: color,
                whiteTime: G.whiteTime,
                blackTime: G.blackTime,
                moveNumber: G.gameStates.length
            };
            G.gameStates.push(state);
            G.currentStateIndex = G.gameStates.length - 1;
            updateMoveLogWithStates();
        }
        
        function updateMoveLogWithStates() {
            var log = document.getElementById('move-log');
            log.innerHTML = '';
            for (var i = G.gameStates.length - 1; i >= 0; i--) {
                var state = G.gameStates[i];
                var entry = document.createElement('div');
                entry.className = 'log-entry' + (state.moveColor ? ' ' + state.moveColor + '-move' : '') + (i === G.currentStateIndex && G.analyzing ? ' active-state' : '');
                entry.textContent = (state.moveNumber) + '. ' + state.description;
                entry.dataset.stateIndex = i;
                (function(idx) {
                    entry.addEventListener('click', function() {
                        if (G.gameOver || G.analyzing) {
                            loadGameState(idx);
                        }
                    });
                })(i);
                log.appendChild(entry);
            }
        }
        
        function loadGameState(index) {
            if (index < 0 || index >= G.gameStates.length) return;
            
            // Reset what-if mode gdy zmieniamy stan
            resetWhatIfMode();
            
            G.currentStateIndex = index;
            G.analyzing = true;
            var state = G.gameStates[index];
            G.board = JSON.parse(JSON.stringify(state.board));
            G.pendingCaptures = JSON.parse(JSON.stringify(state.pendingCaptures));
            G.capturedByWhite = JSON.parse(JSON.stringify(state.capturedByWhite));
            G.capturedByBlack = JSON.parse(JSON.stringify(state.capturedByBlack));
            G.currentPlayer = state.currentPlayer;
            G.inCheck = state.inCheck;
            
            document.getElementById('analysis-controls').style.display = 'block';
            document.getElementById('state-info').textContent = 'Ruch ' + state.moveNumber + '/' + (G.gameStates.length - 1) + ': ' + state.description;
            document.getElementById('whatif-panel').style.display = 'block';
            
            renderBoard();
            updateUI();
            updateMoveLogWithStates();
        }
        
        function navigateState(delta) {
            var newIndex = G.currentStateIndex + delta;
            if (newIndex >= 0 && newIndex < G.gameStates.length) {
                loadGameState(newIndex);
            }
        }
        
        function startWhatIfMode() {
            if (!G.analyzing) return;
            G.whatIfMode = true;
            G.whatIfBaseIndex = G.currentStateIndex;
            G.whatIfRounds = 0;
            // Zapisz stan bazowy
            G.whatIfBoard = JSON.parse(JSON.stringify(G.board));
            G.whatIfPending = JSON.parse(JSON.stringify(G.pendingCaptures));
            G.whatIfCapturedW = JSON.parse(JSON.stringify(G.capturedByWhite));
            G.whatIfCapturedB = JSON.parse(JSON.stringify(G.capturedByBlack));
            G.whatIfPlayer = G.currentPlayer;
            updateWhatIfDisplay();
        }
        
        function resetWhatIfMode() {
            if (G.whatIfMode && G.whatIfBoard) {
                G.board = JSON.parse(JSON.stringify(G.whatIfBoard));
                G.pendingCaptures = JSON.parse(JSON.stringify(G.whatIfPending));
                G.capturedByWhite = JSON.parse(JSON.stringify(G.whatIfCapturedW));
                G.capturedByBlack = JSON.parse(JSON.stringify(G.whatIfCapturedB));
                G.currentPlayer = G.whatIfPlayer;
            }
            G.whatIfMode = false;
            G.whatIfRounds = 0;
            G.whatIfBoard = null;
            G.whatIfPending = null;
            G.whatIfCapturedW = null;
            G.whatIfCapturedB = null;
            G.whatIfPlayer = null;
            G.selectedPiece = null;
            G.plannedPath = [];
            // Wyczy≈õƒá strza≈Çki analizy
            analysisArrows = [];
            analysisArrowStart = null;
            updateWhatIfDisplay();
            renderBoard();
            updateUI();
        }
        
        function updateWhatIfDisplay() {
            var counter = document.getElementById('whatif-rounds');
            if (counter) {
                counter.textContent = G.whatIfRounds;
            }
        }
        
        function executeWhatIfMove() {
            G.whatIfRounds++;
            updateWhatIfDisplay();
        }
        
        function formatTime(seconds) {
            if (seconds === Infinity || seconds <= 0 && G.timeLimit === 0) return '‚àû';
            var mins = Math.floor(seconds / 60);
            var secs = seconds % 60;
            return mins + ':' + (secs < 10 ? '0' : '') + secs;
        }
        
        function updateTimerDisplay() {
            var whiteEl = document.getElementById('white-time');
            var blackEl = document.getElementById('black-time');
            var whiteTimer = document.getElementById('white-timer');
            var blackTimer = document.getElementById('black-timer');
            
            if (G.timeLimit === 0) {
                whiteEl.textContent = '‚àû';
                blackEl.textContent = '‚àû';
                whiteTimer.classList.remove('active', 'low-time');
                blackTimer.classList.remove('active', 'low-time');
            } else {
                whiteEl.textContent = formatTime(G.whiteTime);
                blackEl.textContent = formatTime(G.blackTime);
                
                whiteTimer.classList.toggle('active', G.currentPlayer === 'white' && !G.gameOver);
                blackTimer.classList.toggle('active', G.currentPlayer === 'black' && !G.gameOver);
                whiteTimer.classList.toggle('low-time', G.whiteTime <= 30 && G.whiteTime > 0);
                blackTimer.classList.toggle('low-time', G.blackTime <= 30 && G.blackTime > 0);
            }
        }
        
        function startTimer() {
            if (G.timerInterval) clearInterval(G.timerInterval);
            var lastLowTimeSound = 0;
            G.timerInterval = setInterval(function() {
                if (G.gameOver) {
                    clearInterval(G.timerInterval);
                    return;
                }
                if (G.currentPlayer === 'white') {
                    G.whiteTime--;
                    // D≈∫wiƒôk niskiego czasu co 10 sekund
                    if (G.whiteTime <= 30 && G.whiteTime > 0 && G.whiteTime % 10 === 0 && G.whiteTime !== lastLowTimeSound) {
                        lastLowTimeSound = G.whiteTime;
                        playSound('lowTime');
                    }
                    if (G.whiteTime <= 0) {
                        G.whiteTime = 0;
                        clearInterval(G.timerInterval);
                        endGame('black', 'czas');
                    }
                } else {
                    G.blackTime--;
                    // D≈∫wiƒôk niskiego czasu co 10 sekund
                    if (G.blackTime <= 30 && G.blackTime > 0 && G.blackTime % 10 === 0 && G.blackTime !== lastLowTimeSound) {
                        lastLowTimeSound = G.blackTime;
                        playSound('lowTime');
                    }
                    if (G.blackTime <= 0) {
                        G.blackTime = 0;
                        clearInterval(G.timerInterval);
                        endGame('white', 'czas');
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }
        
        function addTimeIncrement() {
            if (G.timeLimit === 0) return;
            if (G.currentPlayer === 'white') {
                G.whiteTime += G.increment;
            } else {
                G.blackTime += G.increment;
            }
            updateTimerDisplay();
        }
        
        function getZoneClass(x, y) {
            if (!G.showZones) return '';
            if ((x === 3 || x === 4) && (y === 3 || y === 4)) return 'zone-center';
            if (x >= 4 && y >= 6) return 'zone-nexus-white';
            if (x <= 3 && y >= 6) return 'zone-phantom-white';
            if (x >= 4 && y <= 1) return 'zone-nexus-black';
            if (x <= 3 && y <= 1) return 'zone-phantom-black';
            return '';
        }
        
        function getArrowForMove(fromX, fromY, toX, toY) {
            var dx = toX - fromX, dy = toY - fromY;
            if (dx !== 0) dx = dx / Math.abs(dx);
            if (dy !== 0) dy = dy / Math.abs(dy);
            for (var key in DIRECTIONS) {
                var dir = DIRECTIONS[key];
                if (dir.dx === dx && dir.dy === dy) return dir.arrow;
            }
            return '‚¨§';
        }
        
        function isPieceLocked(x, y) {
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                if (G.pendingCaptures[i].targetX === x && G.pendingCaptures[i].targetY === y) return true;
            }
            return false;
        }
        
        function renderBoard() {
            var boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            var validMoves = getValidNextSteps();
            
            var pathArrows = {};
            for (var i = 1; i < G.plannedPath.length; i++) {
                var prev = G.plannedPath[i-1], curr = G.plannedPath[i];
                pathArrows[curr.x + ',' + curr.y] = getArrowForMove(prev.x, prev.y, curr.x, curr.y);
            }
            
            var lockArrows = {};
            G.pendingCaptures.forEach(function(cap) {
                lockArrows[cap.targetX + ',' + cap.targetY] = {
                    arrow: getArrowForMove(cap.attackerX, cap.attackerY, cap.targetX, cap.targetY),
                    color: cap.attackerColor, turns: cap.turnsLeft, attackerSymbol: cap.attackerSymbol
                };
            });
            
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var tile = document.createElement('div');
                    var baseClass = (x + y) % 2 === 0 ? 'light' : 'dark';
                    var zoneClass = getZoneClass(x, y);
                    tile.className = 'tile ' + baseClass + (zoneClass ? ' ' + zoneClass : '');
                    var piece = G.board[y][x];
                    
                    var pathKey = x + ',' + y;
                    if (pathArrows[pathKey]) {
                        var arrowEl = document.createElement('div');
                        arrowEl.className = 'path-arrow';
                        arrowEl.textContent = pathArrows[pathKey];
                        tile.appendChild(arrowEl);
                    }
                    
                    var lockKey = x + ',' + y;
                    if (lockArrows[lockKey]) {
                        var lockData = lockArrows[lockKey];
                        var lockEl = document.createElement('div');
                        lockEl.className = 'lock-arrow ' + lockData.color + '-lock';
                        lockEl.textContent = lockData.arrow;
                        tile.appendChild(lockEl);
                        var attackerEl = document.createElement('div');
                        attackerEl.className = 'attacker-pos ' + lockData.color + '-lock';
                        attackerEl.textContent = lockData.attackerSymbol;
                        tile.appendChild(attackerEl);
                        if (lockData.turns > 0) {
                            var timerEl = document.createElement('div');
                            timerEl.className = 'lock-timer ' + lockData.color + '-lock';
                            timerEl.textContent = lockData.turns;
                            tile.appendChild(timerEl);
                        }
                        tile.classList.add('threat');
                    }
                    
                    // Sprawd≈∫ czy pole jest czƒô≈õciƒÖ Tarczy Sentinela
                    var shieldInfo = getShieldAtTile(x, y);
                    if (shieldInfo) {
                        tile.classList.add('sentinel-shield');
                        tile.classList.add(shieldInfo.color + '-shield');
                        
                        // Je≈õli to miejsce Stra≈ºnika
                        if (shieldInfo.isGuardian && !piece) {
                            var guardianEl = document.createElement('div');
                            guardianEl.className = 'piece guardian ' + shieldInfo.color;
                            guardianEl.innerHTML = '<span class="piece-symbol">' + SENTINEL_GUARDIAN.symbol + '</span>';
                            tile.appendChild(guardianEl);
                        }
                    }
                    
                    if (piece) {
                        var pieceEl = document.createElement('div');
                        pieceEl.className = 'piece ' + piece.color;
                        if (isPieceAttacking(x, y)) {
                            pieceEl.classList.add('attacking');
                            pieceEl.classList.add('is-attacker'); // ≈ª√≥≈Çte pulsowanie dla atakujƒÖcego
                        }
                        // Sprawd≈∫ czy figura bra≈Ça udzia≈Ç w podw√≥jnym ataku
                        for (var da = 0; da < G.doubleAttackPieces.length; da++) {
                            if (G.doubleAttackPieces[da].x === x && G.doubleAttackPieces[da].y === y) {
                                pieceEl.classList.add('double-attacker');
                                break;
                            }
                        }
                        if (piece.frozenTurns && piece.frozenTurns > 0) {
                            pieceEl.classList.add('frozen');
                            // Dodaj licznik zamro≈ºenia
                            var frozenTimer = document.createElement('div');
                            frozenTimer.className = 'frozen-timer';
                            frozenTimer.textContent = '‚ùÑ' + piece.frozenTurns;
                            tile.appendChild(frozenTimer);
                        }
                        pieceEl.innerHTML = '<span class="piece-symbol">' + piece.symbol + '</span>';
                        tile.appendChild(pieceEl);
                        if (piece.type === 'king' && G.inCheck === piece.color) {
                            tile.classList.add('threatened-king');
                            // Czerwony b≈Çysk przy szachu, z≈Çoty przy macie
                            if (G.gameOver) {
                                pieceEl.classList.add('in-mate');
                            } else {
                                pieceEl.classList.add('in-check');
                            }
                        }
                        
                        // Ikona oceny ruchu (jak w chess.com) - tylko gdy showEval w≈ÇƒÖczone
                        if (G.showEval && G.lastMove && G.lastMove.endX === x && G.lastMove.endY === y && G.lastMove.icon) {
                            var iconEl = document.createElement('div');
                            iconEl.className = 'move-icon ' + G.lastMove.icon;
                            var iconText = {
                                'brilliant': '!!',
                                'great': '!',
                                'good': '‚úì',
                                'book': 'üìñ',
                                'inaccuracy': '?!',
                                'mistake': '?',
                                'blunder': '??'
                            };
                            iconEl.textContent = iconText[G.lastMove.icon] || '';
                            tile.appendChild(iconEl);
                        }
                    }
                    if (G.selectedPiece && G.selectedPiece.x === x && G.selectedPiece.y === y) tile.classList.add('selected');
                    var isValidMove = validMoves.some(function(m) { return m.x === x && m.y === y; });
                    if (isValidMove) tile.classList.add('valid-move');
                    
                    // Klikniƒôcie - wsp√≥≈Çrzƒôdne sƒÖ poprawne, CSS tylko obraca wizualnie
                    (function(tx, ty) { 
                        tile.addEventListener('click', function(event) { 
                            handleTileClick(tx, ty, event);
                        });
                        tile.addEventListener('mouseenter', function(e) {
                            handleTileHover(tx, ty);
                        });
                    })(x, y);
                    boardEl.appendChild(tile);
                }
            }
            
            // Renderuj strza≈Çki analizy (SVG overlay)
            renderAnalysisArrows();
        }
        
        function getShieldAtTile(x, y) {
            for (var i = 0; i < G.sentinelShields.length; i++) {
                var shield = G.sentinelShields[i];
                for (var j = 0; j < shield.tiles.length; j++) {
                    if (shield.tiles[j].x === x && shield.tiles[j].y === y) {
                        return {
                            color: shield.color,
                            isGuardian: (shield.guardianX === x && shield.guardianY === y)
                        };
                    }
                }
            }
            return null;
        }
        
        function getGuardianAt(x, y) {
            for (var i = 0; i < G.sentinelShields.length; i++) {
                var shield = G.sentinelShields[i];
                if (shield.guardianX === x && shield.guardianY === y) {
                    return {
                        color: shield.color,
                        shieldIndex: i
                    };
                }
            }
            return null;
        }
        
        function renderAnalysisArrows() {
            // Usu≈Ñ stary SVG
            var oldSvg = document.getElementById('analysis-arrows-svg');
            if (oldSvg) oldSvg.remove();
            
            if (analysisArrows.length === 0) return;
            
            var board = document.getElementById('board');
            var tiles = board.querySelectorAll('.tile');
            if (tiles.length === 0) return;
            
            var tileSize = tiles[0].offsetWidth;
            var boardSize = tileSize * 8;
            
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'analysis-arrows-svg';
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = boardSize + 'px';
            svg.style.height = boardSize + 'px';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '100';
            svg.setAttribute('viewBox', '0 0 ' + boardSize + ' ' + boardSize);
            
            // Definicje - gradient i strza≈Çka
            var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            // Gradient dla strza≈Çki
            var gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'arrowGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');
            var stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#ff9500');
            var stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#ff3300');
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            
            // Glow filter
            var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'arrowGlow');
            filter.setAttribute('x', '-50%');
            filter.setAttribute('y', '-50%');
            filter.setAttribute('width', '200%');
            filter.setAttribute('height', '200%');
            var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
            feGaussianBlur.setAttribute('stdDeviation', '4');
            feGaussianBlur.setAttribute('result', 'coloredBlur');
            filter.appendChild(feGaussianBlur);
            var feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
            var feMergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            feMergeNode1.setAttribute('in', 'coloredBlur');
            var feMergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            feMergeNode2.setAttribute('in', 'SourceGraphic');
            feMerge.appendChild(feMergeNode1);
            feMerge.appendChild(feMergeNode2);
            filter.appendChild(feMerge);
            defs.appendChild(filter);
            
            // Strza≈Çka marker
            var marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '14');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '12');
            marker.setAttribute('refY', '5');
            marker.setAttribute('orient', 'auto');
            var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 14 5, 0 10, 3 5');
            polygon.setAttribute('fill', '#ff3300');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            analysisArrows.forEach(function(arrow, index) {
                // Znajd≈∫ rzeczywiste pozycje kafelk√≥w
                var fromTile = tiles[arrow.fromY * 8 + arrow.fromX];
                var toTile = tiles[arrow.toY * 8 + arrow.toX];
                
                if (!fromTile || !toTile) return;
                
                // ≈örodek ka≈ºdego kafelka wzglƒôdem board
                var x1 = fromTile.offsetLeft + fromTile.offsetWidth / 2;
                var y1 = fromTile.offsetTop + fromTile.offsetHeight / 2;
                var x2 = toTile.offsetLeft + toTile.offsetWidth / 2;
                var y2 = toTile.offsetTop + toTile.offsetHeight / 2;
                
                // Po≈õwiata pod strza≈ÇkƒÖ
                var glowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                glowLine.setAttribute('x1', x1);
                glowLine.setAttribute('y1', y1);
                glowLine.setAttribute('x2', x2);
                glowLine.setAttribute('y2', y2);
                glowLine.setAttribute('stroke', '#ff6600');
                glowLine.setAttribute('stroke-width', '16');
                glowLine.setAttribute('stroke-opacity', '0.3');
                glowLine.setAttribute('stroke-linecap', 'round');
                svg.appendChild(glowLine);
                
                // G≈Ç√≥wna linia
                var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', 'url(#arrowGradient)');
                line.setAttribute('stroke-width', '8');
                line.setAttribute('stroke-opacity', '0.95');
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                line.setAttribute('filter', 'url(#arrowGlow)');
                
                // Animacja
                line.innerHTML = '<animate attributeName="stroke-dasharray" values="0,1000;1000,0" dur="0.5s" fill="freeze"/>';
                
                svg.appendChild(line);
                
                // K√≥≈Çko na poczƒÖtku
                var startCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startCircle.setAttribute('cx', x1);
                startCircle.setAttribute('cy', y1);
                startCircle.setAttribute('r', '6');
                startCircle.setAttribute('fill', '#ff9500');
                startCircle.setAttribute('filter', 'url(#arrowGlow)');
                svg.appendChild(startCircle);
            });
            
            // Dodaj SVG do board (nie wrapper) ≈ºeby by≈Ço w tym samym kontek≈õcie obrotu
            board.appendChild(svg);
        }
        
        function updateUI() {
            var ti = document.getElementById('turn-indicator');
            ti.className = 'turn-indicator ' + G.currentPlayer + '-turn';
            document.getElementById('current-player').textContent = G.currentPlayer === 'white' ? 'BIA≈ÅE' : 'CZARNE';
            var mip = document.getElementById('move-info-panel');
            if (G.selectedPiece) {
                var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
                if (piece) {
                    mip.style.display = 'block';
                    document.getElementById('selected-piece-name').textContent = piece.name + ' ' + piece.symbol;
                    document.getElementById('moves-left').textContent = piece.moves - (G.plannedPath.length - 1);
                } else mip.style.display = 'none';
            } else mip.style.display = 'none';
            document.getElementById('white-captured').innerHTML = G.capturedByWhite.map(function(p) { return '<div class="captured-piece">' + p.symbol + '</div>'; }).join('');
            document.getElementById('black-captured').innerHTML = G.capturedByBlack.map(function(p) { return '<div class="captured-piece">' + p.symbol + '</div>'; }).join('');
            var pe = document.getElementById('pending-captures');
            if (G.pendingCaptures.length > 0) {
                pe.style.display = 'block';
                document.getElementById('pending-list').innerHTML = G.pendingCaptures.map(function(cap) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    return target ? '<div class="pending-item">' + cap.attackerSymbol + ' ‚Üí ' + target.symbol + ' (' + cap.turnsLeft + ' tur)</div>' : '';
                }).join('');
            } else pe.style.display = 'none';
            
            // Mobile turn info
            var mobileTurnPlayer = document.getElementById('mobile-turn-player');
            var mobileTurnMoves = document.getElementById('mobile-turn-moves');
            mobileTurnPlayer.textContent = G.currentPlayer === 'white' ? 'BIA≈ÅE' : 'CZARNE';
            mobileTurnPlayer.className = 'mobile-turn-player ' + G.currentPlayer + '-turn';
            if (G.selectedPiece) {
                var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
                if (piece) {
                    var movesLeft = piece.moves - (G.plannedPath.length - 1);
                    mobileTurnMoves.textContent = piece.name + ' ‚Ä¢ ' + movesLeft + ' ' + (movesLeft === 1 ? 'krok' : 'kroki');
                } else {
                    mobileTurnMoves.textContent = '';
                }
            } else {
                mobileTurnMoves.textContent = 'Wybierz figurƒô';
            }
            
            // Obr√≥t planszy w PvP na mobile
            updateBoardRotation();
        }
        
        function updateBoardRotation() {
            var boardWrapper = document.getElementById('board-wrapper');
            var boardContainer = document.querySelector('.game-board-container');
            if (!boardWrapper) return;
            
            var shouldRotate = false;
            
            // Online - czarny zawsze widzi obr√≥cone
            if (G.gameMode === 'online' && myColor === 'black') {
                shouldRotate = true;
            }
            // PvP - obr√≥t przy turze czarnych
            else if (G.gameMode === 'pvp' && !G.gameOver && !G.analyzing) {
                if (G.currentPlayer === 'black') {
                    shouldRotate = true;
                }
            }
            
            if (shouldRotate) {
                boardWrapper.classList.add('rotated');
                if (boardContainer) boardContainer.classList.add('flipped');
            } else {
                boardWrapper.classList.remove('rotated');
                if (boardContainer) boardContainer.classList.remove('flipped');
            }
        }
        
        function shouldFlipBoard() {
            var boardWrapper = document.getElementById('board-wrapper');
            return boardWrapper && boardWrapper.classList.contains('rotated');
        }
        
        // =====================================================================
        // MEGA ULTRA ZAAWANSOWANA OCENA POZYCJI - STRZA≈ÅKOWE SZACHY v2.0
        // Analizuje WSZYSTKIE zasady gry z MAKSYMALNƒÑ precyzjƒÖ
        // Uwzglƒôdnia zasadƒô: FIGURA POD ATAKIEM NIE MO≈ªE ATAKOWAƒÜ KR√ìLA!
        // =====================================================================
        function evaluatePosition() {
            var pieceValues = { king: 0, queen: 9, rook: 5, bishop: 3, knight: 3, pawn: 1 };
            
            // ===== ZNAJD≈π WSZYSTKIE FIGURY I KR√ìL√ìW =====
            var whitePieces = [], blackPieces = [];
            var whiteKing = null, blackKing = null;
            
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p) {
                        var pieceData = { piece: p, x: x, y: y };
                        if (p.color === 'white') {
                            whitePieces.push(pieceData);
                            if (p.type === 'king') whiteKing = pieceData;
                        } else {
                            blackPieces.push(pieceData);
                            if (p.type === 'king') blackKing = pieceData;
                        }
                    }
                }
            }
            
            // Je≈õli brak kr√≥la - natychmiastowa wygrana/przegrana
            if (!whiteKing) return -999;
            if (!blackKing) return 999;
            
            // =====================================================================
            // 0. ZBIERZ INFORMACJE O FIGURACH POD ATAKIEM
            // To jest KLUCZOWE dla nowej zasady!
            // =====================================================================
            var whitePiecesUnderAttack = {}; // key: "x,y" -> true
            var blackPiecesUnderAttack = {};
            
            G.pendingCaptures.forEach(function(cap) {
                var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                if (target) {
                    var key = cap.targetX + ',' + cap.targetY;
                    if (target.color === 'white') {
                        whitePiecesUnderAttack[key] = true;
                    } else {
                        blackPiecesUnderAttack[key] = true;
                    }
                }
            });
            
            // =====================================================================
            // 1. ANALIZA PENDINGCAPTURES - NAJWA≈ªNIEJSZY ELEMENT!
            // =====================================================================
            var whiteAttackScore = 0, blackAttackScore = 0;
            
            // Zbierz wszystkie ataki na ka≈ºde pole
            var attacksOnSquare = {};
            
            G.pendingCaptures.forEach(function(cap) {
                var key = cap.targetX + ',' + cap.targetY;
                if (!attacksOnSquare[key]) {
                    attacksOnSquare[key] = { white: [], black: [], target: null };
                }
                attacksOnSquare[key][cap.attackerColor].push(cap);
                attacksOnSquare[key].target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
            });
            
            // Analizuj ka≈ºde atakowane pole
            for (var key in attacksOnSquare) {
                var data = attacksOnSquare[key];
                var target = data.target;
                if (!target) continue;
                
                var targetValue = pieceValues[target.type] || 0;
                var coords = key.split(',');
                var tx = parseInt(coords[0]), ty = parseInt(coords[1]);
                
                // === PODW√ìJNY ATAK = GWARANTOWANE ZBICIE ===
                if (data.white.length >= 2) {
                    if (target.type === 'king') {
                        whiteAttackScore += 500; // MAT!
                    } else if (target.color === 'black') {
                        whiteAttackScore += targetValue * 3;
                    }
                }
                if (data.black.length >= 2) {
                    if (target.type === 'king') {
                        blackAttackScore += 500;
                    } else if (target.color === 'white') {
                        blackAttackScore += targetValue * 3;
                    }
                }
                
                // === POJEDYNCZY ATAK ===
                if (data.white.length === 1 && target.color === 'black') {
                    var cap = data.white[0];
                    var escapeMoves = getAllMovesForPiece(tx, ty, target, true);
                    var safeEscapes = countSafeEscapes(escapeMoves, tx, ty, 'white');
                    
                    if (cap.isNexusLock && target.type === 'king') {
                        if (safeEscapes === 0) {
                            whiteAttackScore += (cap.turnsLeft === 1) ? 200 : 100;
                        } else if (safeEscapes === 1) {
                            whiteAttackScore += 30;
                        } else {
                            whiteAttackScore += 15;
                        }
                    } else {
                        if (safeEscapes === 0) {
                            whiteAttackScore += targetValue * (cap.turnsLeft === 1 ? 0.95 : 0.8);
                        } else {
                            whiteAttackScore += targetValue * 0.25;
                        }
                    }
                }
                
                if (data.black.length === 1 && target.color === 'white') {
                    var cap = data.black[0];
                    var escapeMoves = getAllMovesForPiece(tx, ty, target, true);
                    var safeEscapes = countSafeEscapes(escapeMoves, tx, ty, 'black');
                    
                    if (cap.isNexusLock && target.type === 'king') {
                        if (safeEscapes === 0) {
                            blackAttackScore += (cap.turnsLeft === 1) ? 200 : 100;
                        } else if (safeEscapes === 1) {
                            blackAttackScore += 30;
                        } else {
                            blackAttackScore += 15;
                        }
                    } else {
                        if (safeEscapes === 0) {
                            blackAttackScore += targetValue * (cap.turnsLeft === 1 ? 0.95 : 0.8);
                        } else {
                            blackAttackScore += targetValue * 0.25;
                        }
                    }
                }
            }
            
            // =====================================================================
            // 2. KLUCZOWA ZASADA: FIGURY ZAGRO≈ªONE NIE MOGƒÑ ATAKOWAƒÜ KR√ìLA!
            // Zagro≈ºona = przeciwnik mo≈ºe jƒÖ zaatakowaƒá w nastƒôpnej turze
            // =====================================================================
            var whiteNeutralizedPieces = 0, blackNeutralizedPieces = 0;
            var whiteBlockedKingAttackers = 0, blackBlockedKingAttackers = 0;
            
            // Sprawd≈∫ bia≈Çe figury zagro≈ºone przez czarne
            whitePieces.forEach(function(pd) {
                // Czy ta figura jest zagro≈ºona (czarne mogƒÖ jƒÖ zaatakowaƒá)?
                var isThreatened = isSquareThreatened(pd.x, pd.y, 'black');
                if (isThreatened) {
                    // Ta figura jest zagro≈ºona - nie mo≈ºe atakowaƒá kr√≥la czarnych!
                    whiteNeutralizedPieces++;
                    
                    // Sprawd≈∫ czy ta figura MOG≈ÅABY dosiƒôgnƒÖƒá kr√≥la gdyby nie by≈Ça pod atakiem
                    if (blackKing && pd.piece.type !== 'king') {
                        var moves = getAllMovesForPieceIgnoringAttackBlock(pd.x, pd.y, pd.piece);
                        var canReachKing = moves.some(function(path) {
                            var end = path[path.length - 1];
                            return end.x === blackKing.x && end.y === blackKing.y;
                        });
                        if (canReachKing) {
                            // Bia≈Ça figura kt√≥ra mog≈Çaby szachowaƒá jest zablokowana!
                            blackBlockedKingAttackers++;
                            blackAttackScore += 12; // Czarne majƒÖ przewagƒô - zablokowa≈Çy atakujƒÖcego
                        }
                    }
                }
            });
            
            // Sprawd≈∫ czarne figury zagro≈ºone przez bia≈Çe
            blackPieces.forEach(function(pd) {
                var isThreatened = isSquareThreatened(pd.x, pd.y, 'white');
                if (isThreatened) {
                    blackNeutralizedPieces++;
                    
                    if (whiteKing && pd.piece.type !== 'king') {
                        var moves = getAllMovesForPieceIgnoringAttackBlock(pd.x, pd.y, pd.piece);
                        var canReachKing = moves.some(function(path) {
                            var end = path[path.length - 1];
                            return end.x === whiteKing.x && end.y === whiteKing.y;
                        });
                        if (canReachKing) {
                            whiteBlockedKingAttackers++;
                            whiteAttackScore += 12;
                        }
                    }
                }
            });
            
            // Bonus za zneutralizowanie figur przeciwnika
            whiteAttackScore += blackNeutralizedPieces * 3;
            blackAttackScore += whiteNeutralizedPieces * 3;
            
            // =====================================================================
            // 3. BEZPIECZE≈ÉSTWO KR√ìLA - z uwzglƒôdnieniem figur pod atakiem
            // =====================================================================
            var whiteKingSafety = analyzeKingSafetyAdvanced(whiteKing, 'white', blackPieces, whitePiecesUnderAttack);
            var blackKingSafety = analyzeKingSafetyAdvanced(blackKing, 'black', whitePieces, blackPiecesUnderAttack);
            
            whiteAttackScore += (100 - blackKingSafety) * 0.35;
            blackAttackScore += (100 - whiteKingSafety) * 0.35;
            
            // =====================================================================
            // 4. POTENCJALNE PODW√ìJNE ATAKI
            // =====================================================================
            var whitePotentialDouble = findPotentialDoubleAttacksAdvanced('white', whitePieces, blackPieces, whitePiecesUnderAttack);
            var blackPotentialDouble = findPotentialDoubleAttacksAdvanced('black', blackPieces, whitePieces, blackPiecesUnderAttack);
            
            whiteAttackScore += whitePotentialDouble * 2.5;
            blackAttackScore += blackPotentialDouble * 2.5;
            
            // =====================================================================
            // 5. MO≈ªLIWO≈öƒÜ ATAKU NA KR√ìLA - tylko figury NIE pod atakiem!
            // =====================================================================
            var whiteCanAttackKing = 0, blackCanAttackKing = 0;
            
            whitePieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                // Tylko figury kt√≥re NIE sƒÖ ZAGRO≈ªONE mogƒÖ atakowaƒá kr√≥la!
                if (isSquareThreatened(pd.x, pd.y, 'black')) return;
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                if (blackKing && canPieceReachSquare(pd.x, pd.y, blackKing.x, blackKing.y, pd.piece)) {
                    whiteCanAttackKing++;
                }
            });
            
            blackPieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                if (isSquareThreatened(pd.x, pd.y, 'white')) return;
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                if (whiteKing && canPieceReachSquare(pd.x, pd.y, whiteKing.x, whiteKing.y, pd.piece)) {
                    blackCanAttackKing++;
                }
            });
            
            whiteAttackScore += whiteCanAttackKing * 6;
            blackAttackScore += blackCanAttackKing * 6;
            
            // =====================================================================
            // 6. MATERIA≈Å - z modyfikatorami dla figur ZAGRO≈ªONYCH
            // =====================================================================
            var whiteMaterial = 0, blackMaterial = 0;
            
            whitePieces.forEach(function(pd) {
                var value = pieceValues[pd.piece.type] || 0;
                if (pd.piece.type === 'king') { whiteMaterial += 0; return; }
                
                // Figura ZAGRO≈ªONA = znacznie mniej warta (bo nie mo≈ºe atakowaƒá kr√≥la!)
                if (isSquareThreatened(pd.x, pd.y, 'black')) {
                    value *= 0.5;
                }
                // Zamro≈ºona
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) {
                    value *= 0.6;
                }
                // AtakujƒÖca (nie mo≈ºe siƒô ruszaƒá)
                if (isPieceAttacking(pd.x, pd.y)) {
                    value *= 0.75;
                }
                // Bonus za pionki
                if (pd.piece.type === 'pawn') {
                    value += (7 - pd.y) * 0.25;
                    if (pd.y <= 1) value += 2.5;
                }
                // Bonus za blisko≈õƒá do wrogiego kr√≥la
                if (blackKing && pd.piece.type !== 'pawn') {
                    var dist = Math.abs(pd.x - blackKing.x) + Math.abs(pd.y - blackKing.y);
                    if (dist <= 3) value += (4 - dist) * 0.4;
                }
                
                whiteMaterial += value;
            });
            
            blackPieces.forEach(function(pd) {
                var value = pieceValues[pd.piece.type] || 0;
                if (pd.piece.type === 'king') { blackMaterial += 0; return; }
                
                if (isSquareThreatened(pd.x, pd.y, 'white')) {
                    value *= 0.5;
                }
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) {
                    value *= 0.6;
                }
                if (isPieceAttacking(pd.x, pd.y)) {
                    value *= 0.75;
                }
                if (pd.piece.type === 'pawn') {
                    value += pd.y * 0.25;
                    if (pd.y >= 6) value += 2.5;
                }
                if (whiteKing && pd.piece.type !== 'pawn') {
                    var dist = Math.abs(pd.x - whiteKing.x) + Math.abs(pd.y - whiteKing.y);
                    if (dist <= 3) value += (4 - dist) * 0.4;
                }
                
                blackMaterial += value;
            });
            
            // Zbite figury
            G.capturedByWhite.forEach(function(p) { whiteMaterial += pieceValues[p.type] * 0.4; });
            G.capturedByBlack.forEach(function(p) { blackMaterial += pieceValues[p.type] * 0.4; });
            
            // =====================================================================
            // 7. MOBILNO≈öƒÜ - tylko dla figur NIE ZAGRO≈ªONYCH
            // =====================================================================
            var whiteMobility = 0, blackMobility = 0;
            
            whitePieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                if (isSquareThreatened(pd.x, pd.y, 'black')) return; // Zagro≈ºona = ograniczona
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                var moves = getAllMovesForPiece(pd.x, pd.y, pd.piece, false);
                whiteMobility += moves.length;
            });
            
            blackPieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                if (isSquareThreatened(pd.x, pd.y, 'white')) return;
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                var moves = getAllMovesForPiece(pd.x, pd.y, pd.piece, false);
                blackMobility += moves.length;
            });
            
            // =====================================================================
            // 8. KONTROLA CENTRUM
            // =====================================================================
            var whiteCenterControl = 0, blackCenterControl = 0;
            var centerSquares = [{x:3,y:3}, {x:3,y:4}, {x:4,y:3}, {x:4,y:4}];
            
            centerSquares.forEach(function(sq) {
                var p = G.board[sq.y][sq.x];
                if (p) {
                    if (p.color === 'white') whiteCenterControl += 2;
                    else blackCenterControl += 2;
                }
                if (isSquareThreatened(sq.x, sq.y, 'white')) whiteCenterControl += 0.5;
                if (isSquareThreatened(sq.x, sq.y, 'black')) blackCenterControl += 0.5;
            });
            
            // =====================================================================
            // 9. TARCZE SENTINELA
            // =====================================================================
            var whiteShieldValue = 0, blackShieldValue = 0;
            
            G.sentinelShields.forEach(function(shield) {
                var shieldValue = shield.tiles.length * 0.3;
                var enemyKing = (shield.color === 'white') ? blackKing : whiteKing;
                if (enemyKing) {
                    var dist = Math.abs(shield.guardianX - enemyKing.x) + Math.abs(shield.guardianY - enemyKing.y);
                    if (dist < 4) shieldValue += (4 - dist) * 0.5;
                }
                
                if (shield.color === 'white') whiteShieldValue += shieldValue;
                else blackShieldValue += shieldValue;
            });
            
            // =====================================================================
            // 10. STRUKTURA PIONK√ìW
            // =====================================================================
            var whitePawnStructure = analyzePawnStructure('white', whitePieces);
            var blackPawnStructure = analyzePawnStructure('black', blackPieces);
            
            // =====================================================================
            // 11. TEMPO I INICJATYWA
            // =====================================================================
            var whiteTempo = 0, blackTempo = 0;
            
            // Kto ma wiƒôcej aktywnych atak√≥w?
            var whiteActiveAttacks = 0, blackActiveAttacks = 0;
            G.pendingCaptures.forEach(function(cap) {
                if (cap.attackerColor === 'white') whiteActiveAttacks++;
                else blackActiveAttacks++;
            });
            
            whiteTempo += whiteActiveAttacks * 2;
            blackTempo += blackActiveAttacks * 2;
            
            // Kto ma turƒô? (ma≈Çy bonus)
            if (G.currentPlayer === 'white') whiteTempo += 0.5;
            else blackTempo += 0.5;
            
            // =====================================================================
            // FINALNA OCENA - WA≈ªONE SK≈ÅADNIKI
            // =====================================================================
            var whiteScore = 
                whiteAttackScore * 1.5 +
                whiteMaterial * 1.0 +
                whiteMobility * 0.03 +
                whiteCenterControl * 0.4 +
                whiteShieldValue * 0.5 +
                whitePawnStructure * 0.3 +
                whiteTempo * 0.3;
            
            var blackScore = 
                blackAttackScore * 1.5 +
                blackMaterial * 1.0 +
                blackMobility * 0.03 +
                blackCenterControl * 0.4 +
                blackShieldValue * 0.5 +
                blackPawnStructure * 0.3 +
                blackTempo * 0.3;
            
            var finalEval = whiteScore - blackScore;
            
            // Blisko≈õƒá remisu
            var drawProximity = getDrawProximity();
            if (drawProximity > 0) {
                finalEval = finalEval * (1 - drawProximity * 0.85);
            }
            
            // Szach
            if (G.inCheck === 'white') finalEval -= 4;
            if (G.inCheck === 'black') finalEval += 4;
            
            return finalEval;
        }
        
        // =====================================================================
        // ULEPSZONE FUNKCJE POMOCNICZE
        // =====================================================================
        
        // Zaawansowana analiza bezpiecze≈Ñstwa kr√≥la
        function analyzeKingSafetyAdvanced(kingData, color, enemyPieces, friendlyUnderAttack) {
            if (!kingData) return 0;
            
            var safety = 100;
            var enemyColor = (color === 'white') ? 'black' : 'white';
            var kx = kingData.x, ky = kingData.y;
            
            // Szach
            if (G.inCheck === color) safety -= 30;
            
            // Pola ucieczki
            var kingPiece = G.board[ky][kx];
            var escapeMoves = getAllMovesForPiece(kx, ky, kingPiece, false);
            var safeEscapes = countSafeEscapes(escapeMoves, kx, ky, enemyColor);
            
            if (safeEscapes === 0) safety -= 45;
            else if (safeEscapes === 1) safety -= 30;
            else if (safeEscapes === 2) safety -= 18;
            else if (safeEscapes === 3) safety -= 10;
            
            // Pozycja
            if ((kx === 0 || kx === 7) && (ky === 0 || ky === 7)) safety -= 18;
            else if (kx === 0 || kx === 7 || ky === 0 || ky === 7) safety -= 10;
            
            // Ile wrogich figur mo≈ºe atakowaƒá kr√≥la (tylko te NIE pod atakiem!)
            var attackers = 0;
            enemyPieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                var key = pd.x + ',' + pd.y;
                // KLUCZOWE: Figura pod atakiem nie mo≈ºe atakowaƒá kr√≥la!
                var enemyUnderAttack = (color === 'white') ? 
                    (blackPiecesUnderAttack && blackPiecesUnderAttack[key]) : 
                    (whitePiecesUnderAttack && whitePiecesUnderAttack[key]);
                if (enemyUnderAttack) return; // Ta figura nie mo≈ºe nas atakowaƒá!
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                if (canPieceReachSquare(pd.x, pd.y, kx, ky, pd.piece)) {
                    attackers++;
                }
            });
            safety -= attackers * 7;
            
            // Zagro≈ºone pola wok√≥≈Ç
            var threatenedAround = 0;
            for (var dy = -1; dy <= 1; dy++) {
                for (var dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    var nx = kx + dx, ny = ky + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                        if (isSquareThreatened(nx, ny, enemyColor)) {
                            threatenedAround++;
                        }
                    }
                }
            }
            safety -= threatenedAround * 4;
            
            // Blokada na kr√≥lu
            G.pendingCaptures.forEach(function(cap) {
                if (cap.targetX === kx && cap.targetY === ky && cap.isNexusLock) {
                    safety -= (cap.turnsLeft === 1) ? 40 : 25;
                }
            });
            
            // Obro≈Ñcy w pobli≈ºu (ale tylko ci NIE pod atakiem)
            var defenders = 0;
            for (var dy = -2; dy <= 2; dy++) {
                for (var dx = -2; dx <= 2; dx++) {
                    var nx = kx + dx, ny = ky + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                        var p = G.board[ny][nx];
                        if (p && p.color === color && p.type !== 'king') {
                            var defKey = nx + ',' + ny;
                            if (!friendlyUnderAttack[defKey]) {
                                defenders++;
                            }
                        }
                    }
                }
            }
            safety += Math.min(defenders * 4, 18);
            
            return Math.max(0, Math.min(100, safety));
        }
        
        // Zaawansowane szukanie podw√≥jnych atak√≥w
        function findPotentialDoubleAttacksAdvanced(color, friendlyPieces, enemyPieces, friendlyUnderAttack) {
            var score = 0;
            var enemyColor = (color === 'white') ? 'black' : 'white';
            
            G.pendingCaptures.forEach(function(existingCap) {
                if (existingCap.attackerColor !== color) return;
                
                var targetX = existingCap.targetX;
                var targetY = existingCap.targetY;
                
                friendlyPieces.forEach(function(pd) {
                    if (pd.x === existingCap.attackerX && pd.y === existingCap.attackerY) return;
                    var key = pd.x + ',' + pd.y;
                    // Figura pod atakiem nie mo≈ºe do≈ÇƒÖczyƒá do ataku na kr√≥la!
                    if (friendlyUnderAttack[key]) {
                        var target = G.board[targetY] ? G.board[targetY][targetX] : null;
                        if (target && target.type === 'king') return; // Nie mo≈ºe atakowaƒá kr√≥la!
                    }
                    if (isPieceAttacking(pd.x, pd.y)) return;
                    if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                    if (pd.piece.type === 'king') return;
                    
                    if (canPieceReachSquare(pd.x, pd.y, targetX, targetY, pd.piece)) {
                        var target = G.board[targetY] ? G.board[targetY][targetX] : null;
                        if (target && target.color === enemyColor) {
                            var value = pieceValuesGlobal[target.type] || 1;
                            if (target.type === 'king') {
                                score += 55;
                            } else {
                                score += value * 1.8;
                            }
                        }
                    }
                });
            });
            
            return score;
        }
        
        // Globalne zmienne dla funkcji pomocniczych
        var whitePiecesUnderAttack = {};
        var blackPiecesUnderAttack = {};
        
        // =====================================================================
        // FUNKCJE POMOCNICZE DO ULTRA ANALIZY
        // =====================================================================
        
        // Zlicz bezpieczne ucieczki (pola nie zagro≈ºone przez przeciwnika)
        function countSafeEscapes(moves, fromX, fromY, enemyColor) {
            var count = 0;
            for (var i = 0; i < moves.length; i++) {
                var path = moves[i];
                if (path.length > 1) {
                    var end = path[path.length - 1];
                    // Sprawd≈∫ czy pole docelowe jest bezpieczne
                    if (!isSquareThreatened(end.x, end.y, enemyColor)) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        // Szczeg√≥≈Çowa analiza bezpiecze≈Ñstwa kr√≥la (0-100)
        function analyzeKingSafety(kingData, color, enemyPieces) {
            if (!kingData) return 0;
            
            var safety = 100;
            var enemyColor = (color === 'white') ? 'black' : 'white';
            var kx = kingData.x, ky = kingData.y;
            
            // 1. Czy jest pod szachem?
            if (G.inCheck === color) safety -= 25;
            
            // 2. Ile p√≥l ucieczki ma?
            var kingPiece = G.board[ky][kx];
            var escapeMoves = getAllMovesForPiece(kx, ky, kingPiece, false);
            var safeEscapes = countSafeEscapes(escapeMoves, kx, ky, enemyColor);
            
            if (safeEscapes === 0) safety -= 40;
            else if (safeEscapes === 1) safety -= 25;
            else if (safeEscapes === 2) safety -= 15;
            else if (safeEscapes === 3) safety -= 8;
            
            // 3. Czy jest w rogu/na krawƒôdzi? (≈Çatwiej zamatowaƒá)
            if ((kx === 0 || kx === 7) && (ky === 0 || ky === 7)) safety -= 15;
            else if (kx === 0 || kx === 7 || ky === 0 || ky === 7) safety -= 8;
            
            // 4. Ile wrogich figur mo≈ºe go zaatakowaƒá?
            var attackers = 0;
            enemyPieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                if (canPieceReachSquare(pd.x, pd.y, kx, ky, pd.piece)) {
                    attackers++;
                }
            });
            safety -= attackers * 5;
            
            // 5. Ile p√≥l wok√≥≈Ç kr√≥la jest zagro≈ºonych?
            var threatenedAround = 0;
            for (var dy = -1; dy <= 1; dy++) {
                for (var dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    var nx = kx + dx, ny = ky + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                        if (isSquareThreatened(nx, ny, enemyColor)) {
                            threatenedAround++;
                        }
                    }
                }
            }
            safety -= threatenedAround * 3;
            
            // 6. Czy jest aktywna blokada na kr√≥lu?
            G.pendingCaptures.forEach(function(cap) {
                if (cap.targetX === kx && cap.targetY === ky && cap.isNexusLock) {
                    safety -= (cap.turnsLeft === 1) ? 35 : 20;
                }
            });
            
            // 7. Czy ma figury obronne w pobli≈ºu?
            var defenders = 0;
            var friendlyPieces = (color === 'white') ? 
                whitePiecesGlobal || [] : blackPiecesGlobal || [];
            
            // Sprawd≈∫ 2 pola wok√≥≈Ç
            for (var dy = -2; dy <= 2; dy++) {
                for (var dx = -2; dx <= 2; dx++) {
                    var nx = kx + dx, ny = ky + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                        var p = G.board[ny][nx];
                        if (p && p.color === color && p.type !== 'king') {
                            defenders++;
                        }
                    }
                }
            }
            safety += Math.min(defenders * 3, 15);
            
            return Math.max(0, Math.min(100, safety));
        }
        
        // Szukaj mo≈ºliwo≈õci podw√≥jnego ataku
        function findPotentialDoubleAttacks(color, friendlyPieces, enemyPieces) {
            var score = 0;
            var enemyColor = (color === 'white') ? 'black' : 'white';
            
            // Dla ka≈ºdej naszej figury, sprawd≈∫ czy mo≈ºe do≈ÇƒÖczyƒá do istniejƒÖcego ataku
            G.pendingCaptures.forEach(function(existingCap) {
                if (existingCap.attackerColor !== color) return;
                
                var targetX = existingCap.targetX;
                var targetY = existingCap.targetY;
                
                friendlyPieces.forEach(function(pd) {
                    // Pomi≈Ñ atakujƒÖcƒÖ figurƒô
                    if (pd.x === existingCap.attackerX && pd.y === existingCap.attackerY) return;
                    // Pomi≈Ñ figury kt√≥re ju≈º atakujƒÖ
                    if (isPieceAttacking(pd.x, pd.y)) return;
                    // Pomi≈Ñ zamro≈ºone
                    if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                    // Pomi≈Ñ kr√≥la
                    if (pd.piece.type === 'king') return;
                    
                    // Sprawd≈∫ czy ta figura mo≈ºe dosiƒôgnƒÖƒá cel
                    if (canPieceReachSquare(pd.x, pd.y, targetX, targetY, pd.piece)) {
                        var target = G.board[targetY] ? G.board[targetY][targetX] : null;
                        if (target && target.color === enemyColor) {
                            var value = pieceValuesGlobal[target.type] || 1;
                            if (target.type === 'king') {
                                score += 50; // Mo≈ºliwy mat!
                            } else {
                                score += value * 1.5;
                            }
                        }
                    }
                });
            });
            
            return score;
        }
        
        // Globalne warto≈õci figur dla funkcji pomocniczych
        var pieceValuesGlobal = { king: 0, queen: 9, rook: 5, bishop: 3, knight: 3, pawn: 1 };
        var whitePiecesGlobal = [], blackPiecesGlobal = [];
        
        // Oblicz warto≈õƒá figury z modyfikatorami
        function calculatePieceValue(pieceData, color, friendlyKing, enemyKing) {
            var base = pieceValuesGlobal[pieceData.piece.type] || 0;
            var x = pieceData.x, y = pieceData.y;
            var piece = pieceData.piece;
            
            // Zamro≈ºona = po≈Çowa warto≈õci
            if (piece.frozenTurns && piece.frozenTurns > 0) {
                base *= 0.5;
            }
            
            // AtakujƒÖca = mniej warta (nie mo≈ºe siƒô ruszaƒá)
            if (isPieceAttacking(x, y)) {
                base *= 0.7;
            }
            
            // Pod atakiem = mniej warta
            if (isPieceUnderAttack(x, y)) {
                base *= 0.8;
            }
            
            // Pionek - bonus za zaawansowanie
            if (piece.type === 'pawn') {
                if (color === 'white') {
                    base += (7 - y) * 0.25;
                    if (y <= 1) base += 3; // Blisko promocji
                } else {
                    base += y * 0.25;
                    if (y >= 6) base += 3;
                }
            }
            
            // Bonus za blisko≈õƒá do wrogiego kr√≥la (dla figur atakujƒÖcych)
            if (enemyKing && piece.type !== 'pawn' && piece.type !== 'king') {
                var dist = Math.abs(x - enemyKing.x) + Math.abs(y - enemyKing.y);
                if (dist < 4) {
                    base += (4 - dist) * 0.3;
                }
            }
            
            return base;
        }
        
        // Analiza struktury pionk√≥w
        function analyzePawnStructure(color, pieces) {
            var score = 0;
            var pawns = pieces.filter(function(pd) { return pd.piece.type === 'pawn'; });
            
            // Zdwojone pionki (na tej samej kolumnie) = ≈∫le
            var columns = {};
            pawns.forEach(function(pd) {
                if (!columns[pd.x]) columns[pd.x] = 0;
                columns[pd.x]++;
            });
            for (var col in columns) {
                if (columns[col] > 1) {
                    score -= (columns[col] - 1) * 0.5;
                }
            }
            
            // Izolowane pionki = ≈∫le
            pawns.forEach(function(pd) {
                var hasNeighbor = pawns.some(function(other) {
                    return Math.abs(other.x - pd.x) === 1;
                });
                if (!hasNeighbor) score -= 0.3;
            });
            
            // Przej≈õciowe pionki (brak blokady i wrogich pionk√≥w na sƒÖsiednich kolumnach) = dobrze
            pawns.forEach(function(pd) {
                var forward = (color === 'white') ? -1 : 1;
                var blocked = false;
                var opposed = false;
                
                for (var ty = pd.y + forward; ty >= 0 && ty < 8; ty += forward) {
                    var p = G.board[ty][pd.x];
                    if (p) {
                        blocked = true;
                        break;
                    }
                    // Sprawd≈∫ sƒÖsiednie kolumny
                    if (pd.x > 0) {
                        var pl = G.board[ty][pd.x - 1];
                        if (pl && pl.type === 'pawn' && pl.color !== color) opposed = true;
                    }
                    if (pd.x < 7) {
                        var pr = G.board[ty][pd.x + 1];
                        if (pr && pr.type === 'pawn' && pr.color !== color) opposed = true;
                    }
                }
                
                if (!blocked && !opposed) score += 1.5; // Przej≈õciowy pionek!
            });
            
            return score;
        }
        
        // Analiza przysz≈Çych zagro≈ºe≈Ñ
        function analyzeFutureThreats(color, pieces, enemyKing) {
            var score = 0;
            if (!enemyKing) return 0;
            
            var enemyColor = (color === 'white') ? 'black' : 'white';
            
            pieces.forEach(function(pd) {
                if (pd.piece.type === 'king') return;
                if (isPieceAttacking(pd.x, pd.y)) return;
                if (pd.piece.frozenTurns && pd.piece.frozenTurns > 0) return;
                
                // Sprawd≈∫ czy figura mo≈ºe zaatakowaƒá kr√≥la
                if (canPieceReachSquare(pd.x, pd.y, enemyKing.x, enemyKing.y, pd.piece)) {
                    // Ale tylko je≈õli ta figura NIE jest pod atakiem!
                    if (!isPieceUnderAttack(pd.x, pd.y)) {
                        score += 5;
                    }
                }
                
                // Sprawd≈∫ czy figura mo≈ºe zaatakowaƒá cenne figury wroga
                for (var y = 0; y < 8; y++) {
                    for (var x = 0; x < 8; x++) {
                        var target = G.board[y][x];
                        if (target && target.color === enemyColor && target.type !== 'king') {
                            if (canPieceReachSquare(pd.x, pd.y, x, y, pd.piece)) {
                                var value = pieceValuesGlobal[target.type] || 0;
                                score += value * 0.1;
                            }
                        }
                    }
                }
            });
            
            return score;
        }
        
        // Wersja getAllMovesForPiece kt√≥ra IGNORUJE blokadƒô ataku na kr√≥la
        // (u≈ºywana tylko do analizy co by by≈Ço gdyby)
        function getAllMovesForPieceIgnoringAttackBlock(startX, startY, piece) {
            var allMoves = [];
            var enemyColor = piece.color === 'white' ? 'black' : 'white';
            
            function explore(path, usedDiag) {
                if (path.length > piece.moves + 1) return;
                if (path.length > 1) {
                    allMoves.push(path.slice());
                }
                if (path.length >= piece.moves + 1) return;
                var lastPos = path[path.length - 1];
                for (var key in DIRECTIONS) {
                    var dir = DIRECTIONS[key];
                    if (piece.straightOnly && dir.diagonal) continue;
                    if (piece.diagonalOnly && !dir.diagonal) continue;
                    if (dir.diagonal && usedDiag) continue;
                    
                    var newX = lastPos.x + dir.dx, newY = lastPos.y + dir.dy;
                    if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
                    var targetPiece = G.board[newY][newX];
                    if (targetPiece && targetPiece.color === piece.color) continue;
                    var inPath = path.some(function(p) { return p.x === newX && p.y === newY; });
                    if (inPath) continue;
                    
                    var newPath = path.slice();
                    newPath.push({ x: newX, y: newY });
                    explore(newPath, usedDiag || dir.diagonal);
                }
            }
            explore([{ x: startX, y: startY }], false);
            return allMoves;
        }
        
        // Oblicz jak blisko jest do remisu (0 = daleko, 1 = remis)
        function getDrawProximity() {
            var maxProximity = 0;
            
            // 1. Ruchy bez ataku (10 = remis)
            var attackDrawProximity = G.movesWithoutAttack / 10;
            if (attackDrawProximity > maxProximity) maxProximity = attackDrawProximity;
            
            // 2. Potr√≥jne powt√≥rzenie pozycji (3 = remis)
            for (var uid in G.piecePositionHistory) {
                for (var posKey in G.piecePositionHistory[uid]) {
                    var count = G.piecePositionHistory[uid][posKey];
                    if (count >= 2) {
                        var repetitionProximity = count / 3;
                        if (repetitionProximity > maxProximity) maxProximity = repetitionProximity;
                    }
                }
            }
            
            return Math.min(maxProximity, 1);
        }
        
        // Ocena jak blisko dany kolor jest do bycia zamatowanym
        // Zwraca warto≈õƒá dodatniƒÖ = przeciwnik blisko mata (dobrze dla nas)
        function evaluateMateProximity(kingColor) {
            var score = 0;
            var enemyColor = kingColor === 'white' ? 'black' : 'white';
            
            // Znajd≈∫ kr√≥la
            var kingPos = null;
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'king' && p.color === kingColor) {
                        kingPos = {x: x, y: y};
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return 0;
            
            // 1. Czy kr√≥l jest pod szachem?
            var isInCheck = G.inCheck === kingColor;
            if (isInCheck) score += 3;
            
            // 2. Ile p√≥l ucieczki ma kr√≥l?
            var kingPiece = G.board[kingPos.y][kingPos.x];
            var escapeMoves = getAllMovesForPiece(kingPos.x, kingPos.y, kingPiece, false);
            
            // Filtruj bezpieczne pola
            var safeEscapes = 0;
            for (var i = 0; i < escapeMoves.length; i++) {
                var path = escapeMoves[i];
                if (path.length > 1) {
                    var endPos = path[path.length - 1];
                    if (!isSquareThreatened(endPos.x, endPos.y, enemyColor)) {
                        safeEscapes++;
                    }
                }
            }
            
            // Ma≈Ço bezpiecznych p√≥l = bli≈ºej mata
            if (safeEscapes === 0 && isInCheck) {
                score += 50; // Prawie mat!
            } else if (safeEscapes === 0) {
                score += 8; // Kr√≥l zablokowany ale nie szach
            } else if (safeEscapes === 1) {
                score += 4; // Tylko jedno pole ucieczki
            } else if (safeEscapes === 2) {
                score += 2;
            }
            
            // 3. Czy kr√≥l jest w rogu/na krawƒôdzi? (≈Çatwiej zamatowaƒá)
            if ((kingPos.x === 0 || kingPos.x === 7) && (kingPos.y === 0 || kingPos.y === 7)) {
                score += 1.5; // R√≥g
            } else if (kingPos.x === 0 || kingPos.x === 7 || kingPos.y === 0 || kingPos.y === 7) {
                score += 0.8; // Krawƒôd≈∫
            }
            
            // 4. Ile wrogich figur atakuje pola wok√≥≈Ç kr√≥la?
            var threatsAroundKing = 0;
            for (var dy = -1; dy <= 1; dy++) {
                for (var dx = -1; dx <= 1; dx++) {
                    var nx = kingPos.x + dx, ny = kingPos.y + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                        if (isSquareThreatened(nx, ny, enemyColor)) {
                            threatsAroundKing++;
                        }
                    }
                }
            }
            score += threatsAroundKing * 0.3;
            
            // 5. Czy jest aktywna blokada na kr√≥lu?
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.targetX === kingPos.x && cap.targetY === kingPos.y && cap.isNexusLock) {
                    if (cap.turnsLeft === 1) {
                        score += 15; // Ostatnia szansa na ucieczkƒô!
                    } else {
                        score += 8;
                    }
                }
            }
            
            // 6. Stosunek materia≈Çu - je≈õli przeciwnik ma du≈ºo figur a my ma≈Ço, bli≈ºej mata
            var ourMaterial = 0, theirMaterial = 0;
            var pieceVals = { queen: 9, rook: 5, bishop: 3, knight: 3, pawn: 1 };
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type !== 'king') {
                        if (p.color === kingColor) {
                            ourMaterial += pieceVals[p.type] || 0;
                        } else {
                            theirMaterial += pieceVals[p.type] || 0;
                        }
                    }
                }
            }
            
            // Du≈ºa przewaga materialna przeciwnika = bli≈ºej mata
            var materialDiff = theirMaterial - ourMaterial;
            if (materialDiff > 10) score += 3;
            else if (materialDiff > 5) score += 1.5;
            
            return score;
        }
        
        function updateEvalBar() {
            var eval = evaluatePosition();
            
            // Przekszta≈Çƒá eval na procent (sigmoid-like)
            // eval = 0 -> 50%, eval = +10 -> ~95%, eval = -10 -> ~5%
            var percentage = 50 + (eval / (Math.abs(eval) + 5)) * 45;
            percentage = Math.max(2, Math.min(98, percentage));
            
            var whiteBar = document.getElementById('eval-white');
            var marker = document.getElementById('eval-marker');
            var valueDisplay = document.getElementById('eval-value');
            
            if (whiteBar) whiteBar.style.height = percentage + '%';
            if (marker) marker.style.top = (100 - percentage) + '%';
            
            if (valueDisplay) {
                var displayVal = eval >= 0 ? '+' + eval.toFixed(1) : eval.toFixed(1);
                valueDisplay.textContent = displayVal;
                valueDisplay.style.top = (100 - percentage) + '%';
            }
        }
        
        // =====================================================================
        // ULTRA ZAAWANSOWANA OCENA JAKO≈öCI RUCHU
        // Analizuje ka≈ºdy aspekt ruchu zgodnie ze wszystkimi zasadami gry
        // =====================================================================
        function getMoveIcon(evalChange, capturedPiece, causedCheck, moveInfo) {
            // moveInfo = { piece, toX, toY, fromX, fromY } - szczeg√≥≈Çy ruchu
            
            // Definicja warto≈õci figur - u≈ºywana w ca≈Çej funkcji
            var pieceValues = { king: 0, queen: 9, rook: 5, bishop: 3, knight: 3, pawn: 1 };
            
            var analysis = {
                score: 0,           // Punkty jako≈õci ruchu
                reasons: [],        // Powody oceny
                isBrilliant: false,
                isBlunder: false
            };
            
            var currentEval = evaluatePosition();
            var absEval = Math.abs(currentEval);
            var myColor = moveInfo ? moveInfo.piece.color : G.currentPlayer;
            var enemyColor = myColor === 'white' ? 'black' : 'white';
            
            // =====================================================================
            // 1. ANALIZA MATA I SZACHA
            // =====================================================================
            
            // Sprawd≈∫ czy ruch prowadzi do mata
            if (absEval > 100) {
                // Jest blisko mata
                var isWinningForMe = (myColor === 'white' && currentEval > 0) || 
                                     (myColor === 'black' && currentEval < 0);
                if (isWinningForMe && evalChange > 0) {
                    analysis.score += 50;
                    analysis.reasons.push('Prowadzi do mata');
                    analysis.isBrilliant = true;
                }
            }
            
            // Szach na kr√≥la
            if (causedCheck) {
                var mateProximity = evaluateMateProximity(enemyColor);
                
                if (mateProximity > 40) {
                    analysis.score += 40;
                    analysis.reasons.push('Szach z prawie matem!');
                    analysis.isBrilliant = true;
                } else if (mateProximity > 20) {
                    analysis.score += 25;
                    analysis.reasons.push('Silny szach');
                    analysis.isBrilliant = true;
                } else if (mateProximity > 10) {
                    analysis.score += 15;
                    analysis.reasons.push('Dobry szach');
                } else {
                    analysis.score += 8;
                    analysis.reasons.push('Szach');
                }
            }
            
            // =====================================================================
            // 2. ANALIZA ZBIƒÜ
            // =====================================================================
            
            if (capturedPiece) {
                var captureValue = pieceValues[capturedPiece.type] || 0;
                
                // Zbicie Phantoma (kr√≥l√≥wki) = natychmiastowe, mega dobre
                if (capturedPiece.type === 'queen') {
                    analysis.score += 35;
                    analysis.reasons.push('Zbicie Phantoma!');
                    analysis.isBrilliant = true;
                }
                // Zbicie wie≈ºy
                else if (capturedPiece.type === 'rook') {
                    analysis.score += 20;
                    analysis.reasons.push('Zbicie Nexa');
                }
                // Zbicie go≈Ñca/skoczka
                else if (capturedPiece.type === 'bishop' || capturedPiece.type === 'knight') {
                    analysis.score += 12;
                    analysis.reasons.push('Zbicie figury');
                }
                // Zbicie pionka
                else if (capturedPiece.type === 'pawn') {
                    analysis.score += 5;
                    analysis.reasons.push('Zbicie pionka');
                }
                
                // Czy zbicie by≈Ço czƒô≈õciƒÖ podw√≥jnego ataku?
                var wasDoubleAttack = checkIfDoubleAttackCapture(moveInfo);
                if (wasDoubleAttack) {
                    analysis.score += 15;
                    analysis.reasons.push('Podw√≥jny atak zako≈Ñczony!');
                }
            }
            
            // =====================================================================
            // 3. ANALIZA TWORZENIA ATAK√ìW/BLOKAD
            // =====================================================================
            
            if (moveInfo) {
                // Sprawd≈∫ czy ruch tworzy nowy atak
                var newAttacksCreated = countNewAttacksCreated(moveInfo);
                
                if (newAttacksCreated.onKing) {
                    analysis.score += 25;
                    analysis.reasons.push('Atak na kr√≥la!');
                }
                
                if (newAttacksCreated.doubleAttack) {
                    analysis.score += 30;
                    analysis.reasons.push('Utworzono podw√≥jny atak!');
                    analysis.isBrilliant = true;
                }
                
                if (newAttacksCreated.onQueen) {
                    analysis.score += 15;
                    analysis.reasons.push('Atak na Phantoma');
                }
                
                if (newAttacksCreated.onMajor > 0) {
                    analysis.score += newAttacksCreated.onMajor * 8;
                    analysis.reasons.push('Atak na figurƒô');
                }
                
                // =====================================================================
                // 3.5 KLUCZOWA ZASADA: Zablokowanie figury kt√≥ra mog≈Çaby atakowaƒá kr√≥la!
                // =====================================================================
                var blockedKingAttacker = checkIfBlockedKingAttacker(moveInfo, myColor);
                if (blockedKingAttacker) {
                    analysis.score += 20;
                    analysis.reasons.push('Zablokowa≈Ç figurƒô od ataku na kr√≥la!');
                    analysis.isBrilliant = true;
                }
            }
            
            // =====================================================================
            // 4. ANALIZA B≈ÅƒòD√ìW - BLUNDERS
            // =====================================================================
            
            // Drastyczny spadek eval = co≈õ posz≈Ço bardzo ≈∫le
            if (evalChange <= -8) {
                analysis.score -= 40;
                analysis.reasons.push('Du≈ºa strata pozycji');
                analysis.isBlunder = true;
            } else if (evalChange <= -5) {
                analysis.score -= 25;
                analysis.reasons.push('Znaczna strata');
            }
            
            // Phantom podstawiony pod bicie
            if (moveInfo && moveInfo.piece.type === 'queen' && !capturedPiece) {
                if (isSquareThreatened(moveInfo.toX, moveInfo.toY, enemyColor)) {
                    // Sprawd≈∫ czy mo≈ºe uciec
                    var canEscape = checkIfPieceCanEscape(moveInfo.toX, moveInfo.toY, moveInfo.piece);
                    if (!canEscape) {
                        analysis.score -= 50;
                        analysis.reasons.push('Phantom bez ucieczki!');
                        analysis.isBlunder = true;
                    } else {
                        analysis.score -= 15;
                        analysis.reasons.push('Phantom zagro≈ºony');
                    }
                }
            }
            
            // Cenna figura podstawiona pod bicie bez powodu
            if (moveInfo && !capturedPiece && !causedCheck) {
                var pieceVal = pieceValues[moveInfo.piece.type] || 0;
                if (pieceVal >= 3 && isSquareThreatened(moveInfo.toX, moveInfo.toY, enemyColor)) {
                    var canEscape = checkIfPieceCanEscape(moveInfo.toX, moveInfo.toY, moveInfo.piece);
                    if (!canEscape) {
                        analysis.score -= pieceVal * 4;
                        analysis.reasons.push('Figura bez ucieczki!');
                        analysis.isBlunder = true;
                    }
                }
            }
            
            // Nie uciek≈Ç figurƒÖ kt√≥ra jest pod podw√≥jnym atakiem
            var ignoredDoubleAttack = checkIfIgnoredDoubleAttack(moveInfo, myColor);
            if (ignoredDoubleAttack) {
                analysis.score -= 35;
                analysis.reasons.push('Nie uciek≈Ç przed podw√≥jnym atakiem!');
                analysis.isBlunder = true;
            }
            
            // Nie uciek≈Ç kr√≥lem kt√≥ry jest pod blokadƒÖ
            var ignoredKingThreat = checkIfIgnoredKingThreat(moveInfo, myColor);
            if (ignoredKingThreat) {
                analysis.score -= 45;
                analysis.reasons.push('Nie uciek≈Ç kr√≥lem!');
                analysis.isBlunder = true;
            }
            
            // =====================================================================
            // 4.5 B≈ÅƒÑD: Nie wykorzysta≈Ç okazji do zablokowania atakujƒÖcego kr√≥la
            // =====================================================================
            var missedBlockOpportunity = checkIfMissedBlockOpportunity(moveInfo, myColor);
            if (missedBlockOpportunity) {
                analysis.score -= 15;
                analysis.reasons.push('M√≥g≈Ç zablokowaƒá atakujƒÖcego kr√≥la!');
            }
            
            // =====================================================================
            // 5. ANALIZA POZYCYJNA
            // =====================================================================
            
            if (moveInfo && moveInfo.fromX !== undefined && moveInfo.fromY !== undefined) {
                // Kontrola centrum
                var toCenterBonus = getCenterControlBonus(moveInfo.toX, moveInfo.toY);
                var fromCenterPenalty = getCenterControlBonus(moveInfo.fromX, moveInfo.fromY);
                var centerChange = toCenterBonus - fromCenterPenalty;
                
                if (centerChange > 0) {
                    analysis.score += centerChange * 2;
                    if (centerChange >= 2) {
                        analysis.reasons.push('Lepsza kontrola centrum');
                    }
                }
                
                // Rozw√≥j figur (wyj≈õcie z linii startowej)
                if (moveInfo.piece && moveInfo.piece.type !== 'pawn' && moveInfo.piece.type !== 'king') {
                    var wasOnBackRank = (myColor === 'white' && moveInfo.fromY === 7) ||
                                        (myColor === 'black' && moveInfo.fromY === 0);
                    if (wasOnBackRank) {
                        analysis.score += 3;
                        analysis.reasons.push('Rozw√≥j figury');
                    }
                }
                
                // Awans pionka
                if (moveInfo.piece && moveInfo.piece.type === 'pawn') {
                    var promotionDistance = myColor === 'white' ? moveInfo.toY : (7 - moveInfo.toY);
                    if (promotionDistance <= 2) {
                        analysis.score += (3 - promotionDistance) * 5;
                        analysis.reasons.push('Pionek blisko promocji');
                    }
                }
                
                // Bezpiecze≈Ñstwo kr√≥la - czy ruch poprawia obronƒô?
                var kingSafetyChange = analyzeKingSafetyChange(moveInfo, myColor);
                if (kingSafetyChange > 5) {
                    analysis.score += kingSafetyChange;
                    analysis.reasons.push('Lepsza obrona kr√≥la');
                } else if (kingSafetyChange < -5) {
                    analysis.score += kingSafetyChange;
                    analysis.reasons.push('Os≈Çabiona obrona kr√≥la');
                }
            }
            
            // =====================================================================
            // 6. ANALIZA ZMIAN EVAL
            // =====================================================================
            
            // Podstawowa ocena na podstawie zmiany eval
            analysis.score += evalChange * 3;
            
            // =====================================================================
            // FINALNA DECYZJA O IKONIE
            // =====================================================================
            
            // Logowanie do konsoli dla debugowania
            if (analysis.reasons.length > 0) {
                console.log('Analiza ruchu:', analysis.reasons.join(', '), '| Score:', analysis.score.toFixed(1));
            }
            
            // Priorytety:
            if (analysis.isBlunder && analysis.score < -20) return 'blunder';
            if (analysis.isBrilliant && analysis.score > 25) return 'brilliant';
            
            // Na podstawie wyniku
            if (analysis.score >= 30) return 'brilliant';
            if (analysis.score >= 15) return 'great';
            if (analysis.score >= 5) return 'good';
            if (analysis.score >= -3) return 'book';
            if (analysis.score >= -10) return 'inaccuracy';
            if (analysis.score >= -20) return 'mistake';
            return 'blunder';
        }
        
        // =====================================================================
        // FUNKCJE POMOCNICZE DO ANALIZY RUCH√ìW
        // =====================================================================
        
        // Sprawd≈∫ czy zbicie by≈Ço wynikiem podw√≥jnego ataku
        function checkIfDoubleAttackCapture(moveInfo) {
            if (!moveInfo) return false;
            
            // Sprawd≈∫ czy na polu docelowym by≈Çy 2+ ataki przed ruchem
            var attacksOnTarget = 0;
            G.pendingCaptures.forEach(function(cap) {
                if (cap.targetX === moveInfo.toX && cap.targetY === moveInfo.toY) {
                    attacksOnTarget++;
                }
            });
            
            return attacksOnTarget >= 2;
        }
        
        // Policz nowe ataki utworzone przez ruch
        function countNewAttacksCreated(moveInfo) {
            var result = {
                onKing: false,
                onQueen: false,
                onMajor: 0,
                doubleAttack: false,
                total: 0
            };
            
            if (!moveInfo) return result;
            
            // Sprawd≈∫ wszystkie pendingCaptures utworzone przez tƒô figurƒô
            G.pendingCaptures.forEach(function(cap) {
                if (cap.attackerX === moveInfo.toX && cap.attackerY === moveInfo.toY) {
                    result.total++;
                    
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target) {
                        if (target.type === 'king') result.onKing = true;
                        else if (target.type === 'queen') result.onQueen = true;
                        else if (target.type === 'rook' || target.type === 'bishop' || target.type === 'knight') {
                            result.onMajor++;
                        }
                    }
                    
                    // Sprawd≈∫ czy tworzy podw√≥jny atak
                    var otherAttacks = G.pendingCaptures.filter(function(other) {
                        return other.targetX === cap.targetX && 
                               other.targetY === cap.targetY && 
                               other !== cap;
                    });
                    
                    if (otherAttacks.length > 0) {
                        result.doubleAttack = true;
                    }
                }
            });
            
            return result;
        }
        
        // Sprawd≈∫ czy figura mo≈ºe uciec z danego pola
        function checkIfPieceCanEscape(x, y, piece) {
            var moves = getAllMovesForPiece(x, y, piece, isPieceLocked(x, y));
            var enemyColor = piece.color === 'white' ? 'black' : 'white';
            
            for (var i = 0; i < moves.length; i++) {
                var path = moves[i];
                if (path.length > 1) {
                    var end = path[path.length - 1];
                    if (!isSquareThreatened(end.x, end.y, enemyColor)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Sprawd≈∫ czy gracz zignorowa≈Ç podw√≥jny atak na swojƒÖ figurƒô
        function checkIfIgnoredDoubleAttack(moveInfo, myColor) {
            if (!moveInfo) return false;
            if (moveInfo.fromX === undefined || moveInfo.fromY === undefined) return false;
            
            // Szukaj figur gracza kt√≥re sƒÖ pod podw√≥jnym atakiem
            var attacksPerSquare = {};
            G.pendingCaptures.forEach(function(cap) {
                if (cap.attackerColor !== myColor) {
                    var key = cap.targetX + ',' + cap.targetY;
                    if (!attacksPerSquare[key]) attacksPerSquare[key] = 0;
                    attacksPerSquare[key]++;
                }
            });
            
            for (var key in attacksPerSquare) {
                if (attacksPerSquare[key] >= 2) {
                    var coords = key.split(',');
                    var tx = parseInt(coords[0]), ty = parseInt(coords[1]);
                    var target = G.board[ty] ? G.board[ty][tx] : null;
                    
                    // Czy to nasza figura?
                    if (target && target.color === myColor && target.type !== 'king') {
                        // Czy ruszy≈Ç tƒÖ figurƒÖ?
                        if (moveInfo.fromX !== tx || moveInfo.fromY !== ty) {
                            // Nie ruszy≈Ç figurƒÖ pod podw√≥jnym atakiem!
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Sprawd≈∫ czy gracz zignorowa≈Ç zagro≈ºenie kr√≥la
        function checkIfIgnoredKingThreat(moveInfo, myColor) {
            if (!moveInfo) return false;
            
            // Sprawd≈∫ czy nasz kr√≥l jest pod bezpo≈õredniƒÖ blokadƒÖ z 1 turƒÖ
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.isNexusLock && cap.turnsLeft === 1) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target && target.type === 'king' && target.color === myColor) {
                        // Nasz kr√≥l jest pod atakiem!
                        // Czy ruszy≈Ç kr√≥lem?
                        if (moveInfo.piece.type !== 'king') {
                            // Nie ruszy≈Ç kr√≥lem gdy musia≈Ç!
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Bonus za kontrolƒô centrum
        function getCenterControlBonus(x, y) {
            // Centrum: d4, d5, e4, e5 (3,3), (3,4), (4,3), (4,4)
            if ((x === 3 || x === 4) && (y === 3 || y === 4)) return 3;
            // Rozszerzone centrum
            if (x >= 2 && x <= 5 && y >= 2 && y <= 5) return 1;
            return 0;
        }
        
        // Analiza zmiany bezpiecze≈Ñstwa kr√≥la
        function analyzeKingSafetyChange(moveInfo, myColor) {
            if (!moveInfo) return 0;
            if (moveInfo.fromX === undefined || moveInfo.fromY === undefined) return 0;
            if (moveInfo.toX === undefined || moveInfo.toY === undefined) return 0;
            
            // Znajd≈∫ naszego kr√≥la
            var kingPos = null;
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'king' && p.color === myColor) {
                        kingPos = {x: x, y: y};
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return 0;
            
            // Czy ruch przybli≈ºa figurƒô do kr√≥la (obrona)?
            var distBefore = Math.abs(moveInfo.fromX - kingPos.x) + Math.abs(moveInfo.fromY - kingPos.y);
            var distAfter = Math.abs(moveInfo.toX - kingPos.x) + Math.abs(moveInfo.toY - kingPos.y);
            
            // Je≈õli kr√≥l jest zagro≈ºony, zbli≈ºanie figur = dobre
            var kingInDanger = G.inCheck === myColor;
            
            if (kingInDanger && distAfter < distBefore && distAfter <= 2) {
                return 5; // Obrona kr√≥la
            }
            
            // Je≈õli oddalamy figurƒô od kr√≥la gdy jest zagro≈ºony = z≈Çe
            if (kingInDanger && distAfter > distBefore && distBefore <= 2) {
                return -5;
            }
            
            return 0;
        }
        
        // Sprawd≈∫ czy ruch zablokowa≈Ç figurƒô przeciwnika od ataku na naszego kr√≥la
        function checkIfBlockedKingAttacker(moveInfo, myColor) {
            if (!moveInfo) return false;
            
            var enemyColor = (myColor === 'white') ? 'black' : 'white';
            
            // Czy ten ruch utworzy≈Ç nowy atak (pendingCapture)?
            var newAttackOnEnemy = G.pendingCaptures.some(function(cap) {
                return cap.attackerX === moveInfo.toX && 
                       cap.attackerY === moveInfo.toY &&
                       cap.attackerColor === myColor;
            });
            
            if (!newAttackOnEnemy) return false;
            
            // Sprawd≈∫ czy zaatakowana figura mog≈Ça atakowaƒá naszego kr√≥la
            var ourKing = null;
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'king' && p.color === myColor) {
                        ourKing = {x: x, y: y};
                        break;
                    }
                }
                if (ourKing) break;
            }
            
            if (!ourKing) return false;
            
            // Sprawd≈∫ wszystkie nowo zaatakowane figury
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.attackerX === moveInfo.toX && cap.attackerY === moveInfo.toY) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target && target.color === enemyColor && target.type !== 'king') {
                        // Czy ta figura mog≈Ça dosiƒôgnƒÖƒá naszego kr√≥la?
                        var moves = getAllMovesForPieceIgnoringAttackBlock(cap.targetX, cap.targetY, target);
                        var couldReachKing = moves.some(function(path) {
                            var end = path[path.length - 1];
                            return end.x === ourKing.x && end.y === ourKing.y;
                        });
                        if (couldReachKing) {
                            return true; // Zablokowa≈Ç figurƒô kt√≥ra mog≈Ça atakowaƒá kr√≥la!
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Sprawd≈∫ czy gracz mia≈Ç okazjƒô zablokowaƒá figurƒô atakujƒÖcƒÖ kr√≥la ale jej nie wykorzysta≈Ç
        function checkIfMissedBlockOpportunity(moveInfo, myColor) {
            if (!moveInfo) return false;
            if (moveInfo.fromX === undefined || moveInfo.fromY === undefined) return false;
            
            var enemyColor = (myColor === 'white') ? 'black' : 'white';
            
            // Znajd≈∫ naszego kr√≥la
            var ourKing = null;
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'king' && p.color === myColor) {
                        ourKing = {x: x, y: y};
                        break;
                    }
                }
                if (ourKing) break;
            }
            
            if (!ourKing) return false;
            
            // Znajd≈∫ figury wroga kt√≥re mogƒÖ atakowaƒá naszego kr√≥la
            var threateningPieces = [];
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.color === enemyColor && p.type !== 'king') {
                        // Czy jest ju≈º pod atakiem? Je≈õli tak, nie mo≈ºe atakowaƒá kr√≥la
                        if (isPieceLocked(x, y)) continue;
                        
                        // Czy mo≈ºe dosiƒôgnƒÖƒá naszego kr√≥la?
                        if (canPieceReachSquare(x, y, ourKing.x, ourKing.y, p)) {
                            threateningPieces.push({x: x, y: y, piece: p});
                        }
                    }
                }
            }
            
            // Je≈õli nie ma gro≈∫nych figur, nie by≈Ço okazji
            if (threateningPieces.length === 0) return false;
            
            // Sprawd≈∫ czy ruszana figura mog≈Ça zaatakowaƒá kt√≥rƒÖ≈õ z gro≈∫nych figur
            var movedPiece = moveInfo.piece;
            for (var i = 0; i < threateningPieces.length; i++) {
                var threat = threateningPieces[i];
                // Czy mog≈Ça zaatakowaƒá tƒô figurƒô z poprzedniej pozycji?
                if (canPieceReachSquare(moveInfo.fromX, moveInfo.fromY, threat.x, threat.y, movedPiece)) {
                    // Mog≈Ça zaatakowaƒá gro≈∫nƒÖ figurƒô ale tego nie zrobi≈Ça!
                    // Sprawd≈∫ czy faktycznie zaatakowa≈Ça
                    var didAttack = G.pendingCaptures.some(function(cap) {
                        return cap.attackerX === moveInfo.toX && 
                               cap.attackerY === moveInfo.toY &&
                               cap.targetX === threat.x && 
                               cap.targetY === threat.y;
                    });
                    
                    if (!didAttack) {
                        return true; // Zmarnowana okazja!
                    }
                }
            }
            
            return false;
        }
        
        function updateMoveLog(text, color) {
            // Ta funkcja jest teraz tylko wrapperem - zapis stanu robi saveGameState
        }
        
        function getValidNextSteps() {
            if (!G.selectedPiece) return [];
            var piece = G.board[G.selectedPiece.y][G.selectedPiece.x];
            if (!piece) return [];
            var movesUsed = G.plannedPath.length - 1;
            var movesLeft = piece.moves - movesUsed;
            if (movesLeft <= 0) return [];
            var lastPos = G.plannedPath.length > 0 ? G.plannedPath[G.plannedPath.length - 1] : G.selectedPiece;
            var validMoves = [];
            var isLastStep = (movesLeft === 1);
            var weAreLocked = isPieceLocked(G.selectedPiece.x, G.selectedPiece.y);
            
            for (var key in DIRECTIONS) {
                var dir = DIRECTIONS[key];
                if (piece.straightOnly && dir.diagonal) continue;
                if (piece.diagonalOnly && !dir.diagonal) continue;
                if (dir.diagonal && G.usedDiagonal) continue;
                
                if (piece.type === 'pawn') {
                    var forward = piece.color === 'white' ? 'n' : 's';
                    var forwardDiags = piece.color === 'white' ? ['ne', 'nw'] : ['se', 'sw'];
                    if (key !== forward && forwardDiags.indexOf(key) === -1) continue;
                    var tx = lastPos.x + dir.dx, ty = lastPos.y + dir.dy;
                    var tp = G.board[ty] ? G.board[ty][tx] : null;
                    if (weAreLocked) { if (forwardDiags.indexOf(key) !== -1) continue; }
                    else { if (forwardDiags.indexOf(key) !== -1 && (!tp || tp.color === piece.color)) continue; }
                    if (key === forward && tp) continue;
                }
                
                var newX = lastPos.x + dir.dx, newY = lastPos.y + dir.dy;
                if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
                var targetPiece = G.board[newY][newX];
                if (targetPiece && targetPiece.color === piece.color) continue;
                if (G.plannedPath.some(function(p) { return p.x === newX && p.y === newY; })) continue;
                if (weAreLocked && targetPiece) continue;
                if (targetPiece && targetPiece.color !== piece.color && !isLastStep) continue;
                
                // Sprawd≈∫ Tarczƒô Sentinela - nie mo≈ºna wej≈õƒá na pola tarczy przeciwnika
                if (isBlockedByShield(newX, newY, piece.color)) continue;
                
                // KLUCZOWA ZASADA: Figura ZAGRO≈ªONA nie mo≈ºe atakowaƒá kr√≥la!
                // Zagro≈ºona = przeciwnik mo≈ºe jƒÖ zaatakowaƒá w nastƒôpnej turze
                // U≈ºywamy ORYGINALNEJ pozycji figury (G.selectedPiece)
                if (targetPiece && targetPiece.type === 'king') {
                    var originalX = G.selectedPiece.x;
                    var originalY = G.selectedPiece.y;
                    var enemyColor = (piece.color === 'white') ? 'black' : 'white';
                    
                    // Sprawd≈∫ czy nasza figura jest zagro≈ºona przez przeciwnika
                    var isThreatened = isSquareThreatened(originalX, originalY, enemyColor, true);
                    
                    if (isThreatened) {
                        console.log('Figura na', originalX, originalY, 'jest ZAGRO≈ªONA - nie mo≈ºe atakowaƒá kr√≥la!');
                        continue; // Figura zagro≈ºona nie mo≈ºe atakowaƒá kr√≥la!
                    }
                }
                
                validMoves.push({ x: newX, y: newY, diagonal: dir.diagonal });
            }
            return validMoves;
        }
        
        function isPieceAttacking(x, y) {
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                if (G.pendingCaptures[i].attackerX === x && G.pendingCaptures[i].attackerY === y) {
                    return true;
                }
            }
            return false;
        }
        
        // Strza≈Çki analizy (Shift+drag)
        var analysisArrows = []; // [{fromX, fromY, toX, toY}, ...]
        var analysisArrowStart = null; // {x, y} - poczƒÖtek rysowanej strza≈Çki
        var isShiftDown = false;
        var lastHoveredTile = null; // Ostatnie pole pod myszkƒÖ
        
        // Nas≈Çuchuj Shift
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Shift' && !isShiftDown) {
                isShiftDown = true;
                // Zacznij strza≈Çkƒô od pola pod myszkƒÖ
                if (lastHoveredTile) {
                    analysisArrowStart = {x: lastHoveredTile.x, y: lastHoveredTile.y};
                }
            }
        });
        
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') {
                // Zako≈Ñcz strza≈Çkƒô - zamie≈Ñ tymczasowe na sta≈Çe
                if (isShiftDown && analysisArrowStart) {
                    analysisArrows = analysisArrows.map(function(a) {
                        if (a.temp) {
                            return {fromX: a.fromX, fromY: a.fromY, toX: a.toX, toY: a.toY};
                        }
                        return a;
                    });
                    analysisArrowStart = null;
                }
                isShiftDown = false;
            }
        });
        
        function handleTileHover(x, y) {
            lastHoveredTile = {x: x, y: y};
            
            if (!isShiftDown) return;
            
            if (!analysisArrowStart) {
                // PoczƒÖtek strza≈Çki
                analysisArrowStart = {x: x, y: y};
            } else if (analysisArrowStart.x !== x || analysisArrowStart.y !== y) {
                // Aktualizuj lub dodaj strza≈Çkƒô
                // Usu≈Ñ poprzedniƒÖ tymczasowƒÖ strza≈Çkƒô z tego samego poczƒÖtku
                analysisArrows = analysisArrows.filter(function(a) {
                    return !(a.fromX === analysisArrowStart.x && a.fromY === analysisArrowStart.y && a.temp);
                });
                // Dodaj nowƒÖ tymczasowƒÖ
                analysisArrows.push({
                    fromX: analysisArrowStart.x,
                    fromY: analysisArrowStart.y,
                    toX: x,
                    toY: y,
                    temp: true
                });
                renderAnalysisArrows();
            }
        }
        
        function handleTileClick(x, y, event) {
            // Je≈õli Shift - nie r√≥b nic (strza≈Çki przez hover)
            if (event && event.shiftKey) {
                return;
            }
            
            // Normalny klik - usu≈Ñ strza≈Çki analizy
            if (analysisArrows.length > 0) {
                analysisArrows = [];
                analysisArrowStart = null;
                renderAnalysisArrows();
            }
            
            // W normalnej grze
            if (!G.gameOver && !G.analyzing) {
                handleNormalMove(x, y);
                return;
            }
            
            // W trybie analizy - w≈ÇƒÖcz what-if je≈õli nie aktywny (bez limitu ruch√≥w)
            if (G.analyzing) {
                if (!G.whatIfMode) {
                    startWhatIfMode();
                }
                handleWhatIfMove(x, y);
            }
        }
        
        function handleNormalMove(x, y) {
            // W trybie online sprawd≈∫ czy to twoja tura
            if (!canMakeMove()) return;
            
            var piece = G.board[y][x];
            
            // Sprawd≈∫ czy klikniƒôto na Stra≈ºnika (wirtualna figura)
            var guardianInfo = getGuardianAt(x, y);
            if (guardianInfo && guardianInfo.color === G.currentPlayer && !piece) {
                piece = {
                    symbol: SENTINEL_GUARDIAN.symbol,
                    name: SENTINEL_GUARDIAN.name,
                    moves: SENTINEL_GUARDIAN.moves,
                    type: 'guardian',
                    straightOnly: true,
                    color: guardianInfo.color,
                    isGuardian: true,
                    shieldIndex: guardianInfo.shieldIndex
                };
            }
            
            var validMoves = getValidNextSteps();
            
            if (!G.selectedPiece) {
                if (piece && piece.color === G.currentPlayer) {
                    if (isPieceAttacking(x, y)) return;
                    // Nie mo≈ºna ruszaƒá zamro≈ºonƒÖ figurƒÖ
                    if (piece.frozenTurns && piece.frozenTurns > 0) return;
                    G.selectedPiece = { x: x, y: y, isGuardian: piece.isGuardian, shieldIndex: piece.shieldIndex };
                    G.plannedPath = [{ x: x, y: y }];
                    G.usedDiagonal = false;
                    // Tymczasowo "postaw" stra≈ºnika na planszy ≈ºeby getValidNextSteps dzia≈Ça≈Ço
                    if (piece.isGuardian) {
                        G.board[y][x] = piece;
                    }
                    renderBoard(); updateUI();
                }
                return;
            }
            if (G.selectedPiece.x === x && G.selectedPiece.y === y && G.plannedPath.length === 1) {
                // Usu≈Ñ tymczasowego stra≈ºnika
                if (G.selectedPiece.isGuardian) {
                    G.board[y][x] = null;
                }
                G.selectedPiece = null; G.plannedPath = []; G.usedDiagonal = false;
                renderBoard(); updateUI();
                return;
            }
            
            var validMove = null;
            for (var i = 0; i < validMoves.length; i++) {
                if (validMoves[i].x === x && validMoves[i].y === y) { validMove = validMoves[i]; break; }
            }
            
            if (validMove) {
                if (validMove.diagonal) G.usedDiagonal = true;
                G.plannedPath.push({ x: x, y: y });
                var selectedPiece = G.board[G.selectedPiece.y][G.selectedPiece.x];
                var movesUsed = G.plannedPath.length - 1;
                var targetPiece = G.board[y][x];
                
                if (movesUsed >= selectedPiece.moves || targetPiece) { executeMove(); }
                else { renderBoard(); updateUI(); }
                return;
            }
            
            if (piece && piece.color === G.currentPlayer) {
                if (isPieceAttacking(x, y)) return;
                G.selectedPiece = { x: x, y: y }; G.plannedPath = [{ x: x, y: y }]; G.usedDiagonal = false;
                playSound('select');
                renderBoard(); updateUI();
            }
        }
        
        function handleWhatIfMove(x, y) {
            var piece = G.board[y][x];
            var validMoves = getValidNextSteps();
            
            if (!G.selectedPiece) {
                if (piece && piece.color === G.currentPlayer) {
                    if (isPieceAttacking(x, y)) return;
                    G.selectedPiece = { x: x, y: y };
                    G.plannedPath = [{ x: x, y: y }];
                    G.usedDiagonal = false;
                    renderBoard(); updateUI();
                }
                return;
            }
            if (G.selectedPiece.x === x && G.selectedPiece.y === y && G.plannedPath.length === 1) {
                G.selectedPiece = null; G.plannedPath = []; G.usedDiagonal = false;
                renderBoard(); updateUI();
                return;
            }
            
            var validMove = null;
            for (var i = 0; i < validMoves.length; i++) {
                if (validMoves[i].x === x && validMoves[i].y === y) { validMove = validMoves[i]; break; }
            }
            
            if (validMove) {
                if (validMove.diagonal) G.usedDiagonal = true;
                G.plannedPath.push({ x: x, y: y });
                var selectedPiece = G.board[G.selectedPiece.y][G.selectedPiece.x];
                var movesUsed = G.plannedPath.length - 1;
                var targetPiece = G.board[y][x];
                
                if (movesUsed >= selectedPiece.moves || targetPiece) { 
                    executeWhatIfMoveAction(); 
                }
                else { renderBoard(); updateUI(); }
                return;
            }
            
            if (piece && piece.color === G.currentPlayer) {
                if (isPieceAttacking(x, y)) return;
                G.selectedPiece = { x: x, y: y }; G.plannedPath = [{ x: x, y: y }]; G.usedDiagonal = false;
                renderBoard(); updateUI();
            }
        }
        
        function executeWhatIfMoveAction() {
            if (G.plannedPath.length < 2) return;
            
            var startPos = G.selectedPiece;
            var endPos = G.plannedPath[G.plannedPath.length - 1];
            var piece = G.board[startPos.y][startPos.x];
            var targetPiece = G.board[endPos.y][endPos.x];
            
            // KLUCZOWA ZASADA: Figura ZAGRO≈ªONA nie mo≈ºe atakowaƒá kr√≥la!
            var enemyColor = (piece.color === 'white') ? 'black' : 'white';
            var isThreatened = isSquareThreatened(startPos.x, startPos.y, enemyColor);
            
            if (targetPiece && targetPiece.type === 'king' && targetPiece.color !== piece.color) {
                if (isThreatened) {
                    // Figura zagro≈ºona pr√≥buje atakowaƒá kr√≥la - BLOKADA!
                    G.selectedPiece = null;
                    G.plannedPath = [];
                    renderBoard();
                    updateUI();
                    return;
                }
            }
            
            // Usu≈Ñ z blokady je≈õli uciekamy
            var wasLocked = isPieceLocked(startPos.x, startPos.y);
            if (wasLocked) {
                for (var i = G.pendingCaptures.length - 1; i >= 0; i--) {
                    if (G.pendingCaptures[i].targetX === startPos.x && G.pendingCaptures[i].targetY === startPos.y) {
                        G.pendingCaptures.splice(i, 1);
                        break;
                    }
                }
            }
            
            G.board[startPos.y][startPos.x] = null;
            
            if (targetPiece && targetPiece.color !== piece.color) {
                // Blokowanie w what-if
                if (targetPiece.type === 'king') {
                    // Blokada ju≈º sprawdzona na poczƒÖtku
                    G.pendingCaptures.push({ attackerX: startPos.x, attackerY: startPos.y, attackerColor: piece.color, attackerSymbol: piece.symbol, attackerPiece: JSON.parse(JSON.stringify(piece)), targetX: endPos.x, targetY: endPos.y, turnsLeft: 1, isNexusLock: true });
                    G.board[startPos.y][startPos.x] = piece;
                } else {
                    G.pendingCaptures.push({ attackerX: startPos.x, attackerY: startPos.y, attackerColor: piece.color, attackerSymbol: piece.symbol, attackerPiece: JSON.parse(JSON.stringify(piece)), targetX: endPos.x, targetY: endPos.y, turnsLeft: 2, isNexusLock: false });
                    G.board[startPos.y][startPos.x] = piece;
                }
            } else {
                G.board[endPos.y][endPos.x] = piece;
                // Promocja
                if (piece.type === 'pawn' && ((piece.color === 'white' && endPos.y === 0) || (piece.color === 'black' && endPos.y === 7))) {
                    Object.assign(piece, PIECES.QUEEN, { color: piece.color });
                }
            }
            
            G.selectedPiece = null; G.plannedPath = []; G.usedDiagonal = false;
            
            // Prosta zmiana gracza (bez pe≈Çnej logiki processPendingCaptures)
            G.currentPlayer = G.currentPlayer === 'white' ? 'black' : 'white';
            
            G.whatIfRounds++;
            updateWhatIfDisplay();
            
            renderBoard();
            updateUI();
        }
        
        function executeMove() {
            if (G.plannedPath.length < 2) return;
            if (G.analyzing) return;
            if (G.isAnimating) return;
            
            // Automatycznie odrzuƒá propozycjƒô remisu przy ruchu
            if (G.gameMode === 'online') {
                autoDeclineDrawOnMove();
            }
            
            // Zapisz eval przed ruchem
            G.evalBefore = evaluatePosition();
            
            var startPos = G.selectedPiece;
            var endPos = G.plannedPath[G.plannedPath.length - 1];
            var piece = G.board[startPos.y][startPos.x];
            var targetPiece = G.board[endPos.y][endPos.x];
            var moveColor = G.currentPlayer;
            
            // Wy≈õlij ruch do przeciwnika (online)
            if (G.gameMode === 'online' && peerConnection) {
                sendOnlineMove(startPos, endPos, G.plannedPath, piece.isGuardian);
            }
            
            // Je≈õli to atak - BEZ animacji (figura zostaje na miejscu)
            if (targetPiece && targetPiece.color !== piece.color) {
                finishMove(startPos, endPos, piece, targetPiece, moveColor);
                return;
            }
            
            // Normalny ruch - animacja do ko≈Ñcowej pozycji
            animateMove(startPos.x, startPos.y, endPos.x, endPos.y, piece, function() {
                finishMove(startPos, endPos, piece, targetPiece, moveColor);
            });
        }
        
        function finishMove(startPos, endPos, piece, targetPiece, moveColor) {
            var moveDesc = '';
            var madeAttack = false; // Czy ten ruch to atak?
            
            // KLUCZOWA ZASADA: Figura ZAGRO≈ªONA nie mo≈ºe atakowaƒá kr√≥la!
            // Zagro≈ºona = przeciwnik mo≈ºe jƒÖ zaatakowaƒá w nastƒôpnej turze
            var enemyColor = (piece.color === 'white') ? 'black' : 'white';
            var isThreatened = isSquareThreatened(startPos.x, startPos.y, enemyColor);
            
            if (targetPiece && targetPiece.type === 'king' && targetPiece.color !== piece.color) {
                if (isThreatened) {
                    // Figura zagro≈ºona pr√≥buje atakowaƒá kr√≥la - BLOKADA!
                    G.selectedPiece = null;
                    G.plannedPath = [];
                    renderBoard();
                    updateUI();
                    return;
                }
            }
            
            // Usu≈Ñ z blokady je≈õli uciekamy (tylko je≈õli faktycznie by≈Ça zablokowana)
            var wasLocked = isPieceLocked(startPos.x, startPos.y);
            if (wasLocked) {
                for (var i = G.pendingCaptures.length - 1; i >= 0; i--) {
                    if (G.pendingCaptures[i].targetX === startPos.x && G.pendingCaptures[i].targetY === startPos.y) {
                        G.pendingCaptures.splice(i, 1);
                        moveDesc = piece.symbol + ' uciek≈Ç!';
                        break;
                    }
                }
            }
            
            G.board[startPos.y][startPos.x] = null;
            
            // Stra≈ºnik - zamra≈ºa wroga na 2 tury i znika (tarcza te≈º znika)
            if (piece.isGuardian && targetPiece && targetPiece.color !== piece.color) {
                madeAttack = true;
                // Zamro≈∫ ofiarƒô
                if (!targetPiece.frozenTurns) targetPiece.frozenTurns = 0;
                targetPiece.frozenTurns = 2;
                moveDesc = moveDesc || (piece.symbol + ' zamra≈ºa ' + targetPiece.symbol + ' na 2 tury!');
                // Stra≈ºnik znika - tarcza zostaje rozwiƒÖzana automatycznie bo wie≈ºe siƒô nie zmieni≈Çy
                // Ale musimy usunƒÖƒá tymczasowƒÖ figurƒô
                G.board[startPos.y][startPos.x] = null;
            }
            else if (targetPiece && targetPiece.color !== piece.color) {
                madeAttack = true;
                
                // NOWA ZASADA: Atak na figurƒô kt√≥ra sama atakuje = ≈Ça≈Ñcuch zbiƒá!
                // AtakujƒÖcy zbija swojƒÖ ofiarƒô, a my zajmujemy jego miejsce
                var targetIsAttacking = null;
                for (var i = 0; i < G.pendingCaptures.length; i++) {
                    var cap = G.pendingCaptures[i];
                    if (cap.attackerX === endPos.x && cap.attackerY === endPos.y) {
                        targetIsAttacking = cap;
                        break;
                    }
                }
                
                if (targetIsAttacking) {
                    // ≈Åa≈Ñcuch zbiƒá!
                    var victim = G.board[targetIsAttacking.targetY] ? G.board[targetIsAttacking.targetY][targetIsAttacking.targetX] : null;
                    
                    if (victim && victim.color !== targetPiece.color) {
                        // 1. AtakujƒÖcy (targetPiece) zbija swojƒÖ ofiarƒô
                        (victim.color === 'white' ? G.capturedByBlack : G.capturedByWhite).push(victim);
                        G.board[targetIsAttacking.targetY][targetIsAttacking.targetX] = targetPiece;
                        if (!targetPiece.kills) targetPiece.kills = 0;
                        targetPiece.kills++;
                        
                        // 2. My (piece) zajmujemy miejsce atakujƒÖcego
                        G.board[endPos.y][endPos.x] = piece;
                        if (!piece.kills) piece.kills = 0;
                        // Nie zwiƒôkszamy kills bo nie zbili≈õmy nikogo bezpo≈õrednio
                        
                        // 3. Usu≈Ñ blokadƒô z pendingCaptures
                        G.pendingCaptures.splice(i, 1);
                        
                        moveDesc = '≈Åa≈Ñcuch! ' + piece.symbol + ' wypycha ' + targetPiece.symbol + ' ‚Üí ' + targetPiece.symbol + ' zbija ' + victim.symbol + '!';
                        playSound('capture');
                    } else {
                        // Ofiara uciek≈Ça - normalny atak na atakujƒÖcego
                        G.pendingCaptures.push({ attackerX: startPos.x, attackerY: startPos.y, attackerColor: piece.color, attackerSymbol: piece.symbol, attackerPiece: JSON.parse(JSON.stringify(piece)), targetX: endPos.x, targetY: endPos.y, turnsLeft: 2, isNexusLock: false });
                        G.board[startPos.y][startPos.x] = piece;
                        moveDesc = moveDesc || (piece.symbol + ' blokuje ' + targetPiece.symbol + '!');
                        playSound('capture');
                    }
                }
                // Ofiara Phantom - natychmiastowe zbicie (Phantom nie mo≈ºe uciec)
                else if (targetPiece.type === 'queen') {
                    (targetPiece.color === 'white' ? G.capturedByBlack : G.capturedByWhite).push(targetPiece);
                    G.board[endPos.y][endPos.x] = piece;
                    // Licznik zbiƒá
                    if (!piece.kills) piece.kills = 0;
                    piece.kills++;
                    moveDesc = moveDesc || (piece.symbol + ' zbija ' + targetPiece.symbol + '!');
                    playSound('capture');
                }
                // Nexus jako ofiara - 1 tura na ucieczkƒô
                else if (targetPiece.type === 'king') {
                    // Blokada jest ju≈º sprawdzona na poczƒÖtku finishMove
                    // Normalny szach
                    G.inCheck = targetPiece.color;
                    G.pendingCaptures.push({ attackerX: startPos.x, attackerY: startPos.y, attackerColor: piece.color, attackerSymbol: piece.symbol, attackerPiece: JSON.parse(JSON.stringify(piece)), targetX: endPos.x, targetY: endPos.y, turnsLeft: 1, isNexusLock: true });
                    G.board[startPos.y][startPos.x] = piece;
                    moveDesc = moveDesc || (piece.symbol + ' blokuje ' + targetPiece.symbol + '!');
                    playSound('check');
                }
                // Inne figury jako ofiara - 2 tury na ucieczkƒô
                else {
                    G.pendingCaptures.push({ attackerX: startPos.x, attackerY: startPos.y, attackerColor: piece.color, attackerSymbol: piece.symbol, attackerPiece: JSON.parse(JSON.stringify(piece)), targetX: endPos.x, targetY: endPos.y, turnsLeft: 2, isNexusLock: false });
                    G.board[startPos.y][startPos.x] = piece;
                    moveDesc = moveDesc || (piece.symbol + ' blokuje ' + targetPiece.symbol + '!');
                    playSound('capture');
                }
            } else {
                // Stra≈ºnik nie mo≈ºe siƒô ruszaƒá bez ataku - tylko zamra≈ºa
                if (piece.isGuardian) {
                    // Nic nie r√≥b - stra≈ºnik wraca na miejsce
                    G.board[startPos.y][startPos.x] = null; // Usu≈Ñ tymczasowego stra≈ºnika
                    playSound('castle');
                } else {
                    G.board[endPos.y][endPos.x] = piece;
                    
                    // ≈öled≈∫ historiƒô pozycji figury (dla potr√≥jnego powt√≥rzenia)
                    if (checkTripleRepetition(piece, endPos.x, endPos.y)) {
                        endGame(null, 'repetition');
                        return;
                    }
                    
                    moveDesc = moveDesc || (piece.symbol + ' ' + String.fromCharCode(97 + startPos.x) + (8 - startPos.y) + '‚Üí' + String.fromCharCode(97 + endPos.x) + (8 - endPos.y));
                    if (piece.type === 'pawn' && ((piece.color === 'white' && endPos.y === 0) || (piece.color === 'black' && endPos.y === 7))) {
                        Object.assign(piece, PIECES.QUEEN, { color: piece.color });
                        moveDesc += ' (Promocja!)';
                        playSound('promote');
                    } else {
                        playSound('move');
                    }
                }
            }
            
            G.selectedPiece = null; G.plannedPath = []; G.usedDiagonal = false;
            addTimeIncrement();
            
            // Oblicz ocenƒô ruchu
            var evalAfter = evaluatePosition();
            var evalChange = moveColor === 'white' ? (evalAfter - G.evalBefore) : (G.evalBefore - evalAfter);
            
            // Zapisz ostatni ruch z ocenƒÖ
            var moveIcon = getMoveIcon(evalChange, targetPiece, G.inCheck, { piece: piece, toX: endPos.x, toY: endPos.y, fromX: startPos.x, fromY: startPos.y });
            G.lastMove = {
                endX: endPos.x,
                endY: endPos.y,
                color: moveColor,
                icon: moveIcon
            };
            
            // Dodaj/odejmij ELO za ruch gracza (tylko w grze z botem, online lub mistrzostwach)
            var isPlayerMove = false;
            if ((G.gameMode === 'bot' || G.gameMode === 'championship') && moveColor === 'white') {
                isPlayerMove = true;
            } else if (G.gameMode === 'online' && moveColor === myColor) {
                isPlayerMove = true;
            }
            
            if (isPlayerMove) {
                var eloChange = calculateEloForMove(moveIcon, G.inCheck === (moveColor === 'white' ? 'black' : 'white'), false);
                if (eloChange !== 0) {
                    addElo(eloChange, moveIcon);
                }
            }
            
            // Zapisz stan przed processPendingCaptures
            saveGameState(moveDesc, moveColor);
            
            // Licznik ruch√≥w bez ataku (dla automatycznego remisu)
            // Ruchy pionkami (Shard) nie liczƒÖ siƒô do tego licznika
            if (madeAttack) {
                G.movesWithoutAttack = 0;
            } else if (piece.type !== 'pawn') {
                // Tylko ruchy NIE-pionkami zwiƒôkszajƒÖ licznik
                G.movesWithoutAttack++;
                
                // Remis po 10 ruchach bez ataku (nie liczƒÖc pionk√≥w)
                if (G.movesWithoutAttack >= 10 && G.pendingCaptures.length === 0) {
                    endGame(null, 'pat');
                    return;
                }
            }
            // Ruchy pionkami nie zmieniajƒÖ licznika
            
            console.log('finishMove: przed processPendingCaptures, currentPlayer:', G.currentPlayer);
            processPendingCaptures();
            console.log('finishMove: po processPendingCaptures, currentPlayer:', G.currentPlayer, 'gameOver:', G.gameOver);
            if (!G.gameOver) {
                switchTurn();
            }
        }
        
        function processPendingCaptures() {
            var newPending = [];
            var captureHappened = false;
            var captureDesc = '';
            var captureColor = '';
            var gameEnded = false;
            
            // Sprawd≈∫ czy jakie≈õ pole jest atakowane przez 2+ figury
            var attackCounts = {};
            G.pendingCaptures.forEach(function(cap) {
                var key = cap.targetX + ',' + cap.targetY;
                if (!attackCounts[key]) {
                    attackCounts[key] = [];
                }
                attackCounts[key].push(cap);
            });
            
            // Je≈õli figura jest atakowana przez 2+, natychmiastowe zbicie
            for (var key in attackCounts) {
                if (attackCounts[key].length >= 2) {
                    var firstAttack = attackCounts[key][0]; // Pierwszy atakujƒÖcy wchodzi
                    var targetPiece = G.board[firstAttack.targetY] ? G.board[firstAttack.targetY][firstAttack.targetX] : null;
                    
                    if (targetPiece && targetPiece.color !== firstAttack.attackerColor) {
                        // Nexus pod podw√≥jnym atakiem = mat
                        if (targetPiece.type === 'king') {
                            endGame(firstAttack.attackerColor, 'mat');
                            return; // Tutaj return jest OK bo to zwyk≈Ça pƒôtla for
                        }
                        
                        // Zbij figurƒô
                        (targetPiece.color === 'white' ? G.capturedByBlack : G.capturedByWhite).push(targetPiece);
                        G.board[firstAttack.targetY][firstAttack.targetX] = firstAttack.attackerPiece;
                        
                        // Licznik zbiƒá dla atakujƒÖcego
                        var attackerOnBoard = G.board[firstAttack.targetY][firstAttack.targetX];
                        if (attackerOnBoard) {
                            if (!attackerOnBoard.kills) attackerOnBoard.kills = 0;
                            attackerOnBoard.kills++;
                        }
                        
                        // Usu≈Ñ pierwszego atakujƒÖcego z jego pozycji
                        if (G.board[firstAttack.attackerY] && G.board[firstAttack.attackerY][firstAttack.attackerX] && 
                            G.board[firstAttack.attackerY][firstAttack.attackerX].symbol === firstAttack.attackerSymbol) {
                            G.board[firstAttack.attackerY][firstAttack.attackerX] = null;
                        }
                        
                        // Usu≈Ñ wszystkich atakujƒÖcych z tego pola z pending (ale nie pierwszego kt√≥ry ju≈º wszed≈Ç)
                        attackCounts[key].forEach(function(cap, index) {
                            if (index > 0) {
                                // Drugi i kolejni atakujƒÖcy wracajƒÖ na swoje pozycje (zostajƒÖ w miejscu)
                            }
                        });
                        
                        captureHappened = true;
                        captureDesc = 'Podw√≥jny atak! ' + firstAttack.attackerSymbol + ' zbija ' + targetPiece.symbol + '!';
                        captureColor = firstAttack.attackerColor;
                        console.log('PODW√ìJNY ATAK! Zbito:', targetPiece.symbol, 'przez:', firstAttack.attackerSymbol);
                        
                        // Zapisz pozycje atakujƒÖcych do pod≈õwietlenia na zielono
                        G.doubleAttackPieces = [];
                        attackCounts[key].forEach(function(cap, index) {
                            if (index === 0) {
                                // Pierwszy atakujƒÖcy wszed≈Ç na miejsce ofiary
                                G.doubleAttackPieces.push({ x: firstAttack.targetX, y: firstAttack.targetY });
                            } else {
                                // Pozostali zostali na swoich pozycjach
                                G.doubleAttackPieces.push({ x: cap.attackerX, y: cap.attackerY });
                            }
                        });
                        
                        // Oznacz te ataki jako zako≈Ñczone
                        attackCounts[key].forEach(function(cap) {
                            cap.resolved = true;
                        });
                    }
                }
            }
            
            // Przetw√≥rz pozosta≈Çe blokady (u≈ºywamy zwyk≈Çej pƒôtli for zamiast forEach)
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                
                // Pomi≈Ñ ju≈º rozwiƒÖzane ataki
                if (cap.resolved) continue;
                
                var targetPiece = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                
                // Ofiara uciek≈Ça - atakujƒÖcy wchodzi na jej pole
                if (!targetPiece || targetPiece.color === cap.attackerColor) {
                    // Przenie≈õ atakujƒÖcego na pole gdzie by≈Ça ofiara
                    G.board[cap.targetY][cap.targetX] = cap.attackerPiece;
                    if (G.board[cap.attackerY] && G.board[cap.attackerY][cap.attackerX] && 
                        G.board[cap.attackerY][cap.attackerX].symbol === cap.attackerSymbol) {
                        G.board[cap.attackerY][cap.attackerX] = null;
                    }
                    continue; // Nie dodawaj do newPending
                }
                
                // Zmniejsz licznik tylko gdy to tura obro≈Ñcy
                if (targetPiece.color === G.currentPlayer) {
                    cap.turnsLeft--;
                    if (cap.turnsLeft <= 0) {
                        // Czas minƒÖ≈Ç - zbicie!
                        if (cap.isNexusLock) {
                            // Mat - Nexus nie uciek≈Ç w czasie
                            endGame(cap.attackerColor, 'mat');
                            gameEnded = true;
                            break; // Przerwij pƒôtlƒô
                        }
                        (targetPiece.color === 'white' ? G.capturedByBlack : G.capturedByWhite).push(targetPiece);
                        G.board[cap.targetY][cap.targetX] = cap.attackerPiece;
                        
                        // Licznik zbiƒá dla atakujƒÖcego
                        var attackerOnBoard = G.board[cap.targetY][cap.targetX];
                        if (attackerOnBoard) {
                            if (!attackerOnBoard.kills) attackerOnBoard.kills = 0;
                            attackerOnBoard.kills++;
                        }
                        
                        if (G.board[cap.attackerY] && G.board[cap.attackerY][cap.attackerX] && G.board[cap.attackerY][cap.attackerX].symbol === cap.attackerSymbol) {
                            G.board[cap.attackerY][cap.attackerX] = null;
                        }
                        captureHappened = true;
                        captureDesc = cap.attackerSymbol + ' zbija ' + targetPiece.symbol + '!';
                        captureColor = cap.attackerColor;
                        console.log('ZBICIE PO CZASIE! Zbito:', targetPiece.symbol, 'przez:', cap.attackerSymbol);
                        continue; // Nie dodawaj do newPending
                    }
                }
                newPending.push(cap);
            }
            
            if (gameEnded) return;
            
            G.pendingCaptures = newPending;
            G.inCheck = null;
            G.pendingCaptures.forEach(function(cap) {
                if (cap.isNexusLock) {
                    var t = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (t && t.type === 'king') G.inCheck = t.color;
                }
            });
            
            if (captureHappened) {
                saveGameState(captureDesc, captureColor);
            }
        }
        
        // Sprawd≈∫ potr√≥jne powt√≥rzenie pozycji figury
        function checkTripleRepetition(piece, x, y) {
            // Utw√≥rz unikalny identyfikator figury
            if (!piece.uid) {
                piece.uid = piece.color + '_' + piece.type + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            var posKey = x + ',' + y;
            
            if (!G.piecePositionHistory[piece.uid]) {
                G.piecePositionHistory[piece.uid] = {};
            }
            
            if (!G.piecePositionHistory[piece.uid][posKey]) {
                G.piecePositionHistory[piece.uid][posKey] = 0;
            }
            
            G.piecePositionHistory[piece.uid][posKey]++;
            
            // Je≈õli ta sama figura stanƒô≈Ça na tym samym polu 3 razy = remis
            if (G.piecePositionHistory[piece.uid][posKey] >= 3) {
                return true;
            }
            
            return false;
        }
        
        function switchTurn() {
            console.log('switchTurn: zmiana z', G.currentPlayer, 'na', G.currentPlayer === 'white' ? 'black' : 'white');
            G.currentPlayer = G.currentPlayer === 'white' ? 'black' : 'white';
            
            // Wyczy≈õƒá pod≈õwietlenie podw√≥jnego ataku
            G.doubleAttackPieces = [];
            
            // Sprawd≈∫ Tarcze Sentineli
            checkSentinelShields();
            
            // Odliczaj zamro≈ºenie figur aktualnego gracza
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.color === G.currentPlayer) {
                        if (p.frozenTurns && p.frozenTurns > 0) {
                            p.frozenTurns--;
                        }
                    }
                }
            }
            
            // Sprawd≈∫ czy Nexus jest zablokowany i czy ma gdzie uciec
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.isNexusLock) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target && target.type === 'king' && target.color === G.currentPlayer) {
                        // Nexus jest zablokowany - sprawd≈∫ czy ma bezpieczne pola do ucieczki
                        var nexusMoves = getAllMovesForPiece(cap.targetX, cap.targetY, target, true);
                        if (nexusMoves.length === 0) { 
                            // Brak bezpiecznych p√≥l = mat
                            endGame(G.currentPlayer === 'white' ? 'black' : 'white', 'mat'); 
                            return; 
                        }
                    }
                }
            }
            
            renderBoard(); updateUI(); updateEvalBar();
            if (G.gameOver) return;
            if (!hasLegalMoves(G.currentPlayer)) {
                if (G.inCheck === G.currentPlayer) { endGame(G.currentPlayer === 'white' ? 'black' : 'white', 'mat'); }
                else { endGame(null, 'pat'); }
                return;
            }
            if ((G.gameMode === 'bot' || G.gameMode === 'championship') && G.currentPlayer === 'black' && !G.gameOver) {
                var delay = G.difficulty === 'easy' ? 1000 : G.difficulty === 'hard' ? 2500 : 1500;
                // Mistrzostwa - czas my≈õlenia zale≈ºy od ELO
                if (G.gameMode === 'championship' && G.botThinkMultiplier) {
                    delay = Math.floor(delay * G.botThinkMultiplier);
                }
                setTimeout(makeBotMove, delay);
            }
        }
        
        function hasLegalMoves(color) {
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var piece = G.board[y][x];
                    if (piece && piece.color === color) {
                        // Figura kt√≥ra atakuje nie mo≈ºe siƒô ruszaƒá
                        if (isPieceAttacking(x, y)) continue;
                        // Zamro≈ºona figura nie mo≈ºe siƒô ruszaƒá
                        if (piece.frozenTurns && piece.frozenTurns > 0) continue;
                        if (getAllMovesForPiece(x, y, piece, isPieceLocked(x, y)).length > 0) return true;
                    }
                }
            }
            return false;
        }
        
        // Sprawdza czy pole (x,y) mo≈ºe byƒá zaatakowane przez gracza enemyColor
        function isSquareThreatened(x, y, enemyColor, debug) {
            for (var py = 0; py < 8; py++) {
                for (var px = 0; px < 8; px++) {
                    var piece = G.board[py][px];
                    if (!piece || piece.color !== enemyColor) continue;
                    // Sprawd≈∫ czy ta figura mo≈ºe dotrzeƒá na pole (x,y)
                    if (canPieceReachSquare(px, py, x, y, piece)) {
                        if (debug) {
                            console.log('Pole', x, y, 'zagro≈ºone przez', piece.type, 'na', px, py);
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Sprawdza czy figura z (fromX,fromY) mo≈ºe dotrzeƒá na (toX,toY)
        function canPieceReachSquare(fromX, fromY, toX, toY, piece) {
            // Specjalna logika dla pionka (Shard) - zagra≈ºa pola gdzie mo≈ºe siƒô ruszyƒá
            if (piece.type === 'pawn') {
                var forwardDir = piece.color === 'white' ? -1 : 1; // bia≈Çy idzie w g√≥rƒô (y maleje), czarny w d√≥≈Ç
                var dy = toY - fromY;
                var dx = toX - fromX;
                
                // Pionek zagra≈ºa:
                // 1. Pole prosto do przodu (tam gdzie mo≈ºe i≈õƒá)
                // 2. Pola po skosie do przodu (tam gdzie mo≈ºe zbijaƒá)
                if (dy === forwardDir) {
                    // Prosto do przodu (dx === 0) lub po skosie (dx === 1 lub -1)
                    if (Math.abs(dx) <= 1) {
                        return true;
                    }
                }
                return false;
            }
            
            // Bezpo≈õredni sƒÖsiad - 1 krok wystarczy dla ka≈ºdej figury z >= 1 moves
            var directDx = Math.abs(toX - fromX);
            var directDy = Math.abs(toY - fromY);
            if (directDx <= 1 && directDy <= 1 && (directDx + directDy) > 0 && piece.moves >= 1) {
                var isDiag = (directDx === 1 && directDy === 1);
                if (isDiag && piece.straightOnly) { /* nie mo≈ºe */ }
                else if (!isDiag && piece.diagonalOnly) { /* nie mo≈ºe */ }
                else {
                    return true;
                }
            }
            
            var visited = {};
            var queue = [{ x: fromX, y: fromY, steps: 0, usedDiag: false }];
            visited[fromX + ',' + fromY] = true;
            
            while (queue.length > 0) {
                var current = queue.shift();
                if (current.steps >= piece.moves) continue;
                
                for (var key in DIRECTIONS) {
                    var dir = DIRECTIONS[key];
                    if (piece.straightOnly && dir.diagonal) continue;
                    if (piece.diagonalOnly && !dir.diagonal) continue;
                    if (dir.diagonal && current.usedDiag) continue;
                    
                    var newX = current.x + dir.dx;
                    var newY = current.y + dir.dy;
                    if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
                    
                    var visitKey = newX + ',' + newY + ',' + (current.usedDiag || dir.diagonal);
                    if (visited[visitKey]) continue;
                    
                    var targetPiece = G.board[newY][newX];
                    // Nie mo≈ºe przej≈õƒá przez w≈Çasne figury
                    if (targetPiece && targetPiece.color === piece.color) continue;
                    
                    // Czy to jest pole docelowe?
                    if (newX === toX && newY === toY) return true;
                    
                    // Nie mo≈ºe przej≈õƒá przez wrogie figury (ale mo≈ºe na nich sko≈Ñczyƒá)
                    if (targetPiece && targetPiece.color !== piece.color) continue;
                    
                    visited[visitKey] = true;
                    queue.push({ x: newX, y: newY, steps: current.steps + 1, usedDiag: current.usedDiag || dir.diagonal });
                }
            }
            return false;
        }
        
        // Sprawdza czy figura na polu (x, y) jest AKTUALNIE ATAKOWANA (jest w pendingCaptures jako cel)
        function isPieceUnderAttack(x, y) {
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.targetX === x && cap.targetY === y) {
                    return true;
                }
            }
            return false;
        }
        
        function getAllMovesForPiece(startX, startY, piece, isLocked) {
            var allMoves = [];
            var enemyColor = piece.color === 'white' ? 'black' : 'white';
            
            function explore(path, usedDiag) {
                if (path.length > piece.moves + 1) return;
                var isLastStep = (path.length === piece.moves + 1);
                if (path.length > 1) {
                    var last = path[path.length - 1];
                    var targetPiece = G.board[last.y] ? G.board[last.y][last.x] : null;
                    
                    // Nexus nie mo≈ºe wchodziƒá na zagro≈ºone pola
                    if (piece.type === 'king') {
                        // Tymczasowo usu≈Ñ Nexusa z planszy do sprawdzenia zagro≈ºe≈Ñ
                        var originalPiece = G.board[startY][startX];
                        G.board[startY][startX] = null;
                        var isThreatened = isSquareThreatened(last.x, last.y, enemyColor);
                        G.board[startY][startX] = originalPiece;
                        if (isThreatened) return; // Nie dodawaj tego ruchu
                    }
                    
                    if (isLocked) { if (!targetPiece) allMoves.push(path.slice()); }
                    else { if (!targetPiece || (targetPiece.color !== piece.color && isLastStep)) allMoves.push(path.slice()); }
                }
                if (path.length >= piece.moves + 1) return;
                var lastPos = path[path.length - 1];
                for (var key in DIRECTIONS) {
                    var dir = DIRECTIONS[key];
                    if (piece.straightOnly && dir.diagonal) continue;
                    if (piece.diagonalOnly && !dir.diagonal) continue;
                    if (dir.diagonal && usedDiag) continue;
                    if (piece.type === 'pawn') {
                        var forward = piece.color === 'white' ? 'n' : 's';
                        var forwardDiags = piece.color === 'white' ? ['ne', 'nw'] : ['se', 'sw'];
                        if (key !== forward && forwardDiags.indexOf(key) === -1) continue;
                        var tx = lastPos.x + dir.dx, ty = lastPos.y + dir.dy;
                        var tp = G.board[ty] ? G.board[ty][tx] : null;
                        if (isLocked) { if (forwardDiags.indexOf(key) !== -1) continue; }
                        else { if (forwardDiags.indexOf(key) !== -1 && (!tp || tp.color === piece.color)) continue; }
                        if (key === forward && tp) continue;
                    }
                    var newX = lastPos.x + dir.dx, newY = lastPos.y + dir.dy;
                    if (newX < 0 || newX > 7 || newY < 0 || newY > 7) continue;
                    var targetPiece = G.board[newY][newX];
                    if (targetPiece && targetPiece.color === piece.color) continue;
                    var inPath = false;
                    for (var i = 0; i < path.length; i++) { if (path[i].x === newX && path[i].y === newY) { inPath = true; break; } }
                    if (inPath) continue;
                    if (isLocked && targetPiece) continue;
                    
                    // Sprawd≈∫ Tarczƒô Sentinela - nie mo≈ºna wej≈õƒá na pola tarczy przeciwnika
                    if (isBlockedByShield(newX, newY, piece.color)) continue;
                    
                    // Je≈õli na polu jest wroga figura - mo≈ºna tam wej≈õƒá tylko jako ostatni krok
                    // NIE mo≈ºna przechodziƒá przez wrogie figury
                    var stepsUsed = path.length; // path zawiera start, wiƒôc stepsUsed = ile krok√≥w zrobili≈õmy
                    var isThisLastStep = (stepsUsed >= piece.moves);
                    if (targetPiece && targetPiece.color !== piece.color) {
                        // MO≈ªNA atakowaƒá figurƒô kt√≥ra sama atakuje (≈Ça≈Ñcuch zbiƒá)
                        
                        // KLUCZOWA ZASADA: Figura pod atakiem NIE MO≈ªE atakowaƒá kr√≥la!
                        // To dotyczy wszystkich figur kt√≥re sƒÖ celem pendingCapture
                        if (targetPiece.type === 'king') {
                            var figuraJestAtakowana = false;
                            for (var pci = 0; pci < G.pendingCaptures.length; pci++) {
                                var pendCap = G.pendingCaptures[pci];
                                if (pendCap.targetX === startX && pendCap.targetY === startY) {
                                    figuraJestAtakowana = true;
                                    break;
                                }
                            }
                            if (figuraJestAtakowana) {
                                console.log('BLOKADA ATAKU NA KR√ìLA: Figura na', startX, startY, 'jest pod atakiem i nie mo≈ºe szachowaƒá!');
                                continue;
                            }
                        }
                        
                        // Mo≈ºna zbiƒá tylko w ostatnim kroku
                        if (isThisLastStep) {
                            var newPath = path.slice(); newPath.push({ x: newX, y: newY });
                            allMoves.push(newPath);
                        }
                        // Nie mo≈ºna i≈õƒá dalej przez wroga
                        continue;
                    }
                    
                    var newPath = path.slice(); newPath.push({ x: newX, y: newY });
                    explore(newPath, usedDiag || dir.diagonal);
                }
            }
            explore([{ x: startX, y: startY }], false);
            return allMoves;
        }
        
        function endGame(winner, type) {
            G.gameOver = true;
            if (G.timerInterval) clearInterval(G.timerInterval);
            updateTimerDisplay();
            
            // Sprawd≈∫ czy to remis w mistrzostwach - dogrywka!
            var isDrawType = (type === 'pat' || type === 'repetition' || type === 'noattack' || type === 'draw_agreed');
            if (G.gameMode === 'championship' && isDrawType) {
                // Dogrywka - nowa partia
                championshipOvertimeCount = (championshipOvertimeCount || 0) + 1;
                var overtimeMsg = 'Remis! Dogrywka nr ' + championshipOvertimeCount;
                alert(overtimeMsg);
                
                // Reset i nowa gra
                initBoard();
                startGame();
                return;
            }
            
            // ELO za wynik gry
            var playerWon = false;
            var playerLost = false;
            
            if (G.gameMode === 'bot' || G.gameMode === 'championship') {
                playerWon = (winner === 'white');
                playerLost = (winner === 'black');
            } else if (G.gameMode === 'online') {
                playerWon = (winner === myColor);
                playerLost = (winner !== myColor && type !== 'pat');
            }
            
            // Mistrzostwa - zaktualizuj bracket
            if (G.gameMode === 'championship') {
                finishTournamentMatch(playerWon);
                championshipOvertimeCount = 0; // Reset licznika dogrywek
            }
            
            if (playerWon) {
                var winBonus = type === 'mat' ? 100 : 60;
                if (G.gameMode === 'bot') {
                    if (G.difficulty === 'easy') winBonus = Math.floor(winBonus / 3);
                    else if (G.difficulty === 'medium') winBonus = Math.floor(winBonus / 2);
                } else if (G.gameMode === 'championship' && currentOpponent) {
                    // Mistrzostwa - bonus zale≈ºy od ELO przeciwnika
                    var eloBonus = Math.floor((currentOpponent.elo - 1500) / 10);
                    winBonus = Math.max(50, winBonus + eloBonus);
                }
                addElo(winBonus, type === 'mat' ? 'Mat!' : 'Wygrana!');
            } else if (playerLost) {
                var lossPenalty = -30;
                if (G.gameMode === 'bot') {
                    if (G.difficulty === 'easy') lossPenalty = -50;
                    else if (G.difficulty === 'medium') lossPenalty = -30;
                    else if (G.difficulty === 'hard') lossPenalty = -15;
                } else if (G.gameMode === 'championship') {
                    lossPenalty = -20; // Mniejsza kara w turniejach
                }
                addElo(lossPenalty, 'Przegrana');
            }
            
            // Remis = +30 ELO dla ka≈ºdego (nie w mistrzostwach - tam dogrywka)
            if (isDrawType && (G.gameMode === 'bot' || G.gameMode === 'online')) {
                addElo(30, 'Remis');
            }
            
            var title, message;
            if (type === 'mat') {
                title = 'SZACH MAT!';
                message = (winner === 'white' ? 'Bia≈Çe' : 'Czarne') + ' wygrywajƒÖ!';
            } else if (type === 'czas') {
                title = 'KONIEC CZASU!';
                message = (winner === 'white' ? 'Bia≈Çe' : 'Czarne') + ' wygrywajƒÖ!';
            } else if (type === 'poddanie') {
                title = 'PODDANIE!';
                message = (winner === 'white' ? 'Bia≈Çe' : 'Czarne') + ' wygrywajƒÖ!';
            } else if (type === 'konsola') {
                title = 'DYSKWALIFIKACJA!';
                message = (winner === 'white' ? 'Czarne' : 'Bia≈Çe') + ' otworzy≈Çy konsolƒô - przegrana!';
            } else if (type === 'repetition') {
                title = 'REMIS!';
                message = 'Potr√≥jne powt√≥rzenie pozycji figury!';
            } else {
                title = 'REMIS!';
                message = G.movesWithoutAttack >= 10 ? '10 ruch√≥w bez ataku!' : 'Gracze zgodzili siƒô na remis';
            }
            
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            
            // Poka≈º przycisk rewan≈ºu tylko w trybie online
            var rematchBtn = document.getElementById('rematch-btn');
            var rematchStatus = document.getElementById('rematch-status');
            if (G.gameMode === 'online' && peerConnection) {
                rematchBtn.style.display = 'inline-block';
                rematchStatus.style.display = 'none';
                rematchRequested = false;
                rematchAccepted = false;
            } else {
                rematchBtn.style.display = 'none';
                rematchStatus.style.display = 'none';
            }
            
            document.getElementById('game-over-modal').classList.add('active');
            playSound('gameEnd');
        }
        
        // Funkcje rewan≈ºu
        function requestRematch() {
            if (!peerConnection || !G.gameOver) return;
            
            rematchRequested = true;
            var rematchStatus = document.getElementById('rematch-status');
            rematchStatus.textContent = '‚è≥ Czekam na odpowied≈∫ przeciwnika...';
            rematchStatus.style.display = 'block';
            
            // Wy≈õlij pro≈õbƒô o rewan≈º
            sendPeerData({ type: 'rematch_request' });
        }
        
        function handleRematchRequest() {
            if (rematchRequested) {
                // Obaj chcƒÖ rewan≈ºu - akceptuj!
                rematchAccepted = true;
                sendPeerData({ type: 'rematch_accept' });
                startRematch();
            } else {
                // Poka≈º ≈ºe przeciwnik chce rewan≈ºu
                var rematchStatus = document.getElementById('rematch-status');
                rematchStatus.textContent = 'üîÑ Przeciwnik proponuje rewan≈º! Kliknij przycisk aby zaakceptowaƒá.';
                rematchStatus.style.display = 'block';
                rematchAccepted = true; // Zapamiƒôtaj ≈ºe przeciwnik chce
            }
        }
        
        function handleRematchAccept() {
            startRematch();
        }
        
        function handleRematchDecline() {
            var rematchStatus = document.getElementById('rematch-status');
            rematchStatus.textContent = '‚ùå Przeciwnik odrzuci≈Ç rewan≈º.';
            rematchStatus.style.display = 'block';
            
            // Wr√≥ƒá do menu po 2 sekundach
            setTimeout(function() {
                document.getElementById('game-over-modal').classList.remove('active');
                showScreen('menu');
            }, 2000);
        }
        
        function startRematch() {
            // Zamie≈Ñ kolory
            var oldColor = myColor;
            myColor = (myColor === 'white') ? 'black' : 'white';
            
            // Zamknij modal
            document.getElementById('game-over-modal').classList.remove('active');
            
            // Reset gry - PE≈ÅNY RESET WSZYSTKIEGO
            rematchRequested = false;
            rematchAccepted = false;
            
            // Reset stanu gry
            initBoard();
            G.gameMode = 'online';
            G.currentPlayer = 'white';
            G.selectedPiece = null;
            G.plannedPath = [];
            G.usedDiagonal = false;
            G.pendingCaptures = [];
            G.capturedByWhite = [];
            G.capturedByBlack = [];
            G.moveHistory = [];
            G.gameOver = false;
            G.inCheck = null;
            G.movesWithoutAttack = 0;
            G.piecePositionHistory = {};
            G.doubleAttackPieces = [];
            G.sentinelShields = [];
            G.lastMove = null;
            G.evalBefore = 0;
            G.gameStates = [];
            G.currentStateIndex = -1;
            G.analyzing = false;
            G.whatIfMode = false;
            
            // Reset czas√≥w
            G.timeLimit = lobbyTimeLimit * 60;
            G.increment = lobbyIncrement;
            G.whiteTime = G.timeLimit;
            G.blackTime = G.timeLimit;
            if (G.timerInterval) clearInterval(G.timerInterval);
            startTimer();
            
            // Wyczy≈õƒá historiƒô ruch√≥w w UI
            var historyList = document.getElementById('history-list');
            if (historyList) historyList.innerHTML = '';
            
            // Reset paska ewaluacji
            var evalBar = document.getElementById('eval-bar');
            if (evalBar) {
                var evalFill = evalBar.querySelector('.eval-fill');
                if (evalFill) evalFill.style.height = '50%';
            }
            
            // Ustaw info o turze
            var turnInfo = document.getElementById('turn-info');
            if (turnInfo) {
                turnInfo.textContent = myColor === 'white' ? 'Tw√≥j ruch!' : 'Ruch przeciwnika...';
            }
            
            // Zapisz poczƒÖtkowy stan
            saveGameState('Start', 'white');
            
            renderBoard();
            updateUI();
            updateTimerDisplay();
            updateEvalBar();
        }
        
        function makeBotMove() {
            if (G.gameOver) return;
            
            // Czas namys≈Çu zale≈ºny od trudno≈õci
            var thinkTime = G.difficulty === 'easy' ? 800 : G.difficulty === 'hard' ? 2500 : 1500;
            
            // Sprawd≈∫ czy Nexus jest zagro≈ºony - PRIORYTET
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.isNexusLock) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target && target.type === 'king' && target.color === 'black') {
                        var nexusMoves = getAllMovesForPiece(cap.targetX, cap.targetY, target, true);
                        if (nexusMoves.length > 0) {
                            // Wybierz najbezpieczniejsze pole
                            var bestMove = selectSafestMove(nexusMoves, cap.targetX, cap.targetY);
                            G.selectedPiece = { x: cap.targetX, y: cap.targetY };
                            G.plannedPath = bestMove;
                            executeMove(); return;
                        }
                    }
                }
            }
            
            // Uciekaj zablokowanymi figurami
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (!cap.isNexusLock) {
                    var target = G.board[cap.targetY] ? G.board[cap.targetY][cap.targetX] : null;
                    if (target && target.color === 'black') {
                        var escapeMoves = getAllMovesForPiece(cap.targetX, cap.targetY, target, true);
                        if (escapeMoves.length > 0) {
                            var bestMove = selectSafestMove(escapeMoves, cap.targetX, cap.targetY);
                            G.selectedPiece = { x: cap.targetX, y: cap.targetY };
                            G.plannedPath = bestMove;
                            executeMove(); return;
                        }
                    }
                }
            }
            
            var allMoves = [];
            
            // Zbierz ruchy Stra≈ºnik√≥w (czarnych tarcz)
            for (var s = 0; s < G.sentinelShields.length; s++) {
                var shield = G.sentinelShields[s];
                if (shield.color === 'black') {
                    var guardianPiece = {
                        symbol: SENTINEL_GUARDIAN.symbol,
                        name: SENTINEL_GUARDIAN.name,
                        moves: SENTINEL_GUARDIAN.moves,
                        type: 'guardian',
                        straightOnly: true,
                        color: 'black',
                        isGuardian: true,
                        shieldIndex: s
                    };
                    var gx = shield.guardianX, gy = shield.guardianY;
                    if (!G.board[gy][gx]) {
                        G.board[gy][gx] = guardianPiece;
                        var guardianMoves = getAllMovesForPiece(gx, gy, guardianPiece, false);
                        G.board[gy][gx] = null;
                        
                        for (var m = 0; m < guardianMoves.length; m++) {
                            var path = guardianMoves[m];
                            if (path.length > 1) {
                                var endPos = path[path.length - 1];
                                var target = G.board[endPos.y][endPos.x];
                                if (target && target.color === 'white') {
                                    var score = evaluateMoveDeep(gx, gy, endPos.x, endPos.y, guardianPiece, target);
                                    allMoves.push({ from: { x: gx, y: gy, isGuardian: true, shieldIndex: s }, path: path, piece: guardianPiece, score: score });
                                }
                            }
                        }
                    }
                }
            }
            
            // Zbierz ruchy normalnych figur
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var piece = G.board[y][x];
                    if (piece && piece.color === 'black') {
                        if (isPieceAttacking(x, y)) continue;
                        if (piece.frozenTurns && piece.frozenTurns > 0) continue;
                        
                        var moves = getAllMovesForPiece(x, y, piece, isPieceLocked(x, y));
                        for (var m = 0; m < moves.length; m++) {
                            var path = moves[m];
                            if (path.length > 1) {
                                var endPos = path[path.length - 1];
                                var target = G.board[endPos.y][endPos.x];
                                var score = evaluateMoveDeep(x, y, endPos.x, endPos.y, piece, target);
                                allMoves.push({ from: { x: x, y: y }, path: path, piece: piece, score: score });
                            }
                        }
                    }
                }
            }
            
            if (allMoves.length === 0) {
                console.log('BOT ERROR: Brak ruch√≥w! currentPlayer:', G.currentPlayer, 'gameOver:', G.gameOver);
                return;
            }
            
            // Sortuj i wybierz ruch zale≈ºnie od trudno≈õci
            allMoves.sort(function(a, b) { return b.score - a.score; });
            
            var selectedMove;
            if (G.difficulty === 'hard') {
                // Na trudnym - ZAWSZE najlepszy ruch
                selectedMove = allMoves[0];
            } else if (G.difficulty === 'easy') {
                // Na ≈Çatwym - losowy z g√≥rnej po≈Çowy
                var poolSize = Math.max(3, Math.floor(allMoves.length / 2));
                selectedMove = allMoves[Math.floor(Math.random() * Math.min(poolSize, allMoves.length))];
            } else {
                // ≈öredni - top 3
                selectedMove = allMoves[Math.floor(Math.random() * Math.min(3, allMoves.length))];
            }
            
            G.selectedPiece = selectedMove.from;
            G.plannedPath = selectedMove.path;
            
            if (selectedMove.from.isGuardian) {
                G.board[selectedMove.from.y][selectedMove.from.x] = selectedMove.piece;
            }
            
            for (var j = 1; j < selectedMove.path.length; j++) {
                var prev = selectedMove.path[j-1], curr = selectedMove.path[j];
                if (Math.abs(curr.x - prev.x) === 1 && Math.abs(curr.y - prev.y) === 1) { G.usedDiagonal = true; break; }
            }
            executeMove();
        }
        
        // Wybierz najbezpieczniejszy ruch ucieczki
        function selectSafestMove(moves, fromX, fromY) {
            var bestMove = moves[0];
            var bestSafety = -Infinity;
            
            for (var i = 0; i < moves.length; i++) {
                var path = moves[i];
                var endPos = path[path.length - 1];
                var safety = 0;
                
                // Czy pole jest zagro≈ºone?
                if (!isSquareThreatened(endPos.x, endPos.y, 'white')) {
                    safety += 100;
                }
                
                // Odleg≈Ço≈õƒá od centrum (centrum = bezpieczniej dla kr√≥la? nie zawsze)
                safety += (3.5 - Math.abs(endPos.x - 3.5)) * 2;
                
                // Czy jest blisko w≈Çasnych figur (ochrona)?
                for (var dy = -1; dy <= 1; dy++) {
                    for (var dx = -1; dx <= 1; dx++) {
                        var nx = endPos.x + dx, ny = endPos.y + dy;
                        if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
                            var p = G.board[ny][nx];
                            if (p && p.color === 'black' && p.type !== 'king') {
                                safety += 5;
                            }
                        }
                    }
                }
                
                if (safety > bestSafety) {
                    bestSafety = safety;
                    bestMove = path;
                }
            }
            return bestMove;
        }
        
        // G≈Çƒôboka ocena ruchu
        function evaluateMoveDeep(fromX, fromY, toX, toY, piece, targetPiece) {
            var score = 0;
            var pieceValues = { king: 10000, queen: 900, rook: 500, bishop: 320, knight: 300, pawn: 100, guardian: 400 };
            
            // 1. Warto≈õƒá zbicia
            if (targetPiece) {
                score += pieceValues[targetPiece.type] || 100;
                // Bonus za zbicie Phantoma (nie mo≈ºe uciec)
                if (targetPiece.type === 'queen') score += 300;
                // OGROMNY bonus za atak na kr√≥la
                if (targetPiece.type === 'king') {
                    score += 8000;
                    // Sprawd≈∫ czy kr√≥l mo≈ºe uciec
                    var kingMoves = getAllMovesForPiece(toX, toY, targetPiece, true);
                    if (kingMoves.length === 0) {
                        score += 50000; // TO JEST MAT!
                    } else if (kingMoves.length === 1) {
                        score += 3000; // Tylko jedna ucieczka
                    }
                }
            }
            
            // 2. TWORZENIE PODW√ìJNEGO ATAKU - sprawd≈∫ czy po naszym ruchu bƒôdzie podw√≥jny atak
            if (targetPiece && targetPiece.type !== 'king') {
                // Symuluj ruch
                var originalTarget = G.board[toY][toX];
                var originalFrom = G.board[fromY][fromX];
                G.board[toY][toX] = piece;
                G.board[fromY][fromX] = null;
                
                // Sprawd≈∫ czy jest ju≈º inna blokada na tym celu
                for (var i = 0; i < G.pendingCaptures.length; i++) {
                    var cap = G.pendingCaptures[i];
                    if (cap.targetX === toX && cap.targetY === toY && cap.attackerColor === 'black') {
                        // Bƒôdzie podw√≥jny atak!
                        if (targetPiece.type === 'king') {
                            score += 100000; // MAT przez podw√≥jny atak!
                        } else {
                            score += pieceValues[targetPiece.type] * 3; // Gwarantowane zbicie
                        }
                    }
                }
                
                // Przywr√≥ƒá
                G.board[fromY][fromX] = originalFrom;
                G.board[toY][toX] = originalTarget;
            }
            
            // 3. Symuluj ruch i oce≈Ñ pozycjƒô
            var originalTarget2 = G.board[toY][toX];
            var originalFrom2 = G.board[fromY][fromX];
            G.board[toY][toX] = piece;
            G.board[fromY][fromX] = null;
            
            var positionScore = evaluatePositionDeep('black');
            
            // Przywr√≥ƒá
            G.board[fromY][fromX] = originalFrom2;
            G.board[toY][toX] = originalTarget2;
            
            score += positionScore * 0.5;
            
            // 4. Kontrola centrum
            var centerDist = Math.abs(toX - 3.5) + Math.abs(toY - 3.5);
            score += (7 - centerDist) * 15;
            
            // 5. Bezpiecze≈Ñstwo figury po ruchu
            if (isSquareThreatened(toX, toY, 'white')) {
                score -= pieceValues[piece.type] * 0.4;
            }
            
            // 6. Rozw√≥j figur
            if (fromY === 7 && toY < 7) {
                score += 30;
            }
            
            // 7. Pionki - bonus za awans
            if (piece.type === 'pawn') {
                score += toY * 30;
                if (toY >= 5) score += 80;
                if (toY >= 6) score += 200; // Prawie promocja!
            }
            
            // 8. Tworzenie tarczy
            if (piece.type === 'rook') {
                score += getBotShieldBonus(fromX, fromY, toX, toY) * 3;
            }
            
            // 9. Atakowanie wielu figur naraz
            var attackCount = countThreatenedEnemies(toX, toY, piece);
            score += attackCount * 40;
            
            // 10. Ochrona w≈Çasnego kr√≥la
            var kingPos = findKing('black');
            if (kingPos) {
                var distToKing = Math.abs(toX - kingPos.x) + Math.abs(toY - kingPos.y);
                if (distToKing <= 2) score += 30;
            }
            
            // 11. KARA za podstawienie pod podw√≥jny atak
            if (!targetPiece) {
                var attacksOnSquare = countAttacksOnSquare(toX, toY, 'white');
                if (attacksOnSquare >= 2) {
                    score -= pieceValues[piece.type] * 3; // Pewna strata!
                } else if (attacksOnSquare === 1 && isSquareThreatened(toX, toY, 'white')) {
                    score -= pieceValues[piece.type] * 0.4;
                }
            }
            
            // 12. OGROMNA KARA za podstawienie Phantoma pod bicie
            if (piece.type === 'queen' && isSquareThreatened(toX, toY, 'white')) {
                score -= pieceValues[piece.type] * 2;
            }
            
            // 13. Sprawd≈∫ czy po ruchu zostawiamy co≈õ bez obrony
            var originalTarget3 = G.board[toY][toX];
            var originalFrom3 = G.board[fromY][fromX];
            G.board[toY][toX] = piece;
            G.board[fromY][fromX] = null;
            
            for (var cy = 0; cy < 8; cy++) {
                for (var cx = 0; cx < 8; cx++) {
                    var checkPiece = G.board[cy][cx];
                    if (checkPiece && checkPiece.color === 'black' && checkPiece.type !== 'king') {
                        if (isSquareThreatened(cx, cy, 'white')) {
                            var defended = isSquareDefended(cx, cy, 'black');
                            if (!defended) {
                                score -= pieceValues[checkPiece.type] * 0.6;
                            }
                        }
                    }
                }
            }
            
            // Przywr√≥ƒá
            G.board[fromY][fromX] = originalFrom3;
            G.board[toY][toX] = originalTarget3;
            
            // 14. Losowo≈õƒá dla trudno≈õci
            if (G.gameMode === 'championship' && G.botRandomness !== undefined) {
                // Mistrzostwa - losowo≈õƒá zale≈ºy od ELO przeciwnika
                score += Math.random() * G.botRandomness;
            } else if (G.difficulty === 'easy') {
                score += Math.random() * 150;
            } else if (G.difficulty === 'medium') {
                score += Math.random() * 40;
            } else {
                score += Math.random() * 2;
            }
            
            return score;
        }
        
        // Policz ile atak√≥w jest na dane pole
        function countAttacksOnSquare(x, y, byColor) {
            var count = 0;
            
            // Sprawd≈∫ pending captures
            for (var i = 0; i < G.pendingCaptures.length; i++) {
                var cap = G.pendingCaptures[i];
                if (cap.targetX === x && cap.targetY === y && cap.attackerColor === byColor) {
                    count++;
                }
            }
            
            // Sprawd≈∫ czy figury mogƒÖ zaatakowaƒá to pole
            for (var py = 0; py < 8; py++) {
                for (var px = 0; px < 8; px++) {
                    var p = G.board[py][px];
                    if (p && p.color === byColor) {
                        var moves = getAllMovesForPiece(px, py, p, false);
                        for (var m = 0; m < moves.length; m++) {
                            var path = moves[m];
                            if (path.length > 1) {
                                var endPos = path[path.length - 1];
                                if (endPos.x === x && endPos.y === y) {
                                    count++;
                                    break; // Jedna figura = jeden atak
                                }
                            }
                        }
                    }
                }
            }
            
            return count;
        }
        
        // Czy pole jest bronione przez dany kolor
        function isSquareDefended(x, y, byColor) {
            for (var py = 0; py < 8; py++) {
                for (var px = 0; px < 8; px++) {
                    var p = G.board[py][px];
                    if (p && p.color === byColor && !(px === x && py === y)) {
                        // Sprawd≈∫ czy ta figura mo≈ºe "zbiƒá" na tym polu (czyli broniƒá)
                        var moves = getAllMovesForPiece(px, py, p, false);
                        for (var m = 0; m < moves.length; m++) {
                            var path = moves[m];
                            if (path.length > 1) {
                                var endPos = path[path.length - 1];
                                if (endPos.x === x && endPos.y === y) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        // Znajd≈∫ kr√≥la
        function findKing(color) {
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'king' && p.color === color) {
                        return {x: x, y: y};
                    }
                }
            }
            return null;
        }
        
        // Policz ile wrogich figur zagro≈ºonych z danego pola
        function countThreatenedEnemies(x, y, piece) {
            var count = 0;
            var directions = [];
            
            if (piece.straightOnly) {
                directions = ['n', 's', 'e', 'w'];
            } else if (piece.diagonalOnly) {
                directions = ['ne', 'nw', 'se', 'sw'];
            } else {
                directions = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
            }
            
            directions.forEach(function(key) {
                var dir = DIRECTIONS[key];
                for (var step = 1; step <= piece.moves; step++) {
                    var nx = x + dir.dx * step;
                    var ny = y + dir.dy * step;
                    if (nx < 0 || nx > 7 || ny < 0 || ny > 7) break;
                    var target = G.board[ny][nx];
                    if (target) {
                        if (target.color === 'white') count++;
                        break;
                    }
                }
            });
            
            return count;
        }
        
        // G≈Çƒôboka ocena pozycji
        function evaluatePositionDeep(forColor) {
            var pieceValues = { king: 10000, queen: 900, rook: 500, bishop: 320, knight: 300, pawn: 100 };
            var score = 0;
            
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var piece = G.board[y][x];
                    if (!piece) continue;
                    
                    var value = pieceValues[piece.type] || 0;
                    
                    // Pozycja - centrum lepsze
                    var centerBonus = (3.5 - Math.abs(x - 3.5)) * 5 + (3.5 - Math.abs(y - 3.5)) * 5;
                    value += centerBonus;
                    
                    // Pionki - awans
                    if (piece.type === 'pawn') {
                        if (piece.color === 'white') {
                            value += (7 - y) * 15;
                        } else {
                            value += y * 15;
                        }
                    }
                    
                    // Mobilno≈õƒá - ile ruch√≥w ma figura
                    var moves = getAllMovesForPiece(x, y, piece, false);
                    value += moves.length * 3;
                    
                    // Bezpiecze≈Ñstwo
                    var enemyColor = piece.color === 'white' ? 'black' : 'white';
                    if (isSquareThreatened(x, y, enemyColor)) {
                        value -= pieceValues[piece.type] * 0.1;
                    }
                    
                    if (piece.color === forColor) {
                        score += value;
                    } else {
                        score -= value;
                    }
                }
            }
            
            // Sprawd≈∫ szachy
            if (G.inCheck === 'white' && forColor === 'black') score += 200;
            if (G.inCheck === 'black' && forColor === 'white') score += 200;
            
            return score;
        }
        
        // Bonus dla bota za ustawianie wie≈º w linii (tworzenie tarczy)
        function getBotShieldBonus(fromX, fromY, toX, toY) {
            var bonus = 0;
            // Znajd≈∫ inne czarne wie≈ºe
            for (var y = 0; y < 8; y++) {
                for (var x = 0; x < 8; x++) {
                    var p = G.board[y][x];
                    if (p && p.type === 'rook' && p.color === 'black' && !(x === fromX && y === fromY)) {
                        // Czy po ruchu bƒôdƒÖ w jednej linii?
                        if (toX === x || toY === y) {
                            // Sprawd≈∫ czy miƒôdzy nimi nie bƒôdzie figur
                            var clear = true;
                            if (toX === x) {
                                var minY = Math.min(toY, y), maxY = Math.max(toY, y);
                                for (var cy = minY + 1; cy < maxY; cy++) {
                                    if (G.board[cy][x] && !(cy === fromY && x === fromX)) clear = false;
                                }
                            } else {
                                var minX = Math.min(toX, x), maxX = Math.max(toX, x);
                                for (var cx = minX + 1; cx < maxX; cx++) {
                                    if (G.board[toY][cx] && !(toY === fromY && cx === fromX)) clear = false;
                                }
                            }
                            if (clear) bonus += 25; // Bonus za tworzenie tarczy
                        }
                    }
                }
            }
            return bonus;
        }
        
        document.querySelectorAll('.nav-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.nav-btn').forEach(function(b) { b.classList.remove('active'); });
                document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
                btn.classList.add('active');
                var screen = document.getElementById(btn.dataset.screen + '-screen');
                if (screen) screen.classList.add('active');
            });
        });
        document.querySelectorAll('.mode-card').forEach(function(card) {
            card.addEventListener('click', function() {
                if (card.dataset.mode === 'online') {
                    createLobby();
                    return;
                }
                if (card.dataset.mode === 'championship') {
                    var champSelect = document.getElementById('championship-select');
                    var timeSelect = document.getElementById('time-select');
                    var diffSelect = document.getElementById('difficulty-select');
                    if (champSelect) champSelect.style.display = 'block';
                    if (timeSelect) timeSelect.style.display = 'none';
                    if (diffSelect) diffSelect.style.display = 'none';
                    updateChampionshipCards();
                    return;
                }
                var champSelect2 = document.getElementById('championship-select');
                if (champSelect2) champSelect2.style.display = 'none';
                G.gameMode = card.dataset.mode;
                var timeSelect2 = document.getElementById('time-select');
                if (timeSelect2) timeSelect2.style.display = 'block';
                if (card.dataset.mode === 'bot') {
                    var diffSelect2 = document.getElementById('difficulty-select');
                    if (diffSelect2) diffSelect2.style.display = 'block';
                } else {
                    var diffSelect3 = document.getElementById('difficulty-select');
                    if (diffSelect3) diffSelect3.style.display = 'none';
                }
            });
        });
        // Obs≈Çuga kart mistrzostw
        document.querySelectorAll('.championship-card').forEach(function(card) {
            card.addEventListener('click', function() {
                selectChampionship(card.dataset.championship);
            });
        });
        document.querySelectorAll('.diff-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.diff-btn').forEach(function(b) { b.classList.remove('selected'); });
                btn.classList.add('selected');
                G.difficulty = btn.dataset.diff;
            });
        });
        // Menu time buttons (nie lobby)
        document.querySelectorAll('#time-select .time-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('#time-select .time-btn').forEach(function(b) { b.classList.remove('selected'); });
                btn.classList.add('selected');
                G.timeLimit = parseInt(btn.dataset.time);
                var incSelect = document.getElementById('increment-select');
                if (G.timeLimit > 0) {
                    if (incSelect) incSelect.style.display = 'block';
                } else {
                    if (incSelect) incSelect.style.display = 'none';
                    G.increment = 0;
                    startGame();
                }
            });
        });
        document.querySelectorAll('#increment-select .inc-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('#increment-select .inc-btn').forEach(function(b) { b.classList.remove('selected'); });
                btn.classList.add('selected');
                G.increment = parseInt(btn.dataset.inc);
                startGame();
            });
        });
        // Lobby time buttons
        document.querySelectorAll('.lobby-time-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.lobby-time-btn').forEach(function(b) { b.classList.remove('selected'); });
                btn.classList.add('selected');
                lobbyTimeLimit = parseInt(btn.dataset.time);
                var incSection = document.getElementById('lobby-increment');
                if (lobbyTimeLimit > 0) {
                    incSection.style.display = 'block';
                } else {
                    incSection.style.display = 'none';
                    lobbyIncrement = 0;
                }
            });
        });
        document.querySelectorAll('.lobby-inc-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.lobby-inc-btn').forEach(function(b) { b.classList.remove('selected'); });
                btn.classList.add('selected');
                lobbyIncrement = parseInt(btn.dataset.inc);
            });
        });
        document.getElementById('new-game-btn').addEventListener('click', function() {
            var gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) gameOverModal.classList.remove('active');
            if (G.timerInterval) clearInterval(G.timerInterval);
            
            // Je≈õli to by≈Ç mecz turniejowy, wr√≥ƒá do turnieju
            if (G.gameMode === 'championship' && currentTournament) {
                showScreen('tournament');
                renderTournament();
                return;
            }
            
            document.querySelectorAll('.nav-btn').forEach(function(b) { b.classList.remove('active'); });
            document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
            var menuNavBtn = document.querySelector('[data-screen="menu"]');
            if (menuNavBtn) menuNavBtn.classList.add('active');
            var menuScreen = document.getElementById('menu-screen');
            if (menuScreen) menuScreen.classList.add('active');
            // Ukryj info o przeciwniku
            var oppInfo = document.getElementById('opponent-info');
            if (oppInfo) oppInfo.style.display = 'none';
            // Reset menu selections
            var diffSelect = document.getElementById('difficulty-select');
            var timeSelect = document.getElementById('time-select');
            var incSelect = document.getElementById('increment-select');
            var champSelect = document.getElementById('championship-select');
            if (diffSelect) diffSelect.style.display = 'none';
            if (timeSelect) timeSelect.style.display = 'none';
            if (incSelect) incSelect.style.display = 'none';
            if (champSelect) champSelect.style.display = 'none';
            document.querySelectorAll('.diff-btn, .time-btn, .inc-btn').forEach(function(b) { b.classList.remove('selected'); });
        });
        document.getElementById('show-zones').addEventListener('change', function() {
            G.showZones = this.checked;
            renderBoard();
        });
        document.getElementById('show-eval').addEventListener('change', function() {
            G.showEval = this.checked;
            var evalBar = document.getElementById('eval-bar');
            var moveIconsLegend = document.querySelector('.move-icons-legend');
            if (evalBar) {
                evalBar.style.display = this.checked ? 'block' : 'none';
            }
            if (moveIconsLegend) {
                moveIconsLegend.style.display = this.checked ? 'flex' : 'none';
            }
            // Ukryj/poka≈º ikony na figurach
            renderBoard();
        });
        document.getElementById('btn-first').addEventListener('click', function() { loadGameState(0); });
        document.getElementById('btn-prev').addEventListener('click', function() { navigateState(-1); });
        document.getElementById('btn-next').addEventListener('click', function() { navigateState(1); });
        document.getElementById('btn-last').addEventListener('click', function() { loadGameState(G.gameStates.length - 1); });
        document.getElementById('btn-reset-whatif').addEventListener('click', function() { resetWhatIfMode(); });
        
        // Przyciski remisu/poddania
        document.getElementById('btn-offer-draw').addEventListener('click', offerDraw);
        document.getElementById('btn-resign').addEventListener('click', resignGame);
        document.getElementById('draw-accept').addEventListener('click', acceptDraw);
        document.getElementById('draw-decline').addEventListener('click', declineDraw);
        
        // Przycisk rewan≈ºu
        document.getElementById('rematch-btn').addEventListener('click', function() {
            if (rematchAccepted) {
                // Przeciwnik ju≈º zaproponowa≈Ç - akceptujemy
                sendPeerData({ type: 'rematch_accept' });
                startRematch();
            } else {
                // My proponujemy
                requestRematch();
            }
        });
        
        function startGame() {
            document.querySelectorAll('.nav-btn').forEach(function(b) { b.classList.remove('active'); });
            document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
            document.querySelector('[data-screen="game"]').classList.add('active');
            document.getElementById('game-screen').classList.add('active');
            resetGame();
        }
        
        // Inicjalizacja
        initProfile();
        checkLobbyUrl();
        initBoard();
        renderBoard(); updateUI(); updateEvalBar();
        updateTrophyCount();
    </script>
</body>
</html>